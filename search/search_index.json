{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Home","text":"<p><code>quacc</code> (pronounced \"quack\" \ud83e\udd86) is a flexible platform for high-throughput computational materials science and quantum chemistry built for the exascale era, maintained by the Rosen Research Group at Princeton University.</p> <ul> <li> <p><code>quacc</code> makes it possible to easily run pre-made workflows that can be efficiently dispatched anywhere: locally, HPC, the cloud, or any combination thereof.</p> </li> <li> <p><code>quacc</code> leverages community resources. It is built around the Atomic Simulation Environment and much of the software infrastructure powering the Materials Project.</p> </li> <li> <p><code>quacc</code> gives you the freedom of choice. Through a single, unified interface to several supported workflow management solutions, <code>quacc</code> lets you use what best suits your unique computing needs.</p> </li> </ul> <p></p>"},{"location":"about/changelog.html","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"about/changelog.html#042","title":"[0.4.2]","text":""},{"location":"about/changelog.html#added","title":"Added","text":"<ul> <li>Added a Jenkins-based test suite that runs tests on HPC resources without mocking</li> <li>Added a TBLite phonon recipe</li> </ul>"},{"location":"about/changelog.html#fixed","title":"Fixed","text":"<ul> <li>Fixed functional and basis set strings in Gaussian recipes</li> <li>Uses number of physical cores instead of logical cores as default for molecular DFT recipes</li> </ul>"},{"location":"about/changelog.html#041","title":"[0.4.1]","text":""},{"location":"about/changelog.html#changed","title":"Changed","text":"<ul> <li>Switched to using the PyPi release of NewtonNet (1.1).</li> <li>NewtonNet recipes don't run a Hessian calculation by default unless needed</li> </ul>"},{"location":"about/changelog.html#fixed_1","title":"Fixed","text":"<ul> <li>Fixed circular import issue when running Q-Chem calculations.</li> </ul>"},{"location":"about/changelog.html#removed","title":"Removed","text":"<ul> <li>Removed unsupported <code>qchem_internal_relax_job</code></li> </ul>"},{"location":"about/changelog.html#040","title":"[0.4.0]","text":""},{"location":"about/changelog.html#added_1","title":"Added","text":"<ul> <li>Added <code>quacc.recipes.common</code>, including <code>quacc.recipes.common.slabs</code>, <code>quacc.recipes.common.defects</code>, and <code>quacc.recipes.common.phonons</code></li> <li>Added phonopy schema in <code>quacc.schemas.phonons</code></li> <li>Added EMT phonon workflow</li> </ul>"},{"location":"about/changelog.html#changed_1","title":"Changed","text":"<ul> <li>The method for specifying swaps to the default calculator arguments in recipes has been overhauled. In place of the previous <code>calc_swaps: dict</code> approach, additional parameters can be specified via the <code>**kwargs</code>. In practice, this means in recipes you can do <code>scf = \"diis\", max_steps=100</code> instead of <code>calc_swaps={\"scf\":\"diis\", \"max_steps\":100}</code>, for instance.</li> <li>Moved <code>quacc.runners.calc</code> to <code>quacc.runners.ase</code></li> <li>Moved <code>quacc.runners.prep</code> to <code>quacc.schemas.prep</code></li> <li>Reduced code duplication across complex flows</li> </ul>"},{"location":"about/changelog.html#0313","title":"[0.3.13]","text":""},{"location":"about/changelog.html#fixed_2","title":"Fixed","text":"<ul> <li>Fixed support for the most recent version of ASE as of 11/2/2023</li> </ul>"},{"location":"about/changelog.html#0312","title":"[0.3.12]","text":""},{"location":"about/changelog.html#added_2","title":"Added","text":"<ul> <li>Added more type hints for input keyword arguments</li> <li>Added the <code>quacc info</code> command-line argument for error reporting</li> </ul>"},{"location":"about/changelog.html#changed_2","title":"Changed","text":"<ul> <li>Consolidated VASP INCAR co-pilot settings</li> <li>Internal refactoring of the Q-Chem and VASP calculators</li> </ul>"},{"location":"about/changelog.html#fixed_3","title":"Fixed","text":"<ul> <li>All <code>Path</code>-based settings have <code>.expanduser()</code> applied</li> </ul>"},{"location":"about/changelog.html#0311","title":"[0.3.11]","text":""},{"location":"about/changelog.html#changed_3","title":"Changed","text":"<ul> <li>Improved error handling</li> </ul>"},{"location":"about/changelog.html#0310","title":"[0.3.10]","text":""},{"location":"about/changelog.html#changed_4","title":"Changed","text":"<ul> <li>DFTB+ <code>MaxSccIterations</code> set to 200 by default</li> <li>SCC errors in DFTB+ relaxations will be reported with higher priority than a relaxation error</li> </ul>"},{"location":"about/changelog.html#039","title":"[0.3.9]","text":""},{"location":"about/changelog.html#changed_5","title":"Changed","text":"<ul> <li>Changed prefix of scratch directories to have the datetime in it for easier debugging</li> </ul>"},{"location":"about/changelog.html#fixed_4","title":"Fixed","text":"<ul> <li>DFTB+ recipes now won't crash when <code>kpts=None</code> for structures with PBCs</li> </ul>"},{"location":"about/changelog.html#038","title":"[0.3.8]","text":""},{"location":"about/changelog.html#changed_6","title":"Changed","text":"<ul> <li>Changed minimum version of Parsl</li> </ul>"},{"location":"about/changelog.html#037","title":"[0.3.7]","text":""},{"location":"about/changelog.html#added_3","title":"Added","text":"<ul> <li>Added type-hinting for schemas</li> </ul>"},{"location":"about/changelog.html#changed_7","title":"Changed","text":"<ul> <li>Recipes now take <code>Atoms</code> instead of <code>Atoms | dict</code> as input</li> <li>Recipes no longer require the use of <code>fetch_atoms</code></li> <li>Standardized schema fields</li> </ul>"},{"location":"about/changelog.html#removed_1","title":"Removed","text":"<ul> <li>Removed the <code>fetch_atoms</code> function</li> </ul>"},{"location":"about/changelog.html#036","title":"[0.3.6]","text":""},{"location":"about/changelog.html#fixed_5","title":"Fixed","text":"<ul> <li>Fixed VASP recipes to always respect <code>calc_swaps</code>.</li> <li>Fixed setting multiple cores in Custodian for Q-Chem runs.</li> </ul>"},{"location":"about/changelog.html#035","title":"[0.3.5]","text":""},{"location":"about/changelog.html#added_4","title":"Added","text":"<ul> <li>Added a new <code>VibThermoSchema</code> that merges the <code>VibSchema</code> and <code>ThermoSchema</code> as a convenience</li> </ul>"},{"location":"about/changelog.html#changed_8","title":"Changed","text":"<ul> <li>The output of recies no longer automatically removes blank lists/dicts/sets to maintain a consistent schema.</li> <li>The tblite <code>freq_job</code> and lj <code>freq_job</code> now use <code>VibThermoSchema</code> as the output</li> <li>Changed default <code>SCRATCH_DIR</code> from <code>Path.cwd() / \".scratch\"</code> to <code>Path(\"~/.scratch\")</code></li> </ul>"},{"location":"about/changelog.html#034","title":"[0.3.4]","text":""},{"location":"about/changelog.html#added_5","title":"Added","text":"<ul> <li>Added a new documentation section for worked examples on HPC.</li> </ul>"},{"location":"about/changelog.html#changed_9","title":"Changed","text":"<ul> <li>Updated the minimum required versions for Pymatgen and emmet-core to reflect Pydantic 2 update.</li> <li>Added <code>symprec=1e-8</code> to the default parameters of VASP relaxation jobs.</li> <li>VASP bulk recipes now use \"BulkSet\" as the default preset instead of <code>None</code>.</li> <li>VASP slab recipes now use \"SlabSet\" as the default preset instead of <code>None</code>.</li> </ul>"},{"location":"about/changelog.html#033","title":"[0.3.3]","text":""},{"location":"about/changelog.html#fixed_6","title":"Fixed","text":"<ul> <li>Fixed pip version conflict when installing Covalent dependencies.</li> </ul>"},{"location":"about/changelog.html#032","title":"[0.3.2]","text":""},{"location":"about/changelog.html#changed_10","title":"Changed","text":"<ul> <li>Migration to Pydantic 2 is complete, along with the corresponding dependencies.</li> </ul>"},{"location":"about/changelog.html#031","title":"[0.3.1]","text":""},{"location":"about/changelog.html#changed_11","title":"Changed","text":"<ul> <li>Pydantic field type validation has been improved.</li> <li>Moved <code>quacc.utils.atoms</code>/<code>.slabs</code>/<code>.defects</code> into <code>quacc.atoms.core</code>/<code>.slabs</code>/<code>.defects</code></li> <li>Moved <code>quacc.custodian</code> to <code>quacc.calculators.custodian</code></li> <li>Moved <code>quacc.utils.thermo.ideal_gas</code> to <code>quacc.builders.thermo.run_ideal_gas</code></li> <li>Renamed <code>quacc.schemas.ase.summarize_thermo</code> to <code>quacc.schemas.ase.summarize_ideal_gas_thermo</code></li> </ul>"},{"location":"about/changelog.html#030","title":"[0.3.0]","text":""},{"location":"about/changelog.html#changed_12","title":"Changed","text":"<ul> <li>Changed default <code>SCRATCH_DIR</code> from <code>/tmp</code> to <code>Path.cwd() / .scratch</code></li> <li>Refactored decorator handling to be more concise</li> <li>Renamed <code>[optimizers]</code> extras to <code>[sella]</code></li> <li>Moved <code>quacc.utils.wflows</code> into <code>quacc.wflow_tools.decorators</code> and <code>quacc.wflow_tools.prefect</code></li> <li>Moved <code>quacc.utils.db</code> into <code>quacc.wflow_tools.db</code></li> <li>Moved <code>quacc.utils.calc</code> to <code>quacc.runners.ase</code></li> <li>Moved <code>quacc.presets</code> to <code>quacc.calculators.presets</code></li> </ul>"},{"location":"about/changelog.html#fixed_7","title":"Fixed","text":"<ul> <li>Fixed parsing of <code>RESULTS_DIR</code> and <code>SCRATCH_DIR</code> paths when they contain <code>~</code></li> <li>Symlinks are no longer created if <code>RESULTS_DIR == SCRATCH_DIR</code> since this is redundant</li> <li>If <code>RESULTS_DIR</code> or <code>SCRATCH_DIR</code> are not present, they will be automatically made</li> </ul>"},{"location":"about/changelog.html#028","title":"[0.2.8]","text":""},{"location":"about/changelog.html#changed_13","title":"Changed","text":"<ul> <li>Decorators are now applied at import time rather than at function-call time.</li> </ul>"},{"location":"about/changelog.html#fixed_8","title":"Fixed","text":"<ul> <li>Fixed compatibility with FireWorks.</li> <li>Fixed I/O issue on Windows and NFS file systems where Sella optimizations would crash.</li> </ul>"},{"location":"about/changelog.html#027","title":"[0.2.7]","text":""},{"location":"about/changelog.html#added_6","title":"Added","text":"<ul> <li>Added a <code>freq_job</code> recipe in Q-Chem (@samblau)</li> <li>Added support for TRICs in Sella calculations (@samblau)</li> </ul>"},{"location":"about/changelog.html#changed_14","title":"Changed","text":"<ul> <li>Refactored all recipes to prevent code duplication</li> <li>Set <code>LREAL = False</code> in VASP <code>BulkSet.yaml</code></li> </ul>"},{"location":"about/changelog.html#026","title":"[0.2.6]","text":""},{"location":"about/changelog.html#added_7","title":"Added","text":"<ul> <li>Add support for <code>Path</code> objects everywhere possible.</li> </ul>"},{"location":"about/changelog.html#changed_15","title":"Changed","text":"<ul> <li>Charge and spin multiplicity are now required arguments in molecular DFT calculators.</li> <li>Slab recipes now use <code>make_slabs_from_bulk</code> instead of <code>make_max_slabs_from_bulk</code></li> <li>Use the <code>logging</code> module when warnings do not need to be immediately addressed.</li> <li>Functions are no longer used as kwargs in recipes to help with (de)serialization in certain workflow engines.</li> </ul>"},{"location":"about/changelog.html#removed_2","title":"Removed","text":"<ul> <li>Removed <code>make_max_slabs_from_bulk</code> function.</li> </ul>"},{"location":"about/changelog.html#025","title":"[0.2.5]","text":""},{"location":"about/changelog.html#added_8","title":"Added","text":"<ul> <li>Added support for the Redun workflow engine.</li> <li>Added a simple CLI for (un)setting YAML config parameters.</li> </ul>"},{"location":"about/changelog.html#changed_16","title":"Changed","text":"<ul> <li>Internal refactoring of the <code>Vasp</code> calculator.</li> </ul>"},{"location":"about/changelog.html#removed_3","title":"Removed","text":"<ul> <li>Removed the demonstration Jobflow EMT slab recipe.</li> </ul>"},{"location":"about/changelog.html#024","title":"[0.2.4]","text":""},{"location":"about/changelog.html#changed_17","title":"Changed","text":"<ul> <li>Updated VASP co-pilot rules and <code>BulkSet.yaml</code> in accordance with recent MP benchmarking (#849).</li> <li>Moved <code>fetch_atoms</code> to <code>quacc.schemas</code>.</li> </ul>"},{"location":"about/changelog.html#fixed_9","title":"Fixed","text":"<ul> <li>VASP: Fixed a scenario where SIGMA was set to 0.05 if the user provided SIGMA &gt; 0.05. This was supposed to happen when ISMEAR = 0 but was previously done when ISMEAR = -5, which is not influenced by SIGMA.</li> <li>Fixed <code>mp_relax_flow</code> to use a <code>@flow</code> decorator instead of <code>@job</code></li> <li>Fixed the Q-Chem Quasi-IRC job to run as one <code>@job</code> instead of two.</li> </ul>"},{"location":"about/changelog.html#023","title":"[0.2.3]","text":""},{"location":"about/changelog.html#added_9","title":"Added","text":"<ul> <li>Added new defect EMT workflows (@rwexler)</li> <li>Added new defect utilities (@rwexler)</li> <li>Added a custom Q-Chem calculator based on Pymatgen and Custodian. (@samblau)</li> <li>Added Q-chem core recipes. (@samblau)</li> <li>Added the ability to pass option <code>run_kwargs</code> to the <code>.run()</code> method of the ASE optimizers.</li> </ul>"},{"location":"about/changelog.html#changed_18","title":"Changed","text":"<ul> <li>Removed the need to call <code>ct.dispatch</code> when launching Covalent workflows.</li> <li>Renamed <code>quacc.util</code> to <code>quacc.utils</code></li> <li>Refactored and standardized the NewtonNet recipes to match the other recipes</li> </ul>"},{"location":"about/changelog.html#fixed_10","title":"Fixed","text":"<ul> <li>The <code>WORKFLOW_ENGINE</code> setting can now be set dynamically, as expected.</li> </ul>"},{"location":"about/changelog.html#022","title":"[0.2.2]","text":""},{"location":"about/changelog.html#changed_19","title":"Changed","text":"<ul> <li>Changed package handling in <code>pyproject.toml</code> to better handle pip installs.</li> </ul>"},{"location":"about/changelog.html#021","title":"[0.2.1]","text":""},{"location":"about/changelog.html#added_10","title":"Added","text":"<ul> <li>Added NewtonNet recipes and better sella support (@kumaranu)</li> </ul>"},{"location":"about/changelog.html#changed_20","title":"Changed","text":"<ul> <li>Standardized <code>relax_cell</code> to be <code>False</code> by default for all recipes.</li> <li>Update the default <code>SIGMA</code> and <code>ISMEAR</code> in <code>MPScanSet</code> to match the new values to be used in Atomate2.</li> </ul>"},{"location":"about/changelog.html#fixed_11","title":"Fixed","text":"<ul> <li>Fixed a bug on Windows where the trajectory file would not be closed after a relaxation, causing permission errors.</li> </ul>"},{"location":"about/changelog.html#removed_4","title":"Removed","text":"<ul> <li>Removed atomate2 as a dependency.</li> <li>Removed experimental Prefect support.</li> </ul>"},{"location":"about/changelog.html#020","title":"[0.2.0]","text":""},{"location":"about/changelog.html#added_11","title":"Added","text":"<ul> <li>Added a quacc global setting, <code>WORKFLOW_ENGINE</code>, to set the workflow manager.</li> <li>Added support for the new <code>covalent-hpc-plugin</code> in <code>pyproject.toml</code>.</li> </ul>"},{"location":"about/changelog.html#changed_21","title":"Changed","text":"<ul> <li>Quacc recipes are now decorated with generic <code>@job</code>, <code>@subflow</code>, or <code>@flow</code> decorators to be workflow engine-agnostic.</li> <li>Covalent is now an optional dependency to allow the base <code>quacc</code> package to be dependency-light.</li> <li>Default VASP pseudopotentials changed to <code>setups_pbe54.yaml</code>.</li> <li>Changed <code>quacc.recipes.emt.jobflow</code> and <code>quacc.recipes.emt.prefect</code> to <code>quacc.recipes.emt._jobflow</code> and <code>quacc.recipes.emt._prefect</code></li> </ul>"},{"location":"about/changelog.html#fixed_12","title":"Fixed","text":"<ul> <li>Set <code>LMAXMIX</code> based on the <code>Z</code> value, not the s/p/d/f-block type.</li> <li>Do not set automatically <code>LMAXTAU</code> to 8 for f-containing elements in <code>Vasp</code> calculator.</li> </ul>"},{"location":"about/changelog.html#removed_5","title":"Removed","text":"<ul> <li>Removed <code>quacc.recipes.emt.parsl</code> since it is now obsolete.</li> <li>Removed <code>quacc config</code> command-line option.</li> </ul>"},{"location":"about/changelog.html#013","title":"[0.1.3]","text":""},{"location":"about/changelog.html#added_12","title":"Added","text":"<ul> <li>Added a <code>PRIMARY_STORE</code> quacc setting that, when specified, will automatically store all results in the specified Maggma store.</li> </ul>"},{"location":"about/changelog.html#changed_22","title":"Changed","text":"<ul> <li>The trajectory is now stored in <code>quacc.schemas.cclib.summarize_run</code>.</li> <li>By default, results are now stored in a fixed <code>RESULTS_DIR</code>, which defaults to the current working directory.</li> </ul>"},{"location":"about/changelog.html#fixed_13","title":"Fixed","text":"<ul> <li>Fix path-related issues when running in local multi-threaded mode.</li> <li>Psi4 recipes now use <code>uks</code> for unrestricted calculations instead of <code>uhf</code>.</li> </ul>"},{"location":"about/changelog.html#012","title":"[0.1.2]","text":""},{"location":"about/changelog.html#added_13","title":"Added","text":"<ul> <li>Added support for Prefect.</li> <li>Added <code>quacc.wflow_tools</code> module.</li> </ul>"},{"location":"about/changelog.html#changed_23","title":"Changed","text":"<ul> <li>Made slab-related kwargs more consistent, such as by changing <code>slab_relax_electron</code>/<code>slab_relax_app</code> to just <code>slab_relax</code> regardless of workflow manager.</li> </ul>"},{"location":"about/changelog.html#011","title":"[0.1.1]","text":""},{"location":"about/changelog.html#added_14","title":"Added","text":"<ul> <li>Added this <code>CHANGELOG.md</code> file.</li> <li>Added the <code>quacc.recipes.emt.parsl</code> module.</li> <li>Added a CLI for <code>quacc</code> along with a <code>quacc config</code> option to configure Covalent appropriately upon install.</li> <li>Added generic type hints for schemas.</li> <li>Added a <code>CREATE_UNIQUE_WORKDIR</code> global setting to have quacc automatically make a unique working directory for each calculation.</li> <li>Added <code>CHECK_CONVERGENCE</code> to global settings.</li> </ul>"},{"location":"about/changelog.html#changed_24","title":"Changed","text":"<ul> <li>The <code>quacc</code> directory is now found in a <code>src</code> basefolder.</li> <li>All recipes now support the <code>Atoms</code> object being passed in as an <code>AtomsSchema</code>.</li> <li>The <code>slab_relax_job</code> kwarg in <code>recipes.emt.slabs</code> and <code>recipes.vasp.slabs</code> workflows can no longer be set to <code>None</code>, as there are few situations where this would be desired.</li> <li>Class-based recipes have been converted to functions since they don't save state or have inheritance.</li> </ul>"},{"location":"about/changelog.html#docs","title":"Docs","text":"<ul> <li>Switched the docs from Furo to Material for MkDocs.</li> <li>Expanded upon Parsl documentation.</li> <li>Modified tutorials and added example configs for Slurm.</li> </ul>"},{"location":"about/changelog.html#fixed_14","title":"Fixed","text":"<ul> <li>Temporary directories are cleaned up after the run is completed.</li> </ul>"},{"location":"about/changelog.html#removed_6","title":"Removed","text":"<ul> <li>Removed <code>quacc.recipes.vasp.jobflow</code> module to prioritize Covalent and Parsl.</li> </ul>"},{"location":"about/changelog.html#010","title":"[0.1.0]","text":"<p>See https://github.com/quantum-accelerators/quacc/releases/tag/v0.1.0 for more details.</p>"},{"location":"about/changelog.html#006","title":"[0.0.6]","text":"<p>See https://github.com/quantum-accelerators/quacc/releases/tag/v0.0.6 for more details.</p>"},{"location":"about/changelog.html#005","title":"[0.0.5]","text":"<p>See https://github.com/quantum-accelerators/quacc/releases/tag/v0.0.5 for more details.</p>"},{"location":"about/changelog.html#004","title":"[0.0.4]","text":"<p>See https://github.com/quantum-accelerators/quacc/releases/tag/v0.0.4 for more details.</p>"},{"location":"about/changelog.html#003","title":"[0.0.3]","text":"<p>See https://github.com/quantum-accelerators/quacc/releases/tag/v0.0.3 for more details.</p>"},{"location":"about/changelog.html#002","title":"[0.0.2]","text":"<p>See https://github.com/quantum-accelerators/quacc/releases/tag/v0.0.2 for more details.</p>"},{"location":"about/changelog.html#001","title":"[0.0.1]","text":"<p>See https://github.com/quantum-accelerators/quacc/releases/tag/v0.0.1 for more details.</p>"},{"location":"about/conduct.html","title":"Code of Conduct","text":""},{"location":"about/conduct.html#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"about/conduct.html#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the overall   community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or advances of   any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email address,   without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"about/conduct.html#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"about/conduct.html#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"about/conduct.html#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement. All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"about/conduct.html#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"about/conduct.html#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"about/conduct.html#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"about/conduct.html#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"about/conduct.html#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"about/conduct.html#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.1, available at https://www.contributor-covenant.org/version/2/1/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"about/contributors.html","title":"People","text":""},{"location":"about/contributors.html#developers","title":"Developers","text":"<p>Quacc was designed and developed by Andrew S. Rosen.</p>"},{"location":"about/contributors.html#contributors","title":"Contributors","text":"<p>Additional contributions were made by the individuals listed here. Their contributions are summarized below.</p> <p>Add Your Name!</p> <p>Don't see your name and want to update the list? Submit a PR and update this documentation page!</p> <ul> <li>@samblau: Custom Q-Chem calculator, Q-Chem core and TS recipes.</li> <li>@kumaranu: NewtonNet core and TS recipes.</li> <li>@rwexler: Defect utilities and EMT defect recipe.</li> <li>@ViktoriiaBaib: Initial testing of quacc.</li> </ul>"},{"location":"about/contributors.html#inspiration","title":"Inspiration","text":"<p>Quacc was originally inspired by Atomate2, developed by Alex Ganose.</p>"},{"location":"about/faq.html","title":"FAQ","text":"<p>Q: How do I pronounce <code>quacc</code>?</p> <p>A: Like the sound a duck makes: \"quack!\"</p> <p>Q: What's the philosophy behind quacc?</p> <p>A: This is a big question. I'll explain with some points that were on my mind when I made it:</p> <ol> <li> <p>Everyone's computing needs are different, which means not everyone is going to want to use the same workflow engine. This has historically hindered the widespread adoption of prior computational materials science libraries and makes it difficult to share workflows with others. quacc supports several workflow engines out-of-the-box using largely the same syntax, and you can pick your favorite (or use none at all).</p> </li> <li> <p>We should leverage tools that are widely used in the community. Python packages like ASE and Pymatgen are staples in the computational materials science community. Rather than reinvent the wheel, quacc takes advantage of what is already out there and \u2014 crucially \u2014 makes them play nicely together.</p> </li> <li> <p>Developers should be able to focus on the science, not the workflow architecturee. Many similar packages have the science closely intertwined with the workflow logic. This makes it difficult to write new workflows without learning the intricacies of the workflow stack. quacc solely relies on the use of function decorators that make it easy to transform typical functions into ones that are workflow-ready.</p> </li> <li> <p>An overeliance on classes and inheritance can be confusing at the expense of conciseneess. I love classes, but in a computational materials science library, too much class inheritance can make it difficult to track down what parameters are getting set where. Students are also less familiar with classes and may have a difficult time in understanding how they work. The recipes in quacc take a more direct and familiar functional programming approach.</p> </li> <li> <p>And last but not least, I'm opinionated. quacc represents choices that I think make the most sense for my group and me. Hopefully they make sense for you too.</p> </li> </ol> <p>Q: Which workflow management system should I use?</p> <p>A: Good question! Check out the Workflow Engines Overview Guide for a comparison of several common options to see which might be best for you.</p> <p>Q: Why is quacc better than <code>InsertMyFavoriteCode</code>?</p> <p>A: Better is all in the eye of the beholder. If you are happy with the tools you are using, my goal is not to convince you to switch. That said, if you find that writing high-throughput computational workflows has a huge learning curve or simply takes too much time away from your science, then quacc may be for you.</p> <p>Q: Do you have any tips for writing new workflows?</p> <p>A: When developing new workflows, I strongly recommend writing an initial draft based on a low-cost ASE calculator like <code>EMT</code> or <code>LJ</code>, which will allow you to test on your local machine with fast turnaround. Also try to keep things modular. Trying to do too much in one function can make it difficult to debug.</p> <p>Q: How is quacc different than just using the Atomic Simulation Environment (ASE)</p> <p>A: quacc is designed to supercharge ASE for the efficient design of high-throughput workflows. Quacc makes it possible to easily design complex ASE workflows that can be run on heterogeneous compute environments with modern workflow managers, such as Covalent and Parsl. Quacc also makes it possible to combine ASE with the powerful Materials Project software stack, such as Custodian for on-the-fly error handling. For the database enthusiasts, quacc is interoperable with Maggma to store calculation results in a readily queryable format like MongoDB.</p> <p>Q: How is quacc different than Atomate2?</p> <p>A: Atomate2 is a fantastic code that can be used to run libraries of computational materials science workflows. Quacc was originally inspired by Atomate2 and can be thought of as a \"sister code\" to it. That said, there are several important differences.</p> <ul> <li> <p>In Atomate2, workflows are built around the Materials Project software stack and can be cumbersome to interface with the Atomic Simulation Environment (ASE). In contrast, quacc was built around ASE from the ground up while still making it possible to leverage much of the software underlying the Materials Project. Since quacc is built around ASE, it is also trivial to add new recipes based on any code that has an existing ASE Calculator even if it is not in quacc yet.</p> </li> <li> <p>Atomate2 is built around Jobflow. Quacc is largely workflow engine-agnostic and has out-of-the-box support for numerous workflow codes, including but not limited to Jobflow.</p> </li> <li> <p>Atomate2 is often used as a database-first approach to materials science workflows. Quacc is fully compatible with the use of databases but only emphasizes their use for experts, with the goal of reducing the barrier to getting started.</p> </li> <li> <p>Atomate2 is developed and supported by the Materials Project team at Lawrence Berkeley National Laboratory. Quacc is developed and maintained by the Rosen Research Group at Princeton University.</p> </li> </ul> <p>Q: I want to contribute a new recipe to quacc, but it will require additional dependencies. Is that a problem?</p> <p>A: Absolutely not a problem! Simply make your dependencies optional in the <code>pyproject.toml</code> file and use a <code>monty.dev.requires</code> decorator to ensure your recipes and tests only run if your necessary dependencies are installed. Refer to quacc.recipes.tblite.core and the <code>[tblite]</code> extras in the <code>pyproject.toml</code> file for an example.</p>"},{"location":"about/license.html","title":"License","text":"LICENSE.md<pre><code>BSD 3-Clause License\n\nCopyright (c) 2023, Andrew S. Rosen.\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n- Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n\n- Redistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n\n- Neither the name of the copyright holder nor the names of its\n  contributors may be used to endorse or promote products derived from\n  this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n</code></pre>"},{"location":"dev/_internal.html","title":"Overview","text":""},{"location":"dev/_internal.html#approving-jenkins-builds","title":"Approving Jenkins Builds","text":"<p>When a new pull request is opened in the project and the author of the pull request isn't white-listed, the builder will ask \"Can one of the admins verify this patch?\".</p> <ul> <li>\"ok to test\" to accept this pull request for testing</li> <li>\"add to whitelist\" to add the author to the whitelist</li> <li>\"run jenkins\" to run the Jenkins build once approved</li> </ul>"},{"location":"dev/_internal.html#manual-upload-to-pypi","title":"Manual Upload to PyPi","text":"<p>To upload to PyPI manually in the case of a GitHub Actions failure:</p> <pre><code>pip install -e .\npython -m build\ntwine check dist/*\ntwine upload dist/*\n</code></pre>"},{"location":"dev/contributing.html","title":"Contributing Guide","text":"<p>We welcome all contributions, big or small (provided they come with unit tests!). Here are some general guidelines and tips. Note that it is never too early to open a PR if you're looking for input or feedback!</p> <p>Contributions are Acknowledged</p> <p>Thank you for reading this page! If you need additional incentive to contribute to quacc, we plan to eventually submit a manuscript based on this code. If you contribute to quacc in a significant way (e.g. adding a new recipe or module), you will be contacted to opt-in for authorship once a draft is written. Regardless, all contributors are acknowledged in the About section of the documentation.</p>"},{"location":"dev/contributing.html#steps-to-contribute","title":"Steps to Contribute","text":"<p>To contribute to quacc, we recommend doing the following:</p> <ul> <li> <p>Fork the repository to your personal GitHub account.</p> </li> <li> <p>Clone this forked repository to your local machine, e.g. via <code>git clone &lt;repo url&gt;.git</code>.</p> </li> <li> <p>In the newly downloaded <code>quacc</code> base directory, run <code>pip install -e .[dev]</code> to install quacc in editable mode and with the development dependencies. For reproducibility purposes, we strongly recommend installing quacc in a fresh virtual environment.</p> </li> <li> <p>Commit your changes and push them to your personal forked repository in a new branch.</p> </li> <li> <p>Create a pull request (PR) to merge your changes into the main quacc repository.</p> </li> </ul>"},{"location":"dev/contributing.html#guidelines","title":"Guidelines","text":""},{"location":"dev/contributing.html#general","title":"General","text":"<p>Please abide by the following guidelines when contributing code to quacc:</p> <ul> <li> <p>All changes should have associated unit tests that pass. Code coverage should be maintained.</p> </li> <li> <p>All code should include type hints and have internally consistent documentation for the inputs and outputs.</p> </li> <li> <p>Use absolute paths where possible and avoid using <code>os.chdir</code>. This helps ensure that quacc can be run in multi-threading mode.</p> </li> <li> <p><code>gzip</code> large test files to save space.</p> </li> </ul>"},{"location":"dev/contributing.html#writing-new-recipes","title":"Writing New Recipes","text":"<p>Tip</p> <p>In general, the easiest way to develop a new recipe is to first make one for a cheap-to-run calculator (e.g. EMT for solids, LJ for molecules), which you can then basically copy and paste for your more expensive calculator of choice.</p> <p>If contributing new recipes, please abide by the following guidelines:</p> <ul> <li> <p>Please mimic one of the other recipes as a general template for internal consistency.</p> </li> <li> <p>Decorate your individual compute jobs with a <code>@job</code> decorator and your flows with a <code>@flow</code> decorator. Name them accordingly.</p> </li> <li> <p>Add your new recipe to the List of Recipes.</p> </li> <li> <p>In general, your tests for new recipes should use a small molecule/solid (and cheap settings, where possible) to ensure that the unit tests run quickly.</p> </li> </ul>"},{"location":"dev/contributing.html#style","title":"Style","text":"<p>In general, please try to keep the code style consistent when possible, particularly:</p> <ol> <li> <p>Use NumPy-style docstrings.</p> </li> <li> <p>Address any relevant issues raised by the GitHub Actions test suite.</p> </li> <li> <p>All Python code should be formatted with isort (<code>isort .</code>), black (<code>black .</code>), and ruff (<code>ruff . --fix</code>), although this will be corrected automatically when merged.</p> </li> </ol>"},{"location":"dev/contributing.html#unit-tests","title":"Unit Tests","text":""},{"location":"dev/contributing.html#general_1","title":"General","text":"<p>All changes you make to quacc should be accompanied by unit tests and should not break existing tests. The full test suite will run automatically via GitHub Actions. If you are fixing a bug, include a regression test to make sure the fix you submit continues to work.</p>"},{"location":"dev/contributing.html#running-locally","title":"Running Locally","text":"<p>To run the core test suite locally, run <code>pytest tests/local</code>.</p> <p>If you wish to test the behavior of a given workflow engine, run <code>pytest tests/WORKFLOW_ENGINE</code> where <code>WORKFLOW_ENGINE</code> is the name of your workflow engine.</p>"},{"location":"dev/contributing.html#coverage","title":"Coverage","text":"<p>Each PR will report the code coverage once your tests pass, but if you'd like to generate a coverage report locally, you can use pytest-cov, such as by doing <code>pytest --cov=quacc .</code>.</p> <p>Note</p> <p>The codecov check on PRs updates as each unit test finishes, so don't be surprised to see an \"X\" if tests are still running.</p>"},{"location":"dev/contributing.html#monkeypatching","title":"Monkeypatching","text":"<p>For recipes that involve a calculation that cannot be easily run in the test suite (e.g. the underlying calculator cannot be installed via <code>pip</code> or <code>conda</code>), you will need to make a <code>conftest.py</code> file in the recipe directory that monkeypatches the relevant functions (refer to the Gaussian recipe tests for an example). The tests should be written in such a way that they would also pass if the executable were actually available and the <code>conftest.py</code> file were not applied. To run the test on your own machine without the <code>conftest.py</code> file applied, you can use the <code>--noconftest</code> flag when calling <code>pytest</code>.</p>"},{"location":"dev/contributing.html#running-a-pr-on-an-hpc-machine","title":"Running a PR on an HPC Machine","text":"<p>When opening a PR, it is possible to trigger the test suite on a Princeton-hosted HPC machine where the licensed executables are run without monkeypatching. To do so, simply comment \"Run Jenkins\" in a PR. This is strongly encouraged for all PRs that touch any code related to calculators or recipes.</p> <p>If you are adding recipes for a calculator that is not yet part of quacc and cannot be installed via <code>pip</code> or <code>conda</code>, we will add the necessary executables to the HPC build pipeline so that production-quality tests will be run automatically (provided we have a license for it). This is an important reason for why the unit tests should be done with a small molecule/solid.</p>"},{"location":"dev/docs.html","title":"Updating the Docs","text":"<p>To install the dependencies to build the documentation, run <code>pip install -e .[docs]</code>.</p> <p>The quacc documentation is built using Material for MkDocs. To build the documentation locally (e.g. to evaluate changes), run <code>mkdocs serve</code> in the base directory and open the URL shown in the terminal.</p>"},{"location":"dev/recipes/flows.html","title":"Writing Flows","text":""},{"location":"dev/recipes/flows.html#simple-flows","title":"Simple Flows","text":""},{"location":"dev/recipes/flows.html#overview","title":"Overview","text":"<p>A flow is a Python function decorated by <code>@flow</code> that contains a collection of jobs. Refer to the Workflow Syntax page for more information on the syntax of flows.</p> <p>The flow itself does not contain computationally intensive tasks. It simply calls other jobs (and/or flows) and defines the workflow logic.</p>"},{"location":"dev/recipes/flows.html#examples","title":"Examples","text":"<p>A simple, representative flow can be found in quacc.recipes.vasp.mp.mp_relax_flow.</p>"},{"location":"dev/recipes/flows.html#dynamic-flows","title":"Dynamic Flows","text":"<p>quacc fully supports complex, dynamic flows where the number of jobs is not known a priori. In this case, a common pattern is the use of a subflow, defined with a <code>@subflow</code> decorator. A subflow is just like a flow, except the returned object is a list of job outputs.</p>"},{"location":"dev/recipes/flows.html#examples_1","title":"Examples","text":"<p>A representative example of a complex flow can be found in quacc.recipes.emt.slabs.bulk_to_slabs_flow.</p> <p>This flow is \"dynamic\" because the number of slabs is not known until the pre-requisite relaxation step is completed.</p> <p>Note</p> <p>To prevent code duplication, we put common recipes that are code-agnostic in <code>quacc.recipes.common</code>. These recipes are not meant to be run directly, but rather called by other recipes.</p> <p>For instance, quacc.recipes.emt.slabs.bulk_to_slabs_flow and quacc.recipes.vasp.slabs.bulk_to_slabs_flow both call the same quacc.recipes.common.slabs.bulk_to_slabs_subflow.</p>"},{"location":"dev/recipes/jobs.html","title":"Writing Jobs","text":""},{"location":"dev/recipes/jobs.html#overview","title":"Overview","text":"<p>Individual compute tasks are called jobs. You can think of these as distinct calculations you would submit to the job scheduler (e.g. Slurm). Refer to the Workflow Syntax page for more information on the syntax of jobs.</p>"},{"location":"dev/recipes/jobs.html#examples","title":"Examples","text":"<p>For an example job using an ASE optimizer, refer to quacc.recipes.tblite.core.relax_job.</p> <p>For a representative job involving a code that uses an internal geometry optimizer and an external parsing library (i.e. cclib), refer to quacc.recipes.gaussian.core.relax_job.</p>"},{"location":"dev/recipes/jobs.html#requirements-and-recommendations","title":"Requirements and Recommendations","text":"<p>In quacc, jobs are defined as Python functions that are decorated with <code>@job</code>.</p> <p>The following are typical guidelines for jobs:</p> <ul> <li> <p>The function inputs and outputs must be serializable with pickle.</p> </li> <li> <p>The function generally should take an <code>Atoms</code> object as the input, along with any other keyword arguments needed to set calculator parameters and define the logic flow.</p> </li> <li> <p>The returned object should typically be a dictionary of results, as defined in <code>quacc.schemas</code>.</p> </li> <li> <p>Calculations should be executed using a runner from <code>quacc.runners</code>.</p> </li> <li> <p>When given the choice between using an ASE optimizer and the electronic structure package's built-in optimizer, you should typically use the latter.</p> </li> </ul>"},{"location":"dev/recipes/jobs.html#runners","title":"Runners","text":"<p>Three of the most common runners are summarized below:</p> <ol> <li> <p>quacc.runners.ase.run_calc: Runs a calculation using an ASE calculator. This is the most common runner.</p> </li> <li> <p>quacc.runners.ase.run_opt: Runs a geometry optimization using an ASE optimizer.</p> </li> <li> <p>quacc.runners.ase.run_vib: Runs a vibrational analysis using ASE's <code>Vibrations</code> module.</p> </li> </ol>"},{"location":"dev/recipes/jobs.html#schemas","title":"Schemas","text":"<p>A schema is a dictionary containing tabulated input and output properties from a calculation.</p> <p>All available schemas are stored in <code>quacc.schemas</code>, and type-hints associated with the outputs are stored in <code>quacc.schemas._aliases</code>.</p> <p>All schemas create quacc-compatible dictionaries from a given calculation and also will automatically store results in the user's database, if one is specified in the global settings.</p>"},{"location":"install/codes.html","title":"Calculator Setup","text":"<p>Start Simple</p> <p>Just getting started? Try using the EMT or LJ recipes before worrying about setting up one of the calculators below.</p> <p>Here, we outline how to ensure that quacc can run the quantum chemistry package of your choosing. You only need to follow the instructions for the code(s) you intend to use.</p>"},{"location":"install/codes.html#dftb","title":"DFTB+","text":"<p>If you plan to use DFTB+ with quacc, you will need to install the code as follows:</p> <pre><code>conda install -c conda-forge dftbplus\n</code></pre>"},{"location":"install/codes.html#emt","title":"EMT","text":"<p>No setup needed!</p>"},{"location":"install/codes.html#gaussian","title":"Gaussian","text":"<p>To use quacc with Gaussian, you will need to define the <code>GAUSSIAN_CMD</code> setting to be the path of the Gaussian executable (or the name of the executable if it is already in your <code>PATH</code>). This can be done as described in the section on \"Modifying Quacc Settings\", such as by defining the following environment variable:</p> <pre><code>export QUACC_GAUSSIAN_CMD=\"/path/to/g16\"\n</code></pre>"},{"location":"install/codes.html#gulp","title":"GULP","text":"<p>To use quacc with GULP, you will need to download and compile GULP 6.1.2+ per the official manual. Then you will define the <code>GULP_CMD</code> setting to be the path of the GULP executable and the <code>GULP_LIB</code> setting to be the path to the GULP force field library. This can be done as described in the section on \"Modifying Quacc Settings\", such as by defining the following environment variables in your <code>~/.bashrc</code>:</p> <pre><code>export QUACC_GULP_CMD=\"/path/to/gulp\"\nexport QUACC_GULP_LIB=\"/path/to/gulp-#.#.#/Libraries\"\n</code></pre> <p>Receive a Compilation Error?</p> <p>If you receive an error upon compilation, refer to this forum post.</p>"},{"location":"install/codes.html#lennard-jones","title":"Lennard Jones","text":"<p>No setup needed!</p>"},{"location":"install/codes.html#newtonnet","title":"NewtonNet","text":"<p>If you plan to use NewtonNet with Quacc, you will need to install it prior to use. This can be done as follows:</p> <pre><code>pip install quacc[newtonnet]\n</code></pre>"},{"location":"install/codes.html#orca","title":"ORCA","text":"<p>To use quacc with ORCA, you will need to define the <code>ORCA_CMD</code> setting to be the full, absolute path to your ORCA executable. This can be done as described in the section on \"Modifying Quacc Settings\", such as by defining the following environment variable in your <code>~/.bashrc</code>:</p> <pre><code>export QUACC_ORCA_CMD=\"/path/to/orca/orca\"\n</code></pre>"},{"location":"install/codes.html#psi4","title":"Psi4","text":"<p>If you plan to use Psi4 with quacc, you will need to install it prior to use. This can be done as described in the Psi4 installation guide.</p>"},{"location":"install/codes.html#q-chem","title":"Q-Chem","text":"<p>If you plan to use Q-Chem with Quacc, you will need to install <code>openbabel</code>. This can be done as follows:</p> <pre><code>conda install -c conda-forge openbabel\n</code></pre>"},{"location":"install/codes.html#tblite","title":"tblite","text":"<p>If you plan to use tblite with quacc, you will need to install the tblite interface with ASE support.</p> <pre><code>pip install quacc[tblite] # only on Linux\n</code></pre>"},{"location":"install/codes.html#vasp","title":"VASP","text":"<p>To use quacc with VASP, you will need to define several environment variables, as described in the section on \"Modifying Quacc Settings\". The most important are listed below:</p> <pre><code>export QUACC_VASP_PARALLEL_CMD=\"srun -N 2 --ntasks-per-node 24\"\nexport QUACC_VASP_PP_PATH=\"/path/to/POTCARs\"\nexport QUACC_VASP_VDW=\"/path/to/directory/containing/kernel\"\n</code></pre> <p>The <code>VASP_PARALLEL_CMD</code> setting tells Custodian and/or ASE how to parallelize VASP. Note that it does not include the executable.</p> <p>The <code>VASP_PP_PATH</code> setting should point to the directory containing your VASP pseudopotentials. There should be two subdirectories name <code>potpaw_PBE</code> and <code>potpaw</code> for the PBE and LDA pseudopotentials, respectively. If your pseudopotential directories have a different name, create a symbolic link with the required naming scheme. We recommend setting <code>QUACC_VASP_PP_PATH</code> in your <code>~/.bashrc</code> file since this rarely changes.</p> <p>The <code>VASP_VDW</code> environment variable is necessary if you are using a vdW functional and should point to the directory that contains the <code>vdw_kernel.bindat</code> file distributed with VASP. We also recommend including this in your <code>~/.bashrc</code> file since this rarely changes.</p> <p>Additional settings can be specified as well, such as the name of the VASP executables if they differ from the default values (i.e. <code>vasp_std</code>, <code>vasp_gam</code>).</p>"},{"location":"install/install.html","title":"Installation","text":""},{"location":"install/install.html#pre-requisites","title":"Pre-Requisites","text":"<p>Using Windows?</p> <p>If you are on a Windows machine, we recommend using the Windows Subsystem for Linux (WSL) to benefit from all the features of quacc.</p> <ol> <li>Install Python 3.9+, preferably in conjunction with an environment manager. For instance, download and run the Miniconda installer</li> <li>When asked to add Miniconda to your <code>PATH</code>, select yes</li> <li>Create a fresh Python environment by running <code>conda create -n quacc python=3.10</code></li> <li>Activate this environment via <code>conda activate quacc</code></li> </ol>"},{"location":"install/install.html#installing-quacc","title":"Installing quacc","text":"<p>In your newly activated conda environment, run the following commands to install quacc. Note that you will need to install quacc on all machines where you plan to run calculations.</p> <p>For the latest PyPI release:</p> <pre><code># Install development version of ASE\npip install --force-reinstall --no-deps https://gitlab.com/ase/ase/-/archive/master/ase-master.zip\n\n# Install quacc\npip install quacc\n</code></pre> <p>For the development version:</p> <pre><code># Install development version of ASE\npip install --force-reinstall --no-deps https://gitlab.com/ase/ase/-/archive/master/ase-master.zip\n\n# Install development version of quacc\npip install git+https://github.com/quantum-accelerators/quacc.git\n</code></pre>"},{"location":"install/wflow_engines.html","title":"Workflow Engine Setup","text":"<p>Using a workflow engine is a crucial component for scaling up quacc calculations in a high-throughput setting. We describe the necessary installation steps here for the workflow manager of your choosing.</p> <p>Picking a Workflow Engine</p> <p>For a comparison of the different compatible workflow engines, refer to the Workflow Engines Overview section.</p> <p>If you don't want to use a workflow engine, you can simply skip this section.</p> ParslCovalentRedunJobflow <p>Installation</p> <p>To install Parsl, run the following:</p> <pre><code>pip install quacc[parsl]\n</code></pre> <p>Parsl has many configuration options, which we will cover later in the documentation.</p> <p>Installation</p> <p>To install Covalent, run</p> <pre><code>pip install quacc[covalent]\n</code></pre> <p>Starting the Server</p> <p>Covalent uses a server to dispatch and store calculation details and results. To start the server, simply run <code>covalent start</code> in your terminal. It will return a URL (usually http://localhost:48008) that you can use to access the Covalent dashboard, which is shown below.</p> <p></p> <p>Tip</p> <p>Once you start scaling up your calculations, we recommend hosting the Covalent server on a dedicated machine or using Covalent Cloud. Refer to the Covalent Deployment Guide for details.</p> <p>For NERSC Users</p> <p>If you are using Perlmutter at NERSC, you will need to adjust the Covalent configuration directory because the home directory does not support file locking:</p> ~/.bashrc<pre><code>export COVALENT_CONFIG_DIR=\"$SCRATCH/.config/covalent\"\n</code></pre> <p>Installation</p> <p>To install Redun, run the following:</p> <pre><code>pip install quacc[redun]\n</code></pre> <p>Installation</p> <p>To install Jobflow with support for FireWorks, run the following:</p> <pre><code>pip install quacc[jobflow]\n</code></pre> <p>MongoDB Setup</p> <p>Jobflow and FireWorks both require the use of a database (most commonly a MongoDB instance) to store calculation results.</p> <p>Tip</p> <p>If it is not possible to use MongoDB, you can use a variety of other data store options available within the maggma package, including a <code>MontyStore</code> that solely relies on the local filesystem.</p> <p>Jobflow DB Setup</p> <p>If you plan to use Jobflow to write your workflows, you will need to make a <code>jobflow.yaml</code> file. This file will generally be formatted like the example below. Fill in the fields with the appropriate values for your MongoDB cluster, which is where all your calculation inputs and outputs will be stored.</p> jobflow.yaml<pre><code>JOB_STORE:\n  docs_store:\n    type: MongoStore\n    host: &lt;host name&gt;\n    port: 27017\n    username: &lt;username&gt;\n    password: &lt;password&gt;\n    database: &lt;database name&gt;\n    collection_name: &lt;collection name&gt;\n</code></pre> <p>MongoDB Atlas</p> <p>If you are using a URI (as is common with MongoDB Atlas), then you will instead have a <code>jobflow.yaml</code> file that looks like the example below. Here, you will put the full URI in the <code>host</code> field. The <code>username</code> and <code>password</code> are part of the URI and so should not be included elsewhere in the YAML file.</p> jobflow.yaml<pre><code>JOB_STORE:\n  docs_store:\n    type: MongoStore\n    host: &lt;URI&gt;\n    port: 27017\n    database: &lt;database name&gt;\n    collection_name: &lt;collection name&gt;\n</code></pre> <p>You will then need to define a <code>JOBFLOW_CONFIG_FILE</code> environment variable pointing to the file you made. For instance, in your <code>~/.bashrc</code> file, add the following line:</p> <pre><code>export JOBFLOW_CONFIG_FILE=\"/path/to/my/jobflow.yaml\"\n</code></pre> <p>FireWorks DB Setup</p> <p>If you plan to use FireWorks to dispatch your Jobflow workflows, you will also need to make a few configuration files: <code>FW_config.yaml</code>, <code>my_fworker.yaml</code>, <code>my_launchpad.yaml</code>, and <code>my_qadapter.yaml</code>. To begin, make a directory called <code>fw_config</code> where you will store the four files described in greater detail below. The directory structure will look like the following:</p> <pre><code>fw_config\n\u251c\u2500\u2500 FW_config.yaml\n\u251c\u2500\u2500 my_fworker.yaml\n\u251c\u2500\u2500 my_launchpad.yaml\n\u2514\u2500\u2500 my_qadapter.yaml\n</code></pre> <p>FW Config File</p> <p>For the <code>FW_config.yaml</code>, you can use the following template. Make sure to update the path to the <code>fw_config</code> folder where the file resides.</p> FW_config.yaml<pre><code>CONFIG_FILE_DIR: &lt;/path/to/fw_config&gt;\nQUEUE_UPDATE_INTERVAL: 2\n</code></pre> <p>You will also need to define a <code>FW_CONFIG_FILE</code> environment variable pointing to the <code>FW_config.yaml</code> file you made. For instance, in your <code>~/.bashrc</code> file, add the following line:</p> <pre><code>export FW_CONFIG_FILE=\"/path/to/config/fw_config/FW_config.yaml\"\n</code></pre> <p>FWorker</p> <p>For the <code>my_fworker.yaml</code>, you can use the following template. You do not need to make any modifications.</p> my_fworker.yaml<pre><code>name: quacc_fworker\ncategory: \"\"\nquery: \"{}\"\n</code></pre> <p>Launchpad</p> <p>For the <code>my_launchpad.yaml</code>, you can use the following template. Replace the entries in <code>&lt;&gt;</code> with the appropriate values for your Mongo database.</p> my_launchpad.yaml<pre><code>host: &lt;host name&gt;\nport: 27017\nname: &lt;database name&gt;\nusername: &lt;username&gt;\npassword: &lt;password&gt;\nlogdir: null\nIstrm_lvl: DEBUG\nuser_indices: []\nwf_user_indices: []\n</code></pre> <p>MongoDB Atlas</p> <p>If you are accessing your MongoDB via a URI (e.g. as with MongoDB Atlas), then you will use the following <code>my_launchpad.yaml</code> template instead.</p> my_launchpad.yaml<pre><code>host: &lt;URI&gt;\nport: 27017\nname: &lt;database name&gt;\nuri_store: true\nlogdir: null\nIstrm_lvl: DEBUG\nuser_indices: []\nwf_user_indices: []\n</code></pre> <p>QAdapter</p> <p>Assuming you plan to use a queuing system for your compute jobs, you will need to make a <code>my_qadapter.yaml</code> file. For this, you will need to follow the instructions in the FireWorks documentation for your specific job scheduling system. An example <code>my_qadapter.yaml</code> file is shown below for Slurm.</p> my_qadapter.yaml<pre><code>_fw_name: CommonAdapter\n_fw_q_type: SLURM\nrocket_launch: rlaunch -w /path/to/fw_config/my_fworker.yaml singleshot\nnodes: 2\nwalltime: 00:30:00\naccount: &lt;account&gt;\njob_name: quacc_firework\nqos: regular\npre_rocket: |\nmodule load MyModuleName\nexport MyEnvVar=MyEnvValue\n</code></pre> <p>In the above example, you would need to change the path in the <code>rocket_launch</code> field to the correct path to your <code>my_fworker.yaml</code>. The nodes, walltime, account, and qos are the corresponding parameters for your queuing system. Finally, anything in the <code>pre_rocket</code> field will be executed before the job begins running. It is a good place to load modules and set environment variables. A representative example has been provided above.</p> <p>Database Initialization</p> <p>Danger</p> <p>Running <code>lpad reset</code> will clear your FireWorks launchpad, so only use this command if you are a new user.</p> <p>To check that FireWorks can connect to your database, run <code>lpad reset</code> if this is your first time using FireWorks.</p>"},{"location":"reference/SUMMARY.html","title":"SUMMARY","text":"<ul> <li>quacc<ul> <li>atoms<ul> <li>core</li> <li>defects</li> <li>phonons</li> <li>slabs</li> </ul> </li> <li>calculators<ul> <li>qchem<ul> <li>io</li> <li>qchem</li> <li>qchem_custodian</li> </ul> </li> <li>vasp<ul> <li>io</li> <li>params</li> <li>vasp</li> <li>vasp_custodian</li> </ul> </li> </ul> </li> <li>recipes<ul> <li>common<ul> <li>defects</li> <li>phonons</li> <li>slabs</li> </ul> </li> <li>dftb<ul> <li>_base</li> <li>core</li> </ul> </li> <li>emt<ul> <li>core</li> <li>defects</li> <li>phonons</li> <li>slabs</li> </ul> </li> <li>gaussian<ul> <li>_base</li> <li>core</li> </ul> </li> <li>gulp<ul> <li>_base</li> <li>core</li> </ul> </li> <li>lj<ul> <li>core</li> </ul> </li> <li>newtonnet<ul> <li>core</li> <li>ts</li> </ul> </li> <li>orca<ul> <li>_base</li> <li>core</li> </ul> </li> <li>psi4<ul> <li>_base</li> <li>core</li> </ul> </li> <li>qchem<ul> <li>_base</li> <li>core</li> <li>ts</li> </ul> </li> <li>tblite<ul> <li>core</li> <li>phonons</li> </ul> </li> <li>vasp<ul> <li>_base</li> <li>core</li> <li>mp</li> <li>qmof</li> <li>slabs</li> </ul> </li> </ul> </li> <li>runners<ul> <li>ase</li> <li>prep</li> <li>thermo</li> </ul> </li> <li>schemas<ul> <li>ase</li> <li>atoms</li> <li>cclib</li> <li>phonons</li> <li>prep</li> <li>vasp</li> </ul> </li> <li>utils<ul> <li>dicts</li> <li>files</li> </ul> </li> <li>wflow_tools<ul> <li>db</li> <li>decorators</li> <li>prefect</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/quacc/atoms/core.html","title":"core","text":"<p>Utility functions for dealing with Atoms.</p>"},{"location":"reference/quacc/atoms/core.html#quacc.atoms.core.check_charge_and_spin","title":"check_charge_and_spin","text":"<pre><code>check_charge_and_spin(\n    atoms, charge=None, spin_multiplicity=None\n)\n</code></pre> <p>Check the validity of a given <code>charge</code> and <code>multiplicity</code>. If they are <code>None</code>, then set the charge and/or spin multiplicity of a molecule using the following routine, raising a <code>ValueError</code> if there is an incompatibility.</p> <p>Charges:</p> <ol> <li> <p>If <code>charge</code> is specified, that is the charge.</p> </li> <li> <p>If <code>atoms.charge</code> is present, that is the charge.</p> </li> <li> <p>If <code>atoms.has(\"initial_charges\")</code>, then <code>atoms.get_initial_charges.sum()</code> is the charge.</p> </li> <li> <p>If <code>spin_multiplicity</code> is set, set the charge to the smallest physically possible value.</p> </li> <li> <p>Otherwise, set to 0.</p> </li> </ol> <p>Spin multiplicity:</p> <ol> <li> <p>If <code>spin_multiplicity</code> is specified, that is the spin multiplicity.</p> </li> <li> <p>If <code>atoms.spin_multiplicity</code> is present, that is the spin multiplicity.</p> </li> <li> <p>If <code>atoms.has(\"initial_magmoms\")</code>, then <code>np.abs(atoms.get_initial_magnetic_moments().sum())+1</code> is the spin multiplicity.</p> </li> <li> <p>If none of the above, use Pymatgen to identify the lowest physically possible spin multiplicity given the number of electrons and the charge, if set.</p> </li> </ol> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>Atoms object</p> </li> <li> <code>charge</code>             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>Molecular charge</p> </li> <li> <code>spin_multiplicity</code>             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>Molecular multiplicity</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>(charge, multiplicity)</code>         \u2013          </li> </ul> Source code in <code>quacc/atoms/core.py</code> <pre><code>def check_charge_and_spin(\n    atoms: Atoms, charge: int | None = None, spin_multiplicity: int | None = None\n) -&gt; tuple[int, int]:\n    \"\"\"\n    Check the validity of a given `charge` and `multiplicity`. If they are `None`, then\n    set the charge and/or spin multiplicity of a molecule using the following routine,\n    raising a `ValueError` if there is an incompatibility.\n\n    Charges:\n\n    1. If `charge` is specified, that is the charge.\n\n    2. If `atoms.charge` is present, that is the charge.\n\n    3. If `atoms.has(\"initial_charges\")`, then\n    `atoms.get_initial_charges.sum()` is the charge.\n\n    4. If `spin_multiplicity` is set, set the charge to the smallest physically\n    possible value.\n\n    5. Otherwise, set to 0.\n\n    Spin multiplicity:\n\n    1. If `spin_multiplicity` is specified, that is the spin multiplicity.\n\n    2. If `atoms.spin_multiplicity` is present, that is the spin multiplicity.\n\n    3. If `atoms.has(\"initial_magmoms\")`, then\n    `np.abs(atoms.get_initial_magnetic_moments().sum())+1` is the spin\n    multiplicity.\n\n    4. If none of the above, use Pymatgen to identify the lowest physically\n    possible spin multiplicity given the number of electrons and the charge, if\n    set.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    charge\n        Molecular charge\n    spin_multiplicity\n        Molecular multiplicity\n\n    Returns\n    -------\n    charge, multiplicity\n    \"\"\"\n\n    charge = (\n        charge\n        if charge is not None\n        else atoms.charge\n        if getattr(atoms, \"charge\", None)\n        else round(atoms.get_initial_charges().sum())\n        if atoms.has(\"initial_charges\")\n        else None\n    )\n\n    spin_multiplicity = (\n        spin_multiplicity\n        if spin_multiplicity is not None\n        else atoms.spin_multiplicity\n        if getattr(atoms, \"spin_multiplicity\", None)\n        else round(np.abs(atoms.get_initial_magnetic_moments().sum()) + 1)\n        if atoms.has(\"initial_magmoms\")\n        else None\n    )\n\n    if charge is None and spin_multiplicity is not None:\n        charge = 0\n\n    try:\n        mol = AseAtomsAdaptor.get_molecule(atoms)\n        if charge is not None:\n            if spin_multiplicity is not None:\n                mol.set_charge_and_spin(charge, spin_multiplicity)\n            else:\n                mol.set_charge_and_spin(charge)\n    except ValueError:\n        mol = AseAtomsAdaptor.get_molecule(atoms, charge_spin_check=False)\n        nelectrons = mol.nelectrons - charge if charge else mol.nelectrons\n        default_spin_multiplicity = 1 if nelectrons % 2 == 0 else 2\n        mol.set_charge_and_spin(\n            charge if charge is not None else mol.charge,\n            spin_multiplicity\n            if spin_multiplicity is not None\n            else default_spin_multiplicity,\n        )\n    if (mol.nelectrons + mol.spin_multiplicity) % 2 != 1:\n        raise ValueError(\n            f\"Charge of {mol.charge} and spin multiplicity of {mol.spin_multiplicity} is\"\n            \" not possible for this molecule.\"\n        )\n    logger.info(\n        f\"Setting charge to {mol.charge} and spin multiplicity to {mol.spin_multiplicity}\"\n    )\n\n    return mol.charge, mol.spin_multiplicity\n</code></pre>"},{"location":"reference/quacc/atoms/core.html#quacc.atoms.core.check_is_metal","title":"check_is_metal","text":"<pre><code>check_is_metal(atoms)\n</code></pre> <p>Checks if a structure is a likely metal.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>Atoms object</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True if the structure is likely a metal; False otherwise</p> </li> </ul> Source code in <code>quacc/atoms/core.py</code> <pre><code>def check_is_metal(atoms: Atoms) -&gt; bool:\n    \"\"\"\n    Checks if a structure is a likely metal.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n\n    Returns\n    -------\n    bool\n        True if the structure is likely a metal; False otherwise\n    \"\"\"\n    if atoms.pbc.any():\n        struct = AseAtomsAdaptor.get_structure(atoms)\n    else:\n        struct = AseAtomsAdaptor.get_molecule(atoms)\n\n    return all(k.is_metal for k in struct.composition)\n</code></pre>"},{"location":"reference/quacc/atoms/core.html#quacc.atoms.core.copy_atoms","title":"copy_atoms","text":"<pre><code>copy_atoms(atoms)\n</code></pre> <p>Simple function to copy an atoms object to prevent mutability.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>Atoms object</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>atoms</code>         \u2013          <p>Atoms object</p> </li> </ul> Source code in <code>quacc/atoms/core.py</code> <pre><code>def copy_atoms(atoms: Atoms) -&gt; Atoms:\n    \"\"\"\n    Simple function to copy an atoms object to prevent mutability.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n\n    Returns\n    -------\n    atoms\n        Atoms object\n    \"\"\"\n    try:\n        atoms = deepcopy(atoms)\n    except Exception:\n        # Needed because of ASE issue #1084\n        calc = atoms.calc\n        atoms = atoms.copy()\n        atoms.calc = calc\n\n    return atoms\n</code></pre>"},{"location":"reference/quacc/atoms/core.html#quacc.atoms.core.get_atoms_id","title":"get_atoms_id","text":"<pre><code>get_atoms_id(atoms)\n</code></pre> <p>Returns a unique ID for the Atoms object. Note: The .info dict and calculator is excluded from the hash generation.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>Atoms object</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>md5hash</code>         \u2013          <p>MD5 hash of the Atoms object</p> </li> </ul> Source code in <code>quacc/atoms/core.py</code> <pre><code>def get_atoms_id(atoms: Atoms) -&gt; str:\n    \"\"\"\n    Returns a unique ID for the Atoms object. Note: The .info dict and calculator is\n    excluded from the hash generation.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n\n    Returns\n    -------\n    md5hash\n        MD5 hash of the Atoms object\n    \"\"\"\n\n    atoms = copy_atoms(atoms)\n    atoms.info = {}\n    atoms.calc = None\n    encoded_atoms = encode(atoms)\n    # This is a hack to avoid int32/int64 and float32/float64 differences\n    # between machines.\n    encoded_atoms = (\n        encoded_atoms.replace(\"int64\", \"int\")\n        .replace(\"int32\", \"int\")\n        .replace(\"float64\", \"float\")\n        .replace(\"float32\", \"float\")\n    )\n\n    return hashlib.md5(encoded_atoms.encode(\"utf-8\")).hexdigest()\n</code></pre>"},{"location":"reference/quacc/atoms/defects.html","title":"defects","text":"<p>Utility functions for dealing with defects.</p>"},{"location":"reference/quacc/atoms/defects.html#quacc.atoms.defects.make_defects_from_bulk","title":"make_defects_from_bulk","text":"<pre><code>make_defects_from_bulk(\n    atoms,\n    defect_gen=VacancyGenerator,\n    defect_charge=0,\n    sc_mat=None,\n    min_atoms=80,\n    max_atoms=240,\n    min_length=10.0,\n    force_diagonal=False,\n    **defect_gen_kwargs\n)\n</code></pre> <p>Function to make defects from a bulk atoms object.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>bulk atoms</p> </li> <li> <code>defect_gen</code>             (<code>AntiSiteGenerator | ChargeInterstitialGenerator | InterstitialGenerator | SubstitutionGenerator | VacancyGenerator | VoronoiInterstitialGenerator</code>, default:                 <code>VacancyGenerator</code> )         \u2013          <p>defect generator</p> </li> <li> <code>sc_mat</code>             (<code>NDArray | None</code>, default:                 <code>None</code> )         \u2013          <p>supercell matrix</p> </li> <li> <code>min_atoms</code>             (<code>int</code>, default:                 <code>80</code> )         \u2013          <p>minimum number of atoms in supercell</p> </li> <li> <code>max_atoms</code>             (<code>int</code>, default:                 <code>240</code> )         \u2013          <p>maximum number of atoms in supercell</p> </li> <li> <code>min_length</code>             (<code>float</code>, default:                 <code>10.0</code> )         \u2013          <p>minimum length of supercell</p> </li> <li> <code>force_diagonal</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>force supercell to be diagonal</p> </li> <li> <code>defect_charge</code>             (<code>int</code>, default:                 <code>0</code> )         \u2013          <p>charge state of defect</p> </li> <li> <code>**defect_gen_kwargs</code>         \u2013          <p>keyword arguments to pass to the pymatgen.analysis.defects.generators get_defects() method</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Atoms]</code>         \u2013          <p>All generated defects</p> </li> </ul> Source code in <code>quacc/atoms/defects.py</code> <pre><code>def make_defects_from_bulk(\n    atoms: Atoms,\n    defect_gen: (\n        AntiSiteGenerator\n        | ChargeInterstitialGenerator\n        | InterstitialGenerator\n        | SubstitutionGenerator\n        | VacancyGenerator\n        | VoronoiInterstitialGenerator\n    ) = VacancyGenerator,\n    defect_charge: int = 0,\n    sc_mat: NDArray | None = None,\n    min_atoms: int = 80,\n    max_atoms: int = 240,\n    min_length: float = 10.0,\n    force_diagonal: bool = False,\n    **defect_gen_kwargs,\n) -&gt; list[Atoms]:\n    \"\"\"\n    Function to make defects from a bulk atoms object.\n\n    Parameters\n    ----------\n    atoms\n        bulk atoms\n    defect_gen\n        defect generator\n    sc_mat\n        supercell matrix\n    min_atoms\n        minimum number of atoms in supercell\n    max_atoms\n        maximum number of atoms in supercell\n    min_length\n        minimum length of supercell\n    force_diagonal\n        force supercell to be diagonal\n    defect_charge\n        charge state of defect\n    **defect_gen_kwargs\n        keyword arguments to pass to the pymatgen.analysis.defects.generators\n        get_defects() method\n\n    Returns\n    -------\n    list[Atoms]\n        All generated defects\n    \"\"\"\n\n    # Use pymatgen-analysis-defects and ShakeNBreak to generate defects\n    struct = AseAtomsAdaptor.get_structure(atoms)\n\n    # Make all the defects\n    defects = defect_gen().get_defects(struct, **defect_gen_kwargs)\n    final_defects = []\n    for defect in defects:\n        defect.user_charges = [defect_charge]\n\n        # Generate the supercell for a defect\n        defect_supercell = defect.get_supercell_structure(\n            sc_mat=sc_mat,\n            dummy_species=DummySpecies(),\n            min_atoms=min_atoms,\n            max_atoms=max_atoms,\n            min_length=min_length,\n            force_diagonal=force_diagonal,\n        )\n\n        # Generate DefectEntry object from Defect object\n        defect_entry = _get_defect_entry_from_defect(\n            defect=defect,\n            defect_supercell=defect_supercell,\n            defect_charge=defect_charge,\n        )\n\n        # Instantiate class to apply rattle and bond distortion to all defects\n        Dist = Distortions([defect_entry])\n\n        # Apply rattle and bond distortion to all defects\n        defect_dict, distortion_metadata = Dist.apply_distortions()\n        defect_symbol = next(iter(distortion_metadata[\"defects\"].keys()))\n        distortion_dict = defect_dict[defect_symbol][\"charges\"][defect_charge][\n            \"structures\"\n        ][\"distortions\"]\n\n        # Make atoms objects and store defect stats\n        for distortions, defect_struct in distortion_dict.items():\n            final_defect = AseAtomsAdaptor.get_atoms(defect_struct)\n            defect_stats = {\n                \"defect_symbol\": defect_symbol,\n                \"defect_charge\": defect_charge,\n                \"distortions\": distortions,\n                \"bulk\": atoms,\n                \"defect\": defect,\n            }\n            final_defect.info[\"defect_stats\"] = defect_stats\n            final_defects.append(final_defect)\n    return final_defects\n</code></pre>"},{"location":"reference/quacc/atoms/phonons.html","title":"phonons","text":"<p>Atoms handling with Phonopy</p>"},{"location":"reference/quacc/atoms/phonons.html#quacc.atoms.phonons.atoms_to_phonopy","title":"atoms_to_phonopy","text":"<pre><code>atoms_to_phonopy(\n    atoms, supercell_matrix, atom_disp, phonopy_kwargs=None\n)\n</code></pre> <p>Convert an ASE atoms object to a phonopy object with displacements generated.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>ASE atoms object</p> </li> <li> <code>supercell_matrix</code>             (<code>ArrayLike</code>)         \u2013          <p>Supercell matrix to use.</p> </li> <li> <code>atom_disp</code>             (<code>float</code>)         \u2013          <p>Atomic displacement (A).</p> </li> <li> <code>phonopy_kwargs</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional kwargs to pass to the Phonopy class.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Phonopy</code>         \u2013          <p>Phonopy object</p> </li> </ul> Source code in <code>quacc/atoms/phonons.py</code> <pre><code>def atoms_to_phonopy(\n    atoms: Atoms,\n    supercell_matrix: ArrayLike,\n    atom_disp: float,\n    phonopy_kwargs: dict | None = None,\n) -&gt; Phonopy:\n    \"\"\"\n    Convert an ASE atoms object to a phonopy object with displacements\n    generated.\n\n    Parameters\n    ----------\n    atoms\n        ASE atoms object\n    supercell_matrix\n        Supercell matrix to use.\n    atom_disp\n        Atomic displacement (A).\n    phonopy_kwargs\n        Additional kwargs to pass to the Phonopy class.\n\n    Returns\n    -------\n    Phonopy\n        Phonopy object\n    \"\"\"\n    phonopy_kwargs = phonopy_kwargs or {}\n    structure = AseAtomsAdaptor().get_structure(atoms)\n    phonopy_atoms = get_phonopy_structure(structure)\n    phonon = phonopy.Phonopy(\n        phonopy_atoms, supercell_matrix=supercell_matrix, **phonopy_kwargs\n    )\n    phonon.generate_displacements(distance=atom_disp)\n    return phonon\n</code></pre>"},{"location":"reference/quacc/atoms/phonons.html#quacc.atoms.phonons.phonopy_atoms_to_ase_atoms","title":"phonopy_atoms_to_ase_atoms","text":"<pre><code>phonopy_atoms_to_ase_atoms(phonpy_atoms)\n</code></pre> <p>Convert a phonopy atoms object to an ASE atoms object.</p> <p>Parameters:</p> <ul> <li> <code>phonpy_atoms</code>             (<code>PhonopyAtoms</code>)         \u2013          <p>Phonopy atoms object</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Atoms</code>         \u2013          <p>ASE atoms object</p> </li> </ul> Source code in <code>quacc/atoms/phonons.py</code> <pre><code>def phonopy_atoms_to_ase_atoms(phonpy_atoms: PhonopyAtoms) -&gt; Atoms:\n    \"\"\"\n    Convert a phonopy atoms object to an ASE atoms object.\n\n    Parameters\n    ----------\n    phonpy_atoms\n        Phonopy atoms object\n\n    Returns\n    -------\n    Atoms\n        ASE atoms object\n    \"\"\"\n    pmg_structure = get_pmg_structure(phonpy_atoms)\n    return AseAtomsAdaptor().get_atoms(pmg_structure)\n</code></pre>"},{"location":"reference/quacc/atoms/slabs.html","title":"slabs","text":"<p>Utility functions for dealing with slabs.</p>"},{"location":"reference/quacc/atoms/slabs.html#quacc.atoms.slabs.flip_atoms","title":"flip_atoms","text":"<pre><code>flip_atoms(atoms, return_struct=False)\n</code></pre> <p>Convenience function for vertically flipping periodic atoms or structures.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms | Structure | Slab</code>)         \u2013          <p>Atoms/.Structure to flip</p> </li> <li> <code>return_struct</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>True if a Pymatgen structure object should be returned. False if an ASE atoms object should be returned</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Atoms | Structure | Slab</code>         \u2013          <p>Inverted slab</p> </li> </ul> Source code in <code>quacc/atoms/slabs.py</code> <pre><code>def flip_atoms(\n    atoms: Atoms | Structure | Slab, return_struct: bool = False\n) -&gt; Atoms | Structure | Slab:\n    \"\"\"\n    Convenience function for vertically flipping periodic atoms or structures.\n\n    Parameters\n    ----------\n    atoms\n        Atoms/.Structure to flip\n    return_struct\n        True if a Pymatgen structure object should be returned. False if an ASE\n        atoms object should be returned\n\n    Returns\n    -------\n    Atoms | Structure | Slab\n        Inverted slab\n    \"\"\"\n\n    if isinstance(atoms, Atoms):\n        new_atoms = copy_atoms(atoms)\n    else:\n        new_atoms = AseAtomsAdaptor.get_atoms(atoms)\n\n    new_atoms.rotate(180, \"x\")\n    new_atoms.wrap()\n\n    if return_struct:\n        new_atoms = AseAtomsAdaptor.get_structure(new_atoms)\n\n    return new_atoms\n</code></pre>"},{"location":"reference/quacc/atoms/slabs.html#quacc.atoms.slabs.get_surface_energy","title":"get_surface_energy","text":"<pre><code>get_surface_energy(bulk, slab, bulk_energy, slab_energy)\n</code></pre> <p>Calculate the surface energy to form a given surface slab from a bulk structure. For asymmetric slabs, this is better thought of as the cleavage energy.</p> <p>Parameters:</p> <ul> <li> <code>bulk</code>             (<code>Atoms</code>)         \u2013          <p>The bulk structure.</p> </li> <li> <code>slab</code>             (<code>Atoms</code>)         \u2013          <p>The slab structure.</p> </li> <li> <code>bulk_energy</code>             (<code>float</code>)         \u2013          <p>The total energy of the bulk structure.</p> </li> <li> <code>slab_energy</code>             (<code>float</code>)         \u2013          <p>The total energy of the slab structure.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>floating</code>         \u2013          <p>The surface energy in eV/A^2.</p> </li> </ul> Source code in <code>quacc/atoms/slabs.py</code> <pre><code>def get_surface_energy(\n    bulk: Atoms, slab: Atoms, bulk_energy: float, slab_energy: float\n) -&gt; np.floating:\n    \"\"\"\n    Calculate the surface energy to form a given surface slab from a bulk structure. For\n    asymmetric slabs, this is better thought of as the cleavage energy.\n\n    Parameters\n    -----------\n    bulk\n        The bulk structure.\n    slab\n        The slab structure.\n    bulk_energy\n        The total energy of the bulk structure.\n    slab_energy\n        The total energy of the slab structure.\n\n    Returns\n    -------\n    np.floating\n        The surface energy in eV/A^2.\n    \"\"\"\n\n    alpha = len(slab) / len(bulk)\n    cell = slab.get_cell()\n    A = np.linalg.norm(np.cross(cell[0], cell[1]))\n    return (slab_energy - alpha * bulk_energy) / (2 * A)\n</code></pre>"},{"location":"reference/quacc/atoms/slabs.html#quacc.atoms.slabs.make_adsorbate_structures","title":"make_adsorbate_structures","text":"<pre><code>make_adsorbate_structures(\n    atoms,\n    adsorbate,\n    min_distance=2.0,\n    modes=None,\n    allowed_surface_symbols=None,\n    allowed_surface_indices=None,\n    ads_site_finder_kwargs=None,\n    find_ads_sites_kwargs=None,\n)\n</code></pre> <p>Add a single adsorbate to a structure for every requested adsorption mode.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>The atoms to add adsorbates to.</p> </li> <li> <code>adsorbate</code>             (<code>Atoms</code>)         \u2013          <p>The adsorbate to add. Note: It will be placed on the surface in the exact input orientation provided by the user (the adsorption mode is along the c axis and the coordinating atom is the one in the -z direction).</p> </li> <li> <code>min_distance</code>             (<code>float</code>, default:                 <code>2.0</code> )         \u2013          <p>The (minimum) distance to set between the adsorbate and the surface site.</p> </li> <li> <code>modes</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>The adsorption mode(s) to consider. Options include: \"ontop\", \"bridge\", \"hollow\", \"subsurface\".</p> </li> <li> <code>allowed_surface_symbols</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>The symbols of surface atoms to consider. If None, will use all surface atoms. Note: This method could be improved for bridge/hollow sites.</p> </li> <li> <code>allowed_surface_indices</code>             (<code>list[int] | None</code>, default:                 <code>None</code> )         \u2013          <p>The indices of surface atoms to consider. If None, will use all surface atoms. Generally used if a specific site is to be excluded from the set. Note: This method could be improved for bridge/hollow sites.</p> </li> <li> <code>ads_site_finder_kwargs</code>             (<code>AdsSiteFinderKwargs | None</code>, default:                 <code>None</code> )         \u2013          <p>The keyword arguments to pass to the AdsorbateSiteFinder().</p> </li> <li> <code>find_ads_sites_kwargs</code>             (<code>FindAdsSitesKwargs | None</code>, default:                 <code>None</code> )         \u2013          <p>The keyword arguments to pass to AdsorbateSiteFinder.find_adsorption_sites().</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Atoms]</code>         \u2013          <p>The structures with adsorbates</p> </li> </ul> Source code in <code>quacc/atoms/slabs.py</code> <pre><code>def make_adsorbate_structures(\n    atoms: Atoms,\n    adsorbate: Atoms,\n    min_distance: float = 2.0,\n    modes: list[str] | None = None,\n    allowed_surface_symbols: list[str] | None = None,\n    allowed_surface_indices: list[int] | None = None,\n    ads_site_finder_kwargs: AdsSiteFinderKwargs | None = None,\n    find_ads_sites_kwargs: FindAdsSitesKwargs | None = None,\n) -&gt; list[Atoms]:\n    \"\"\"\n    Add a single adsorbate to a structure for every requested adsorption mode.\n\n    Parameters\n    ----------\n    atoms\n        The atoms to add adsorbates to.\n    adsorbate\n        The adsorbate to add. Note: It will be placed on the surface in the\n        exact input orientation provided by the user (the adsorption mode is\n        along the c axis and the coordinating atom is the one in the -z\n        direction).\n    min_distance\n        The (minimum) distance to set between the adsorbate and the surface\n        site.\n    modes\n        The adsorption mode(s) to consider. Options include: \"ontop\", \"bridge\",\n        \"hollow\", \"subsurface\".\n    allowed_surface_symbols\n        The symbols of surface atoms to consider. If None, will use all surface\n        atoms. Note: This method could be improved for bridge/hollow sites.\n    allowed_surface_indices\n        The indices of surface atoms to consider. If None, will use all surface\n        atoms. Generally used if a specific site is to be excluded from the set.\n        Note: This method could be improved for bridge/hollow sites.\n    ads_site_finder_kwargs\n        The keyword arguments to pass to the AdsorbateSiteFinder().\n    find_ads_sites_kwargs\n        The keyword arguments to pass to\n        AdsorbateSiteFinder.find_adsorption_sites().\n\n    Returns\n    --------\n    list[Atoms]\n        The structures with adsorbates\n    \"\"\"\n    atoms = copy_atoms(atoms)\n\n    if modes is None:\n        modes = [\"ontop\", \"bridge\", \"hollow\"]\n\n    ads_site_finder_kwargs = ads_site_finder_kwargs or {}\n    find_ads_sites_kwargs = find_ads_sites_kwargs or {}\n\n    # Check for double-used parameters\n    if min_distance and \"distance\" in find_ads_sites_kwargs:\n        msg = \"Cannot specify both min_distance and find_ads_sites_kwargs['distance']\"\n        raise ValueError(msg)\n    if modes and \"positions\" in find_ads_sites_kwargs:\n        msg = \"Cannot specify both modes and find_ads_sites_kwargs['positions']\"\n        raise ValueError(msg)\n    find_ads_sites_kwargs[\"distance\"] = min_distance\n    find_ads_sites_kwargs[\"positions\"] = [mode.lower() for mode in modes]\n\n    # Check the provided surface indices are reasonable\n    atom_indices = [atom.index for atom in atoms]\n    if allowed_surface_indices and any(\n        idx not in atom_indices for idx in allowed_surface_indices\n    ):\n        msg = \"All indices in allowed_surface_indices must be in atoms.\"\n        raise ValueError(msg, allowed_surface_indices, atom_indices)\n\n    # Add 0.0 initial magmoms to atoms/adsorbate if needed\n    if atoms.has(\"initial_magmoms\") and not adsorbate.has(\"initial_magmoms\"):\n        adsorbate.set_initial_magnetic_moments([0.0] * len(adsorbate))\n    if adsorbate.has(\"initial_magmoms\") and not atoms.has(\"initial_magmoms\"):\n        atoms.set_initial_magnetic_moments([0.0] * len(atoms))\n\n    # Make a Pymatgen structure and molecule\n    struct = AseAtomsAdaptor.get_structure(atoms)\n    mol = AseAtomsAdaptor.get_molecule(adsorbate, charge_spin_check=False)\n\n    # Get the adsorption sites\n    ads_finder = AdsorbateSiteFinder(struct, **ads_site_finder_kwargs)\n    ads_sites = ads_finder.find_adsorption_sites(**find_ads_sites_kwargs)\n\n    # Find and add the adsorbates\n    new_atoms = []\n    for mode, ads_coords in ads_sites.items():\n        # Check if mode is in desired list\n        if mode not in modes:\n            continue\n\n        for ads_coord in ads_coords:\n            # Place adsorbate\n            struct_with_adsorbate = ads_finder.add_adsorbate(mol, ads_coord)\n\n            # Convert back to Atoms object\n            atoms_with_adsorbate = AseAtomsAdaptor.get_atoms(struct_with_adsorbate)\n\n            # Get distance matrix between adsorbate binding atom and surface\n            d = atoms_with_adsorbate.get_all_distances(mic=True)[\n                0 : len(atoms), len(atoms) :\n            ]\n\n            # Find closest surface atoms\n            min_d = np.min(d)\n            surface_atom_indices = np.where(\n                (d &gt;= min_d - min_d * 0.1) &amp; (d &lt;= min_d + min_d * 0.1)\n            )[0]\n\n            surface_atom_symbols = atoms_with_adsorbate[\n                surface_atom_indices\n            ].get_chemical_symbols()\n\n            # Check if surface binding site is not in the specified user list.\n            # If so, skip this one\n            if allowed_surface_symbols and all(\n                surface_atom_symbol not in allowed_surface_symbols\n                for surface_atom_symbol in surface_atom_symbols\n            ):\n                continue\n\n            if allowed_surface_indices and all(\n                surface_atom_idx not in allowed_surface_indices\n                for surface_atom_idx in surface_atom_indices\n            ):\n                continue\n\n            # Store adsorbate info\n            atoms_with_adsorbate.info = atoms.info.copy()\n            ads_stats = {\n                \"adsorbate\": adsorbate,\n                \"initial_mode\": mode,\n                \"surface_atoms_symbols\": surface_atom_symbols,\n                \"surface_atoms_indices\": surface_atom_indices,\n            }\n            if atoms_with_adsorbate.info.get(\"adsorbates\", None) is None:\n                atoms_with_adsorbate.info[\"adsorbates\"] = [ads_stats]\n            else:\n                atoms_with_adsorbate.info[\"adsorbates\"].extend([ads_stats])\n\n            # Add slab+adsorbate to list\n            new_atoms.append(atoms_with_adsorbate)\n\n    return new_atoms\n</code></pre>"},{"location":"reference/quacc/atoms/slabs.html#quacc.atoms.slabs.make_slabs_from_bulk","title":"make_slabs_from_bulk","text":"<pre><code>make_slabs_from_bulk(\n    atoms,\n    max_index=1,\n    min_slab_size=10.0,\n    min_length_width=8.0,\n    min_vacuum_size=20.0,\n    z_fix=2.0,\n    flip_asymmetric=True,\n    allowed_surface_symbols=None,\n    **slabgen_kwargs\n)\n</code></pre> <p>Function to make slabs from a bulk atoms object.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>bulk atoms</p> </li> <li> <code>max_index</code>             (<code>int</code>, default:                 <code>1</code> )         \u2013          <p>Maximum Miller index for slab generation</p> </li> <li> <code>min_slab_size</code>             (<code>float</code>, default:                 <code>10.0</code> )         \u2013          <p>Minimum slab size (depth) in angstroms</p> </li> <li> <code>min_length_width</code>             (<code>float</code>, default:                 <code>8.0</code> )         \u2013          <p>Minimum length and width of the slab in angstroms</p> </li> <li> <code>min_vacuum_size</code>             (<code>float</code>, default:                 <code>20.0</code> )         \u2013          <p>Minimum vacuum size in angstroms</p> </li> <li> <code>z_fix</code>             (<code>float | None</code>, default:                 <code>2.0</code> )         \u2013          <p>Distance (in angstroms) from top of slab for which atoms should be fixed</p> </li> <li> <code>flip_asymmetric</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>If an asymmetric surface should be flipped and added to the list</p> </li> <li> <code>allowed_surface_symbols</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>List of chemical symbols that must be present on the surface of the slab otherwise the slab will be discarded, e.g. [\"Cu\", \"Ni\"]</p> </li> <li> <code>**slabgen_kwargs</code>         \u2013          <p><code>generate_all_slabs</code> function</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Atoms]</code>         \u2013          <p>All generated slabs</p> </li> </ul> Source code in <code>quacc/atoms/slabs.py</code> <pre><code>def make_slabs_from_bulk(\n    atoms: Atoms,\n    max_index: int = 1,\n    min_slab_size: float = 10.0,\n    min_length_width: float = 8.0,\n    min_vacuum_size: float = 20.0,\n    z_fix: float | None = 2.0,\n    flip_asymmetric: bool = True,\n    allowed_surface_symbols: list[str] | None = None,\n    **slabgen_kwargs,\n) -&gt; list[Atoms]:\n    \"\"\"\n    Function to make slabs from a bulk atoms object.\n\n    Parameters\n    ----------\n    atoms\n        bulk atoms\n    max_index\n        Maximum Miller index for slab generation\n    min_slab_size\n        Minimum slab size (depth) in angstroms\n    min_length_width\n        Minimum length and width of the slab in angstroms\n    min_vacuum_size\n        Minimum vacuum size in angstroms\n    z_fix\n        Distance (in angstroms) from top of slab for which atoms should be fixed\n    flip_asymmetric\n        If an asymmetric surface should be flipped and added to the list\n    allowed_surface_symbols\n        List of chemical symbols that must be present on the surface of the slab\n        otherwise the slab will be discarded, e.g. [\"Cu\", \"Ni\"]\n    **slabgen_kwargs: keyword arguments to pass to the pymatgen\n        `generate_all_slabs` function\n\n    Returns\n    -------\n    list[Atoms]\n        All generated slabs\n    \"\"\"\n\n    # Note: This will not work properly for 2D structures. See Oxana/Martin's\n    # code for adjustments for 2D:\n    # https://github.com/oxana-a/atomate/blob/ads_wf/atomate/vasp/firetasks/adsorption_tasks.py\n\n    # Use pymatgen to generate slabs\n    struct = AseAtomsAdaptor.get_structure(atoms)\n\n    # Make all the slabs\n    slabs = generate_all_slabs(\n        struct,\n        max_index,\n        min_slab_size,\n        min_vacuum_size,\n        center_slab=True,\n        **slabgen_kwargs,\n    )\n\n    # If the two terminations are not equivalent, make new slab by inverting the\n    # original slab and add it to the list\n    if flip_asymmetric:\n        new_slabs = []\n        for slab in slabs:\n            if not slab.is_symmetric():\n                # Flip the slab and its oriented unit cell\n                new_slab = flip_atoms(slab, return_struct=True)  # type: Slab\n                new_oriented_unit_cell = flip_atoms(\n                    slab.oriented_unit_cell, return_struct=True\n                )  # type: Slab\n\n                # Reconstruct the full slab object, noting the new shift and\n                # oriented unit cell\n                new_slab = Slab(\n                    new_slab.lattice,\n                    new_slab.species,\n                    coords=new_slab.frac_coords,\n                    miller_index=slab.miller_index,\n                    oriented_unit_cell=new_oriented_unit_cell,\n                    shift=-slab.shift,\n                    scale_factor=slab.scale_factor,\n                    site_properties=new_slab.site_properties,\n                )\n\n                # It looks better to center the inverted slab so we do that\n                # here.\n                new_slab = center_slab(new_slab)\n\n                # Add the new slab to the list\n                new_slabs.append(new_slab)\n\n        slabs.extend(new_slabs)\n\n    # For each slab, make sure the lengths and widths are large enough and fix\n    # atoms z_fix away from the top of the slab.\n    slabs_with_props = []\n    for slab in slabs:\n        # Make sure desired atoms are on surface\n        if allowed_surface_symbols:\n            # Find atoms at surface\n            surf_sites = AdsorbateSiteFinder(slab.copy()).surface_sites\n            surface_species = [s.specie.symbol for s in surf_sites]\n\n        if allowed_surface_symbols and all(\n            allowed_surface_atom not in surface_species\n            for allowed_surface_atom in allowed_surface_symbols\n        ):\n            continue\n\n        # Supercell creation (if necessary)\n        a_factor = round(np.ceil(min_length_width / slab.lattice.abc[0]))\n        b_factor = round(np.ceil(min_length_width / slab.lattice.abc[1]))\n        slab.make_supercell([a_factor, b_factor, 1])\n\n        # Add constraints. Note: This does not actually add an adsorbate\n        if z_fix:\n            sel_dyn = AdsorbateSiteFinder(\n                slab.copy(), selective_dynamics=True, height=z_fix\n            ).slab.site_properties[\"selective_dynamics\"]\n            slab.add_site_property(\"selective_dynamics\", sel_dyn)\n\n        # Add slab to list\n        slabs_with_props.append(slab)\n\n    final_slabs = []\n    if not slabs_with_props:\n        return final_slabs\n\n    # Make atoms objects and store slab stats\n    for slab_with_props in slabs_with_props:\n        final_slab = AseAtomsAdaptor.get_atoms(slab_with_props)\n        slab_stats = {\n            \"bulk\": atoms,\n            \"miller_index\": slab_with_props.miller_index,\n            \"shift\": round(slab_with_props.shift, 3),\n            \"scale_factor\": slab_with_props.scale_factor,\n        }\n        final_slab.info[\"slab_stats\"] = slab_stats\n        final_slabs.append(final_slab)\n\n    return final_slabs\n</code></pre>"},{"location":"reference/quacc/calculators/qchem/io.html","title":"io","text":"<p>Q-Chem calculator IO.</p>"},{"location":"reference/quacc/calculators/qchem/io.html#quacc.calculators.qchem.io.read_qchem","title":"read_qchem","text":"<pre><code>read_qchem(directory='.')\n</code></pre> <p>Read Q-Chem log files.</p> <p>Parameters:</p> <ul> <li> <code>directory</code>             (<code>Path | str</code>, default:                 <code>'.'</code> )         \u2013          <p>The directory in which the Q-Chem calculation was run.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[Results, list[float]]</code>         \u2013          <p>The results of the calculation and the orbital coefficients from a previous calculation.</p> </li> </ul> Source code in <code>quacc/calculators/qchem/io.py</code> <pre><code>def read_qchem(directory: Path | str = \".\") -&gt; tuple[Results, list[float]]:\n    \"\"\"\n    Read Q-Chem log files.\n\n    Parameters\n    ----------\n    directory\n        The directory in which the Q-Chem calculation was run.\n\n    Returns\n    -------\n    tuple[Results, list[float]]\n        The results of the calculation and the orbital coefficients from a previous\n        calculation.\n    \"\"\"\n    directory = Path(directory)\n    qc_input = QCInput.from_file(directory / \"mol.qin\").as_dict()\n    qc_output = QCOutput(directory / \"mol.qout\").data\n\n    results: Results = {\n        \"energy\": qc_output[\"final_energy\"] * units.Hartree,\n        \"qc_output\": qc_output,\n        \"qc_input\": qc_input,\n        \"custodian\": _parse_custodian(directory),\n    }\n\n    # Read the gradient scratch file in 8 byte chunks\n    grad_scratch = directory / \"131.0\"\n    if grad_scratch.exists() and grad_scratch.stat().st_size &gt; 0:\n        tmp_grad_data = []\n        with zopen(grad_scratch, mode=\"rb\") as file:\n            binary = file.read()\n        tmp_grad_data.extend(\n            struct.unpack(\"d\", binary[ii * 8 : (ii + 1) * 8])[0]\n            for ii in range(len(binary) // 8)\n        )\n        grad = [\n            [\n                float(tmp_grad_data[ii * 3]),\n                float(tmp_grad_data[ii * 3 + 1]),\n                float(tmp_grad_data[ii * 3 + 2]),\n            ]\n            for ii in range(len(tmp_grad_data) // 3)\n        ]\n\n        # Ensure that the scratch values match the correct values from the\n        # output file but with higher precision\n        if qc_output[\"pcm_gradients\"] is not None:\n            gradient = qc_output[\"pcm_gradients\"][0]\n        else:\n            gradient = qc_output[\"gradients\"][0]\n        for ii, subgrad in enumerate(grad):\n            for jj, val in enumerate(subgrad):\n                if abs(gradient[ii, jj] - val) &gt; 1e-6:\n                    raise ValueError(\n                        \"Difference between gradient value in scratch file vs. output file should not be this large.\"\n                    )\n                gradient[ii, jj] = val\n\n        # Convert gradient to force + deal with units\n        results[\"forces\"] = gradient * (-units.Hartree / units.Bohr)\n\n    # Read Hessian scratch file in 8 byte chunks\n    hessian_scratch = directory / \"132.0\"\n    if hessian_scratch.exists() and hessian_scratch.stat().st_size &gt; 0:\n        tmp_hess_data = []\n        with zopen(hessian_scratch, mode=\"rb\") as file:\n            binary = file.read()\n        tmp_hess_data.extend(\n            struct.unpack(\"d\", binary[ii * 8 : (ii + 1) * 8])[0]\n            for ii in range(len(binary) // 8)\n        )\n        reshaped_hess = np.reshape(\n            np.array(tmp_hess_data),\n            (len(qc_output[\"species\"]) * 3, len(qc_output[\"species\"]) * 3),\n        )\n        results[\"hessian\"] = reshaped_hess * (units.Hartree / units.Bohr**2)\n        results[\"enthalpy\"] = qc_output[\"total_enthalpy\"] * (units.kcal / units.mol)\n        results[\"entropy\"] = qc_output[\"total_entropy\"] * (\n            0.001 * units.kcal / units.mol\n        )\n\n    # Read orbital coefficients scratch file in 8 byte chunks\n    prev_orbital_coeffs = []\n    with zopen(directory / \"53.0\", mode=\"rb\") as file:\n        binary = file.read()\n    prev_orbital_coeffs.extend(\n        struct.unpack(\"d\", binary[ii * 8 : (ii + 1) * 8])[0]\n        for ii in range(len(binary) // 8)\n    )\n\n    return results, prev_orbital_coeffs\n</code></pre>"},{"location":"reference/quacc/calculators/qchem/io.html#quacc.calculators.qchem.io.write_qchem","title":"write_qchem","text":"<pre><code>write_qchem(\n    atoms,\n    directory=\".\",\n    charge=0,\n    spin_multiplicity=1,\n    basis_set=\"def2-tzvpd\",\n    job_type=\"force\",\n    scf_algorithm=\"diis\",\n    qchem_input_params=None,\n    prev_orbital_coeffs=None,\n)\n</code></pre> <p>Write the Q-Chem input files.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>The Atoms object to be used for the calculation.</p> </li> <li> <code>directory</code>             (<code>Path | str</code>, default:                 <code>'.'</code> )         \u2013          <p>The directory in which to write the Q-Chem input files.</p> </li> <li> <code>charge</code>             (<code>int</code>, default:                 <code>0</code> )         \u2013          <p>The total charge of the molecular system.</p> </li> <li> <code>spin_multiplicity</code>             (<code>int</code>, default:                 <code>1</code> )         \u2013          <p>The spin multiplicity of the molecular system.</p> </li> <li> <code>basis_set</code>             (<code>str</code>, default:                 <code>'def2-tzvpd'</code> )         \u2013          <p>The basis set to use for the calculation.</p> </li> <li> <code>job_type</code>             (<code>Literal['sp', 'force', 'opt', 'freq']</code>, default:                 <code>'force'</code> )         \u2013          <p>The type of calculation to perform.</p> </li> <li> <code>scf_algorithm</code>             (<code>str</code>, default:                 <code>'diis'</code> )         \u2013          <p>The SCF algorithm to use for the calculation.</p> </li> <li> <code>qchem_input_params</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of Q-Chem input parameters to be passed to <code>pymatgen.io.qchem.sets.DictSet</code>.</p> </li> <li> <code>prev_orbital_coeffs</code>             (<code>list[float] | None</code>, default:                 <code>None</code> )         \u2013          <p>The orbital coefficients from a previous calculation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          </li> </ul> Source code in <code>quacc/calculators/qchem/io.py</code> <pre><code>def write_qchem(\n    atoms: Atoms,\n    directory: Path | str = \".\",\n    charge: int = 0,\n    spin_multiplicity: int = 1,\n    basis_set: str = \"def2-tzvpd\",\n    job_type: Literal[\"sp\", \"force\", \"opt\", \"freq\"] = \"force\",\n    scf_algorithm: str = \"diis\",\n    qchem_input_params: dict[str, Any] | None = None,\n    prev_orbital_coeffs: list[float] | None = None,\n) -&gt; None:\n    \"\"\"\n    Write the Q-Chem input files.\n\n    Parameters\n    ----------\n    atoms\n        The Atoms object to be used for the calculation.\n    directory\n        The directory in which to write the Q-Chem input files.\n    charge\n        The total charge of the molecular system.\n    spin_multiplicity\n        The spin multiplicity of the molecular system.\n    basis_set\n        The basis set to use for the calculation.\n    job_type\n        The type of calculation to perform.\n    scf_algorithm\n        The SCF algorithm to use for the calculation.\n    qchem_input_params\n        Dictionary of Q-Chem input parameters to be passed to\n        `pymatgen.io.qchem.sets.DictSet`.\n    prev_orbital_coeffs\n        The orbital coefficients from a previous calculation.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    directory = Path(directory)\n\n    if prev_orbital_coeffs is not None:\n        with Path(directory / \"53.0\").open(mode=\"wb\") as file:\n            for val in prev_orbital_coeffs:\n                data = struct.pack(\"d\", val)\n                file.write(data)\n        if \"overwrite_inputs\" not in qchem_input_params:\n            qchem_input_params[\"overwrite_inputs\"] = {}\n        if \"rem\" not in qchem_input_params[\"overwrite_inputs\"]:\n            qchem_input_params[\"overwrite_inputs\"][\"rem\"] = {}\n        if \"scf_guess\" not in qchem_input_params[\"overwrite_inputs\"][\"rem\"]:\n            qchem_input_params[\"overwrite_inputs\"][\"rem\"][\"scf_guess\"] = \"read\"\n\n    atoms.charge = charge\n    atoms.spin_multiplicity = spin_multiplicity\n    mol = AseAtomsAdaptor.get_molecule(atoms)\n    QChemDictSet(\n        mol, job_type, basis_set, scf_algorithm, qchem_version=6, **qchem_input_params\n    ).write(directory / \"mol.qin\")\n</code></pre>"},{"location":"reference/quacc/calculators/qchem/qchem.html","title":"qchem","text":"<p>A Q-Chem calculator built on Pymatgen and Custodian functionality.</p>"},{"location":"reference/quacc/calculators/qchem/qchem.html#quacc.calculators.qchem.qchem.QChem","title":"QChem","text":"<pre><code>QChem(\n    atoms,\n    charge=0,\n    spin_multiplicity=1,\n    method=None,\n    basis_set=\"def2-tzvpd\",\n    job_type=\"force\",\n    scf_algorithm=\"diis\",\n    cores=1,\n    qchem_input_params=None,\n    **fileiocalculator_kwargs\n)\n</code></pre> <p>             Bases: <code>FileIOCalculator</code></p> <p>Custom Q-Chem calculator built on Pymatgen and Custodian.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>The Atoms object to be used for the calculation.</p> </li> <li> <code>cores</code>             (<code>int</code>, default:                 <code>1</code> )         \u2013          <p>Number of cores to use for the Q-Chem calculation.</p> </li> <li> <code>charge</code>             (<code>int</code>, default:                 <code>0</code> )         \u2013          <p>The total charge of the molecular system.</p> </li> <li> <code>spin_multiplicity</code>             (<code>int</code>, default:                 <code>1</code> )         \u2013          <p>The spin multiplicity of the molecular system.</p> </li> <li> <code>method</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>The level of theory to use.</p> </li> <li> <code>basis_set</code>             (<code>str</code>, default:                 <code>'def2-tzvpd'</code> )         \u2013          <p>The basis set.</p> </li> <li> <code>job_type</code>             (<code>Literal['sp', 'force', 'opt', 'freq']</code>, default:                 <code>'force'</code> )         \u2013          <p>The job type for the calculation.</p> </li> <li> <code>scf_algorithm</code>             (<code>str</code>, default:                 <code>'diis'</code> )         \u2013          <p>The SCF algorithm to use</p> </li> <li> <code>cores</code>             (<code>int</code>, default:                 <code>1</code> )         \u2013          <p>The number of CPU cores to run on.</p> </li> <li> <code>qchem_input_params</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of Q-Chem input parameters to be passed to <code>pymatgen.io.qchem.sets.DictSet</code>.</p> </li> <li> <code>**fileiocalculator_kwargs</code>         \u2013          <p>Additional arguments to be passed to <code>ase.calculators.calculator.FileIOCalculator</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          </li> </ul> Source code in <code>quacc/calculators/qchem/qchem.py</code> <pre><code>def __init__(\n    self,\n    atoms: Atoms,\n    charge: int = 0,\n    spin_multiplicity: int = 1,\n    method: str | None = None,\n    basis_set: str = \"def2-tzvpd\",\n    job_type: Literal[\"sp\", \"force\", \"opt\", \"freq\"] = \"force\",\n    scf_algorithm: str = \"diis\",\n    cores: int = 1,\n    qchem_input_params: dict[str, Any] | None = None,\n    **fileiocalculator_kwargs,\n) -&gt; None:\n    \"\"\"\n    Initialize the Q-Chem calculator.\n\n    Parameters\n    ----------\n    atoms\n        The Atoms object to be used for the calculation.\n    cores\n        Number of cores to use for the Q-Chem calculation.\n    charge\n        The total charge of the molecular system.\n    spin_multiplicity\n        The spin multiplicity of the molecular system.\n    method\n        The level of theory to use.\n    basis_set\n        The basis set.\n    job_type\n        The job type for the calculation.\n    scf_algorithm\n        The SCF algorithm to use\n    cores\n        The number of CPU cores to run on.\n    qchem_input_params\n        Dictionary of Q-Chem input parameters to be passed to\n        `pymatgen.io.qchem.sets.DictSet`.\n    **fileiocalculator_kwargs\n        Additional arguments to be passed to\n        `ase.calculators.calculator.FileIOCalculator`.\n\n    Returns\n    -------\n    None\n    \"\"\"\n\n    # Assign variables to self\n    self.atoms = atoms\n    self.charge = charge\n    self.spin_multiplicity = spin_multiplicity\n    self.method = method\n    self.basis_set = basis_set\n    self.job_type = job_type\n    self.scf_algorithm = scf_algorithm\n    self.cores = cores\n    self.qchem_input_params = qchem_input_params or {}\n    self.fileiocalculator_kwargs = fileiocalculator_kwargs\n\n    # Instantiate previous orbital coefficients\n    self._prev_orbital_coeffs = None\n\n    if \"directory\" in self.fileiocalculator_kwargs:\n        raise NotImplementedError(\"The directory kwarg is not supported.\")\n\n    # Clean up parameters\n    self._cleanup_qchem_input_params()\n    self._set_default_params()\n\n    # Get Q-Chem executable command\n    command = self._manage_environment()\n\n    # Instantiate the calculator\n    super().__init__(\n        restart=None,\n        ignore_bad_restart_file=FileIOCalculator._deprecated,\n        label=None,\n        atoms=self.atoms,\n        command=command,\n        profile=None,\n        **self.fileiocalculator_kwargs,\n    )\n</code></pre>"},{"location":"reference/quacc/calculators/qchem/qchem.html#quacc.calculators.qchem.qchem.QChem.read_results","title":"read_results","text":"<pre><code>read_results()\n</code></pre> <p>Read the Q-Chem output files. Update the .results and ._prev_orbital_coeffs attributes.</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          </li> </ul> Source code in <code>quacc/calculators/qchem/qchem.py</code> <pre><code>def read_results(self) -&gt; None:\n    \"\"\"\n    Read the Q-Chem output files. Update the .results and ._prev_orbital_coeffs\n    attributes.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    results, _prev_orbital_coeffs = read_qchem()\n    self.results = results\n    self._prev_orbital_coeffs = _prev_orbital_coeffs\n</code></pre>"},{"location":"reference/quacc/calculators/qchem/qchem.html#quacc.calculators.qchem.qchem.QChem.write_input","title":"write_input","text":"<pre><code>write_input(atoms, properties=None, system_changes=None)\n</code></pre> <p>Write the Q-Chem input files.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>The Atoms object to be used for the calculation.</p> </li> <li> <code>properties</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>List of properties to calculate.</p> </li> <li> <code>system_changes</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>List of changes to the system since last calculation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          </li> </ul> Source code in <code>quacc/calculators/qchem/qchem.py</code> <pre><code>def write_input(\n    self,\n    atoms: Atoms,\n    properties: list[str] | None = None,\n    system_changes: list[str] | None = None,\n) -&gt; None:\n    \"\"\"\n    Write the Q-Chem input files.\n\n    Parameters\n    ----------\n    atoms\n        The Atoms object to be used for the calculation.\n    properties\n        List of properties to calculate.\n    system_changes\n        List of changes to the system since last calculation.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    FileIOCalculator.write_input(self, atoms, properties, system_changes)\n    write_qchem(\n        atoms,\n        charge=self.charge,\n        spin_multiplicity=self.spin_multiplicity,\n        basis_set=self.basis_set,\n        job_type=self.job_type,\n        scf_algorithm=self.scf_algorithm,\n        qchem_input_params=self.qchem_input_params,\n        prev_orbital_coeffs=self._prev_orbital_coeffs,\n    )\n</code></pre>"},{"location":"reference/quacc/calculators/qchem/qchem_custodian.html","title":"qchem_custodian","text":"<p>Custodian handlers for QChem.</p>"},{"location":"reference/quacc/calculators/qchem/qchem_custodian.html#quacc.calculators.qchem.qchem_custodian.run_custodian","title":"run_custodian","text":"<pre><code>run_custodian(\n    qchem_cores=1,\n    qchem_cmd=None,\n    qchem_local_scratch=None,\n    qchem_use_error_handlers=None,\n    qchem_custodian_max_errors=None,\n    qchem_nbo_exe=None,\n)\n</code></pre> <p>Function to run QChem Custodian.</p> <p>Parameters:</p> <ul> <li> <code>qchem_cores</code>             (<code>int</code>, default:                 <code>1</code> )         \u2013          <p>Number of cores to use for the Q-Chem calculation.</p> </li> <li> <code>qchem_cmd</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>Q-Chem command. Defaults to \"qchem\" in settings.</p> </li> <li> <code>qchem_local_scratch</code>             (<code>str | Path | None</code>, default:                 <code>None</code> )         \u2013          <p>Compute-node local scratch directory in which Q-Chem should perform IO. Defaults to /tmp in settings.</p> </li> <li> <code>qchem_use_error_handlers</code>             (<code>bool | None</code>, default:                 <code>None</code> )         \u2013          <p>Whether or not to employ error handlers. Defaults to True in settings.</p> </li> <li> <code>qchem_custodian_max_errors</code>             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>Maximum number of errors to allow before stopping the run. Defaults to 5 in settings.</p> </li> <li> <code>qchem_nbo_exe</code>             (<code>str | Path | None</code>, default:                 <code>None</code> )         \u2013          <p>The full path to the NBO executable.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          </li> </ul> Source code in <code>quacc/calculators/qchem/qchem_custodian.py</code> <pre><code>@requires(ob, \"Openbabel must be installed. Try conda install -c conda-forge openbabel\")\ndef run_custodian(\n    qchem_cores: int = 1,\n    qchem_cmd: str | None = None,\n    qchem_local_scratch: str | Path | None = None,\n    qchem_use_error_handlers: bool | None = None,\n    qchem_custodian_max_errors: int | None = None,\n    qchem_nbo_exe: str | Path | None = None,\n) -&gt; None:\n    \"\"\"\n    Function to run QChem Custodian.\n\n    Parameters\n    ----------\n    qchem_cores\n        Number of cores to use for the Q-Chem calculation.\n    qchem_cmd\n        Q-Chem command. Defaults to \"qchem\" in settings.\n    qchem_local_scratch\n        Compute-node local scratch directory in which Q-Chem should perform IO.\n        Defaults to /tmp in settings.\n    qchem_use_error_handlers\n        Whether or not to employ error handlers. Defaults to True in settings.\n    qchem_custodian_max_errors\n        Maximum number of errors to allow before stopping the run. Defaults to 5\n        in settings.\n    qchem_nbo_exe\n        The full path to the NBO executable.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    # Adapted from atomate.qchem.firetasks.run_calc\n    from custodian import Custodian\n    from custodian.qchem.handlers import QChemErrorHandler\n    from custodian.qchem.jobs import QCJob\n\n    # Set defaults\n    qchem_cmd = SETTINGS.QCHEM_CMD if qchem_cmd is None else qchem_cmd\n    qchem_local_scratch = (\n        SETTINGS.QCHEM_LOCAL_SCRATCH\n        if qchem_local_scratch is None\n        else qchem_local_scratch\n    )\n    qchem_use_error_handlers = (\n        SETTINGS.QCHEM_USE_ERROR_HANDLERS\n        if qchem_use_error_handlers is None\n        else qchem_use_error_handlers\n    )\n    qchem_custodian_max_errors = (\n        SETTINGS.QCHEM_CUSTODIAN_MAX_ERRORS\n        if qchem_custodian_max_errors is None\n        else qchem_custodian_max_errors\n    )\n    qchem_nbo_exe = SETTINGS.QCHEM_NBO_EXE if qchem_nbo_exe is None else qchem_nbo_exe\n\n    # Error handlers for Q-Chem\n    handlers = [QChemErrorHandler()] if qchem_use_error_handlers else []\n\n    # Run Q-Chem\n    jobs = [\n        QCJob(\n            qchem_command=qchem_cmd,\n            max_cores=qchem_cores,\n            calc_loc=str(qchem_local_scratch),\n            nboexe=str(qchem_nbo_exe),\n        )\n    ]\n\n    c = Custodian(handlers, jobs, max_errors=qchem_custodian_max_errors)\n\n    c.run()\n</code></pre>"},{"location":"reference/quacc/calculators/vasp/io.html","title":"io","text":"<p>I/O utilities for the Vasp calculator.</p>"},{"location":"reference/quacc/calculators/vasp/io.html#quacc.calculators.vasp.io.load_vasp_yaml_calc","title":"load_vasp_yaml_calc","text":"<pre><code>load_vasp_yaml_calc(yaml_path)\n</code></pre> <p>Loads a YAML file containing calculator settings. Used for VASP calculations and can read quacc-formatted YAMLs that are of the following format: <pre><code>inputs:\n  xc: pbe\n  algo: all\n  setups:\n    Cu: Cu_pv\n  elemental_magmoms:\n    Fe: 5\n    Cu: 1\n</code></pre> where <code>inputs</code> is a dictionary of ASE-style input parameters, <code>setups</code> is a dictionary of ASE-style pseudopotentials, and and <code>elemental_magmoms</code> is a dictionary of element-wise initial magmoms.</p> <p>Parameters:</p> <ul> <li> <code>yaml_path</code>             (<code>str | Path</code>)         \u2013          <p>Path to the YAML file. This function will look in the <code>VASP_PRESET_DIR</code> (default: quacc/calculators/presets/vasp) for the file, thereby assuming that <code>yaml_path</code> is a relative path within that folder.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>The calculator configuration (i.e. settings).</p> </li> </ul> Source code in <code>quacc/calculators/vasp/io.py</code> <pre><code>def load_vasp_yaml_calc(yaml_path: str | Path) -&gt; dict[str, Any]:\n    \"\"\"\n    Loads a YAML file containing calculator settings. Used for VASP calculations\n    and can read quacc-formatted YAMLs that are of the following format:\n    ```yaml\n    inputs:\n      xc: pbe\n      algo: all\n      setups:\n        Cu: Cu_pv\n      elemental_magmoms:\n        Fe: 5\n        Cu: 1\n    ```\n    where `inputs` is a dictionary of ASE-style input parameters, `setups` is a\n    dictionary of ASE-style pseudopotentials, and and `elemental_magmoms` is a\n    dictionary of element-wise initial magmoms.\n\n    Parameters\n    ----------\n    yaml_path\n        Path to the YAML file. This function will look in the `VASP_PRESET_DIR`\n        (default: quacc/calculators/presets/vasp) for the file, thereby assuming\n        that `yaml_path` is a relative path within that folder.\n\n    Returns\n    -------\n    dict\n        The calculator configuration (i.e. settings).\n    \"\"\"\n\n    config = load_yaml_calc(yaml_path)\n\n    # Allow for either \"Cu_pv\" and \"_pv\" style setups\n    if \"inputs\" in config:\n        config[\"inputs\"] = {\n            k.lower(): v.lower() if isinstance(v, str) else v\n            for k, v in config[\"inputs\"].items()\n        }\n        for k, v in config[\"inputs\"].get(\"setups\", {}).items():\n            if k in v:\n                config[\"inputs\"][\"setups\"][k] = v.split(k)[-1]\n\n    return config\n</code></pre>"},{"location":"reference/quacc/calculators/vasp/params.html","title":"params","text":"<p>Parameter-related utilities for the Vasp calculator.</p>"},{"location":"reference/quacc/calculators/vasp/params.html#quacc.calculators.vasp.params.convert_auto_kpts","title":"convert_auto_kpts","text":"<pre><code>convert_auto_kpts(user_calc_params, auto_kpts, input_atoms)\n</code></pre> <p>Shortcuts for pymatgen k-point generation schemes.</p> <p>Parameters:</p> <ul> <li> <code>user_calc_params</code>             (<code>dict[str, Any]</code>)         \u2013          <p>The user-provided calculator parameters.</p> </li> <li> <code>auto_kpts</code>             (<code>dict[Literal['line_density', 'kppvol', 'kppa'], float]</code>)         \u2013          <p>The auto_kpts kwarg.</p> </li> <li> <code>input_atoms</code>             (<code>Atoms</code>)         \u2013          <p>The input atoms.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>The updated user-provided calculator parameters.</p> </li> </ul> Source code in <code>quacc/calculators/vasp/params.py</code> <pre><code>def convert_auto_kpts(\n    user_calc_params: dict[str, Any],\n    auto_kpts: dict[Literal[\"line_density\", \"kppvol\", \"kppa\"], float],\n    input_atoms: Atoms,\n) -&gt; dict[str, Any]:\n    \"\"\"\n    Shortcuts for pymatgen k-point generation schemes.\n\n    Parameters\n    ----------\n    user_calc_params\n        The user-provided calculator parameters.\n    auto_kpts\n        The auto_kpts kwarg.\n    input_atoms\n        The input atoms.\n\n    Returns\n    -------\n    dict\n        The updated user-provided calculator parameters.\n    \"\"\"\n    struct = AseAtomsAdaptor.get_structure(input_atoms)\n\n    if auto_kpts.get(\"line_density\"):\n        # TODO: Support methods other than latimer-munro\n        kpath = HighSymmKpath(\n            struct,\n            path_type=\"latimer_munro\",\n            has_magmoms=np.any(struct.site_properties.get(\"magmom\", None)),\n        )\n        kpts, _ = kpath.get_kpoints(\n            line_density=auto_kpts[\"line_density\"], coords_are_cartesian=True\n        )\n        kpts = np.stack(kpts)\n        reciprocal = True\n        gamma = None\n\n    else:\n        reciprocal = None\n        force_gamma = user_calc_params.get(\"gamma\", False)\n        max_pmg_kpts = None\n        for k, v in auto_kpts.items():\n            if k == \"kppvol\":\n                pmg_kpts = Kpoints.automatic_density_by_vol(\n                    struct, v, force_gamma=force_gamma\n                )\n            elif k == \"kppa\":\n                pmg_kpts = Kpoints.automatic_density(struct, v, force_gamma=force_gamma)\n            elif k == \"length_densities\":\n                pmg_kpts = Kpoints.automatic_density_by_lengths(\n                    struct, v, force_gamma=force_gamma\n                )\n            else:\n                msg = f\"Unsupported k-point generation scheme: {auto_kpts}.\"\n                raise ValueError(msg)\n\n            max_pmg_kpts = (\n                pmg_kpts\n                if (\n                    not max_pmg_kpts\n                    or np.prod(pmg_kpts.kpts[0]) &gt;= np.prod(max_pmg_kpts.kpts[0])\n                )\n                else max_pmg_kpts\n            )\n\n        kpts = max_pmg_kpts.kpts[0]\n        gamma = max_pmg_kpts.style.name.lower() == \"gamma\"\n\n    user_calc_params[\"kpts\"] = kpts\n    if reciprocal and user_calc_params.get(\"reciprocal\") is None:\n        user_calc_params[\"reciprocal\"] = reciprocal\n    if user_calc_params.get(\"gamma\") is None:\n        user_calc_params[\"gamma\"] = gamma\n\n    return user_calc_params\n</code></pre>"},{"location":"reference/quacc/calculators/vasp/params.html#quacc.calculators.vasp.params.get_param_swaps","title":"get_param_swaps","text":"<pre><code>get_param_swaps(\n    user_calc_params, auto_kpts, input_atoms, incar_copilot\n)\n</code></pre> <p>Swaps out bad INCAR flags.</p> <p>Parameters:</p> <ul> <li> <code>user_calc_params</code>             (<code>dict[str, Any]</code>)         \u2013          <p>The user-provided calculator parameters.</p> </li> <li> <code>auto_kpts</code>             (<code>dict[Literal['line_density', 'kppvol', 'kppa'], float]</code>)         \u2013          <p>The auto_kpts kwarg.</p> </li> <li> <code>input_atoms</code>             (<code>Atoms</code>)         \u2013          <p>The input atoms.</p> </li> <li> <code>incar_copilot</code>             (<code>Literal['off', 'on', 'aggressive']</code>)         \u2013          <p>INCAR copilot mode. See <code>quacc.calculators.vasp.vasp.Vasp</code> for more info.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>The updated user-provided calculator parameters.</p> </li> </ul> Source code in <code>quacc/calculators/vasp/params.py</code> <pre><code>def get_param_swaps(\n    user_calc_params: dict[str, Any],\n    auto_kpts: dict[Literal[\"line_density\", \"kppvol\", \"kppa\"], float],\n    input_atoms: Atoms,\n    incar_copilot: Literal[\"off\", \"on\", \"aggressive\"],\n) -&gt; dict[str, Any]:\n    \"\"\"\n    Swaps out bad INCAR flags.\n\n    Parameters\n    ----------\n    user_calc_params\n        The user-provided calculator parameters.\n    auto_kpts\n        The auto_kpts kwarg.\n    input_atoms\n        The input atoms.\n    incar_copilot\n        INCAR copilot mode. See `quacc.calculators.vasp.vasp.Vasp` for more info.\n\n    Returns\n    -------\n    dict\n        The updated user-provided calculator parameters.\n    \"\"\"\n\n    is_metal = check_is_metal(input_atoms)\n    calc = Vasp_(**user_calc_params)\n    max_Z = input_atoms.get_atomic_numbers().max()\n\n    if (\n        not calc.int_params[\"lmaxmix\"] or calc.int_params[\"lmaxmix\"] &lt; 6\n    ) and max_Z &gt; 56:\n        logger.info(\"Copilot: Recommending LMAXMIX = 6 because you have f electrons.\")\n        calc.set(lmaxmix=6)\n    elif (\n        not calc.int_params[\"lmaxmix\"] or calc.int_params[\"lmaxmix\"] &lt; 4\n    ) and max_Z &gt; 20:\n        logger.info(\"Copilot: Recommending LMAXMIX = 4 because you have d electrons.\")\n        calc.set(lmaxmix=4)\n\n    if (\n        calc.bool_params[\"luse_vdw\"]\n        or calc.bool_params[\"lhfcalc\"]\n        or calc.bool_params[\"ldau\"]\n        or calc.dict_params[\"ldau_luj\"]\n        or calc.string_params[\"metagga\"]\n    ) and not calc.bool_params[\"lasph\"]:\n        logger.info(\n            \"Copilot: Recommending LASPH = True because you have a +U, vdW, meta-GGA, or hybrid calculation.\"\n        )\n        calc.set(lasph=True)\n\n    if calc.string_params[\"metagga\"] and (\n        not calc.string_params[\"algo\"] or calc.string_params[\"algo\"].lower() != \"all\"\n    ):\n        logger.info(\n            \"Copilot: Recommending ALGO = All because you have a meta-GGA calculation.\"\n        )\n        calc.set(algo=\"all\")\n\n    if calc.bool_params[\"lhfcalc\"] and (\n        not calc.string_params[\"algo\"]\n        or calc.string_params[\"algo\"].lower() not in [\"all\", \"damped\", \"normal\"]\n    ):\n        logger.info(\n            \"Copilot: Recommending ALGO = Normal because you have a hybrid calculation.\"\n        )\n        calc.set(algo=\"normal\")\n\n    if (\n        is_metal\n        and (calc.int_params[\"ismear\"] and calc.int_params[\"ismear\"] &lt; 0)\n        and (calc.int_params[\"nsw\"] and calc.int_params[\"nsw\"] &gt; 0)\n    ):\n        logger.info(\n            \"Copilot: You are relaxing a likely metal. Setting ISMEAR = 1 and SIGMA = 0.1.\"\n        )\n        calc.set(ismear=1, sigma=0.1)\n\n    if (\n        calc.int_params[\"ismear\"] != -5\n        and calc.int_params[\"nsw\"] in (None, 0)\n        and (\n            np.prod(calc.kpts) &gt;= 4\n            or (calc.float_params[\"kspacing\"] and calc.float_params[\"kspacing\"] &lt;= 0.5)\n        )\n    ):\n        logger.info(\n            \"Copilot: Recommending ISMEAR = -5 because you have a static calculation.\"\n        )\n        calc.set(ismear=-5)\n\n    if (\n        calc.int_params[\"ismear\"] == -5\n        and np.prod(calc.kpts) &lt; 4\n        and calc.float_params[\"kspacing\"] is None\n    ):\n        logger.info(\n            \"Copilot: Recommending ISMEAR = 0 because you don't have enough k-points for ISMEAR = -5.\"\n        )\n        calc.set(ismear=0)\n\n    if (\n        calc.float_params[\"kspacing\"]\n        and calc.float_params[\"kspacing\"] &gt; 0.5\n        and calc.int_params[\"ismear\"] == -5\n    ):\n        logger.info(\n            \"Copilot: KSPACING is likely too large for ISMEAR = -5. Setting ISMEAR = 0.\"\n        )\n        calc.set(ismear=0)\n\n    if auto_kpts and auto_kpts.get(\"line_density\") and calc.int_params[\"ismear\"] != 0:\n        logger.info(\n            \"Copilot: Recommending ISMEAR = 0 and SIGMA = 0.01 because you are doing a line mode calculation.\"\n        )\n        calc.set(ismear=0, sigma=0.01)\n\n    if calc.int_params[\"ismear\"] == 0 and (\n        not calc.float_params[\"sigma\"] or calc.float_params[\"sigma\"] &gt; 0.05\n    ):\n        logger.info(\n            \"Copilot: Recommending SIGMA = 0.05 because ISMEAR = 0 was requested with SIGMA &gt; 0.05.\"\n        )\n        calc.set(sigma=0.05)\n\n    if (\n        calc.int_params[\"nsw\"]\n        and calc.int_params[\"nsw\"] &gt; 0\n        and calc.bool_params[\"laechg\"]\n    ):\n        logger.info(\n            \"Copilot: Recommending LAECHG = False because you have NSW &gt; 0. LAECHG is not compatible with NSW &gt; 0.\"\n        )\n        calc.set(laechg=False)\n\n    if calc.int_params[\"ldauprint\"] in (None, 0) and (\n        calc.bool_params[\"ldau\"] or calc.dict_params[\"ldau_luj\"]\n    ):\n        logger.info(\"Copilot: Recommending LDAUPRINT = 1 because LDAU = True.\")\n        calc.set(ldauprint=1)\n\n    if calc.special_params[\"lreal\"] and len(input_atoms) &lt; 30:\n        logger.info(\n            \"Copilot: Recommending LREAL = False because you have a small system (&lt; 30 atoms/cell).\"\n        )\n        calc.set(lreal=False)\n\n    if not calc.int_params[\"lorbit\"] and (\n        calc.int_params[\"ispin\"] == 2\n        or np.any(input_atoms.get_initial_magnetic_moments() != 0)\n    ):\n        logger.info(\n            \"Copilot: Recommending LORBIT = 11 because you have a spin-polarized calculation.\"\n        )\n        calc.set(lorbit=11)\n\n    if (\n        (calc.int_params[\"ncore\"] and calc.int_params[\"ncore\"] &gt; 1)\n        or (calc.int_params[\"npar\"] and calc.int_params[\"npar\"] &gt; 1)\n    ) and (\n        calc.bool_params[\"lhfcalc\"] is True\n        or calc.bool_params[\"lrpa\"] is True\n        or calc.bool_params[\"lepsilon\"] is True\n        or calc.int_params[\"ibrion\"] in [5, 6, 7, 8]\n    ):\n        logger.info(\n            \"Copilot: Recommending NCORE = 1 because NCORE/NPAR is not compatible with this job type.\"\n        )\n        calc.set(ncore=1, npar=None)\n\n    if (\n        calc.int_params[\"kpar\"]\n        and calc.int_params[\"kpar\"] &gt; np.prod(calc.kpts)\n        and calc.float_params[\"kspacing\"] is None\n    ):\n        logger.info(\n            \"Copilot: Recommending KPAR = 1 because you have too few k-points to parallelize.\"\n        )\n        calc.set(kpar=1)\n\n    if calc.bool_params[\"lhfcalc\"] is True and calc.int_params[\"isym\"] in (1, 2):\n        logger.info(\n            \"Copilot: Recommending ISYM = 3 because you are running a hybrid calculation.\"\n        )\n        calc.set(isym=3)\n\n    if calc.bool_params[\"lsorbit\"]:\n        logger.info(\n            \"Copilot: Recommending ISYM = -1 because you are running an SOC calculation.\"\n        )\n        calc.set(isym=-1)\n\n    if (\n        (calc.int_params[\"ncore\"] and calc.int_params[\"ncore\"] &gt; 1)\n        or (calc.int_params[\"npar\"] and calc.int_params[\"npar\"] &gt; 1)\n    ) and (calc.bool_params[\"lelf\"] is True):\n        logger.info(\n            \"Copilot: Recommending NPAR = 1 because NCORE/NPAR is not compatible with this job type.\"\n        )\n        calc.set(npar=1, ncore=None)\n\n    if not calc.string_params[\"efermi\"]:\n        logger.info(\"Copilot: Recommending EFERMI = MIDGAP per the VASP manual.\")\n        calc.set(efermi=\"midgap\")\n\n    return (\n        calc.parameters\n        if incar_copilot == \"aggressive\"\n        else calc.parameters | user_calc_params\n        if incar_copilot == \"on\"\n        else user_calc_params\n    )\n</code></pre>"},{"location":"reference/quacc/calculators/vasp/params.html#quacc.calculators.vasp.params.remove_unused_flags","title":"remove_unused_flags","text":"<pre><code>remove_unused_flags(user_calc_params)\n</code></pre> <p>Removes unused flags in the INCAR, like EDIFFG if you are doing NSW = 0.</p> <p>Parameters:</p> <ul> <li> <code>user_calc_params</code>             (<code>dict[str, Any]</code>)         \u2013          <p>The updated user-provided calculator parameters.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>The updated user-provided calculator parameters.</p> </li> </ul> Source code in <code>quacc/calculators/vasp/params.py</code> <pre><code>def remove_unused_flags(user_calc_params: dict[str, Any]) -&gt; dict[str, Any]:\n    \"\"\"\n    Removes unused flags in the INCAR, like EDIFFG if you are doing NSW = 0.\n\n    Parameters\n    -------\n    user_calc_params\n        The updated user-provided calculator parameters.\n\n    Returns\n    -------\n    dict\n        The updated user-provided calculator parameters.\n    \"\"\"\n\n    if user_calc_params.get(\"nsw\", 0) == 0:\n        # Turn off opt flags if NSW = 0\n        opt_flags = (\"ediffg\", \"ibrion\", \"isif\", \"potim\", \"iopt\")\n        for opt_flag in opt_flags:\n            user_calc_params.pop(opt_flag, None)\n\n    if not user_calc_params.get(\"ldau\", False) and not user_calc_params.get(\"ldau_luj\"):\n        # Turn off +U flags if +U is not even used\n        ldau_flags = (\n            \"ldau\",\n            \"ldauu\",\n            \"ldauj\",\n            \"ldaul\",\n            \"ldautype\",\n            \"ldauprint\",\n            \"ldau_luj\",\n        )\n        for ldau_flag in ldau_flags:\n            user_calc_params.pop(ldau_flag, None)\n\n    # Remove None keys\n    none_keys = [k for k, v in user_calc_params.items() if v is None]\n    for none_key in none_keys:\n        del user_calc_params[none_key]\n\n    return user_calc_params\n</code></pre>"},{"location":"reference/quacc/calculators/vasp/params.html#quacc.calculators.vasp.params.set_auto_dipole","title":"set_auto_dipole","text":"<pre><code>set_auto_dipole(user_calc_params, input_atoms)\n</code></pre> <p>Sets flags related to the auto_dipole kwarg.</p> <p>Parameters:</p> <ul> <li> <code>user_calc_params</code>             (<code>dict[str, Any]</code>)         \u2013          <p>The user-provided calculator parameters.</p> </li> <li> <code>input_atoms</code>             (<code>Atoms</code>)         \u2013          <p>The input atoms.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>The updated user-provided calculator parameters.</p> </li> </ul> Source code in <code>quacc/calculators/vasp/params.py</code> <pre><code>def set_auto_dipole(\n    user_calc_params: dict[str, Any], input_atoms: Atoms\n) -&gt; dict[str, Any]:\n    \"\"\"\n    Sets flags related to the auto_dipole kwarg.\n\n    Parameters\n    ----------\n    user_calc_params\n        The user-provided calculator parameters.\n    input_atoms\n        The input atoms.\n\n    Returns\n    -------\n    dict\n        The updated user-provided calculator parameters.\n    \"\"\"\n\n    com = input_atoms.get_center_of_mass(scaled=True)\n    if \"dipol\" not in user_calc_params:\n        user_calc_params[\"dipol\"] = com\n    if \"idipol\" not in user_calc_params:\n        user_calc_params[\"idipol\"] = 3\n    if \"ldipol\" not in user_calc_params:\n        user_calc_params[\"ldipol\"] = True\n\n    return user_calc_params\n</code></pre>"},{"location":"reference/quacc/calculators/vasp/vasp.html","title":"vasp","text":"<p>A wrapper around ASE's Vasp calculator that makes it better suited for high-throughput DFT.</p>"},{"location":"reference/quacc/calculators/vasp/vasp.html#quacc.calculators.vasp.vasp.Vasp","title":"Vasp","text":"<pre><code>Vasp(\n    input_atoms,\n    preset=None,\n    use_custodian=None,\n    incar_copilot=None,\n    copy_magmoms=None,\n    preset_mag_default=None,\n    mag_cutoff=None,\n    elemental_magmoms=None,\n    auto_kpts=None,\n    auto_dipole=None,\n    **kwargs\n)\n</code></pre> <p>             Bases: <code>Vasp</code></p> <p>This is a wrapper around the ASE Vasp calculator that adjusts INCAR parameters on-the-fly, allows for ASE to run VASP via Custodian, and supports several automatic k-point generation schemes from Pymatgen.</p> <p>Parameters:</p> <ul> <li> <code>input_atoms</code>             (<code>Atoms</code>)         \u2013          <p>The input Atoms object to be used for the calculation.</p> </li> <li> <code>preset</code>             (<code>None | str</code>, default:                 <code>None</code> )         \u2013          <p>The name of a YAML file containing a list of INCAR parameters to use as a \"preset\" for the calculator. quacc will automatically look in the <code>VASP_PRESET_DIR</code> (default: quacc/calculators/vasp/presets) for the file, such that preset=\"BulkSet\" is supported, for instance. The .yaml extension is not necessary. Any user-supplied calculator **kwargs will override any corresponding preset values.</p> </li> <li> <code>use_custodian</code>             (<code>bool | None</code>, default:                 <code>None</code> )         \u2013          <p>Whether to use Custodian to run VASP. Default is True in settings.</p> </li> <li> <code>incar_copilot</code>             (<code>Literal['off', 'on', 'aggressive'] | None</code>, default:                 <code>None</code> )         \u2013          <p>Controls VASP co-pilot mode for automated INCAR parameter handling. Options include: off: Do not use co-pilot mode. INCAR parameters will be unmodified. on: Use co-pilot mode. This will only modify INCAR flags not already set by the user. aggressive: Use co-pilot mode in aggressive mode. This will modify INCAR flags even if they are already set by the user.</p> </li> <li> <code>copy_magmoms</code>             (<code>bool | None</code>, default:                 <code>None</code> )         \u2013          <p>If True, any pre-existing <code>atoms.get_magnetic_moments()</code> will be set in <code>atoms.set_initial_magnetic_moments()</code>. Set this to False if you want to use a preset's magnetic moments every time. Default is True in settings.</p> </li> <li> <code>preset_mag_default</code>             (<code>float | None</code>, default:                 <code>None</code> )         \u2013          <p>Default magmom value for sites without one explicitly specified in the preset. Only used if a preset is specified with an elemental_mags_dict key-value pair. Default is 1.0 in settings.</p> </li> <li> <code>mag_cutoff</code>             (<code>None | float</code>, default:                 <code>None</code> )         \u2013          <p>Set all initial magmoms to 0 if all have a magnitude below this value. Default is 0.05 in settings.</p> </li> <li> <code>elemental_magmoms</code>             (<code>dict[str, float] | None</code>, default:                 <code>None</code> )         \u2013          <p>A dictionary of elemental initial magnetic moments to pass to quacc.schemas.prep.set_magmoms, e.g. <code>{\"Fe\": 5, \"Ni\": 4}</code>.</p> </li> <li> <code>auto_kpts</code>             (<code>dict[Literal['line_density', 'kppvol', 'kppa'], float] | dict[Literal['length_densities'], list[float]] | None</code>, default:                 <code>None</code> )         \u2013          <p>An automatic k-point generation scheme from Pymatgen. Options include:</p> <ul> <li> <p>{\"line_density\": float}. This will call <code>pymatgen.symmetry.bandstructure.HighSymmKpath</code>     with <code>path_type=\"latimer_munro\"</code>. The <code>line_density</code> value will be     set in the <code>.get_kpoints</code> attribute.</p> </li> <li> <p>{\"kppvol\": float}. This will call <code>pymatgen.io.vasp.inputs.Kpoints.automatic_density_by_vol</code>     with the given value for <code>kppvol</code>.</p> </li> <li> <p>{\"kppa\": float}. This will call <code>pymatgen.io.vasp.inputs.Kpoints.automatic_density</code>     with the given value for <code>kppa</code>.</p> </li> <li> <p>{\"length_densities\": [float, float, float]}. This will call <code>pymatgen.io.vasp.inputs.Kpoints.automatic_density_by_lengths</code>     with the given value for <code>length_densities</code>.</p> </li> </ul> <p>If multiple options are specified, the most dense k-point scheme will be chosen.</p> </li> <li> <code>auto_dipole</code>             (<code>bool | None</code>, default:                 <code>None</code> )         \u2013          <p>If True, will automatically set dipole moment correction parameters based on the center of mass (in the c dimension by default).</p> </li> <li> <code>**kwargs</code>         \u2013          <p>Additional arguments to be passed to the VASP calculator, e.g. <code>xc='PBE'</code>, <code>encut=520</code>. Takes all valid ASE calculator arguments.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          </li> </ul> Source code in <code>quacc/calculators/vasp/vasp.py</code> <pre><code>def __init__(\n    self,\n    input_atoms: Atoms,\n    preset: None | str = None,\n    use_custodian: bool | None = None,\n    incar_copilot: Literal[\"off\", \"on\", \"aggressive\"] | None = None,\n    copy_magmoms: bool | None = None,\n    preset_mag_default: float | None = None,\n    mag_cutoff: None | float = None,\n    elemental_magmoms: dict[str, float] | None = None,\n    auto_kpts: dict[Literal[\"line_density\", \"kppvol\", \"kppa\"], float]\n    | dict[Literal[\"length_densities\"], list[float]]\n    | None = None,\n    auto_dipole: bool | None = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Initialize the VASP calculator.\n\n    Parameters\n    ----------\n    input_atoms\n        The input Atoms object to be used for the calculation.\n    preset\n        The name of a YAML file containing a list of INCAR parameters to use as\n        a \"preset\" for the calculator. quacc will automatically look in the\n        `VASP_PRESET_DIR` (default: quacc/calculators/vasp/presets) for the\n        file, such that preset=\"BulkSet\" is supported, for instance. The .yaml\n        extension is not necessary. Any user-supplied calculator **kwargs will\n        override any corresponding preset values.\n    use_custodian\n        Whether to use Custodian to run VASP. Default is True in settings.\n    incar_copilot\n        Controls VASP co-pilot mode for automated INCAR parameter handling.\n        Options include:\n        off: Do not use co-pilot mode. INCAR parameters will be unmodified.\n        on: Use co-pilot mode. This will only modify INCAR flags not already set by the user.\n        aggressive: Use co-pilot mode in aggressive mode. This will modify INCAR flags even if they are already set by the user.\n    copy_magmoms\n        If True, any pre-existing `atoms.get_magnetic_moments()` will be set in\n        `atoms.set_initial_magnetic_moments()`. Set this to False if you want to\n        use a preset's magnetic moments every time. Default is True in settings.\n    preset_mag_default\n        Default magmom value for sites without one explicitly specified in the\n        preset. Only used if a preset is specified with an elemental_mags_dict\n        key-value pair. Default is 1.0 in settings.\n    mag_cutoff\n        Set all initial magmoms to 0 if all have a magnitude below this value.\n        Default is 0.05 in settings.\n    elemental_magmoms\n        A dictionary of elemental initial magnetic moments to pass to\n        [quacc.schemas.prep.set_magmoms][], e.g. `{\"Fe\": 5, \"Ni\": 4}`.\n    auto_kpts\n        An automatic k-point generation scheme from Pymatgen. Options include:\n\n        - {\"line_density\": float}. This will call\n        `pymatgen.symmetry.bandstructure.HighSymmKpath`\n            with `path_type=\"latimer_munro\"`. The `line_density` value will be\n            set in the `.get_kpoints` attribute.\n\n        - {\"kppvol\": float}. This will call\n        `pymatgen.io.vasp.inputs.Kpoints.automatic_density_by_vol`\n            with the given value for `kppvol`.\n\n        - {\"kppa\": float}. This will call\n        `pymatgen.io.vasp.inputs.Kpoints.automatic_density`\n            with the given value for `kppa`.\n\n        - {\"length_densities\": [float, float, float]}. This will call\n        `pymatgen.io.vasp.inputs.Kpoints.automatic_density_by_lengths`\n            with the given value for `length_densities`.\n\n        If multiple options are specified, the most dense k-point scheme will be\n        chosen.\n    auto_dipole\n        If True, will automatically set dipole moment correction parameters\n        based on the center of mass (in the c dimension by default).\n    **kwargs\n        Additional arguments to be passed to the VASP calculator, e.g.\n        `xc='PBE'`, `encut=520`. Takes all valid ASE calculator arguments.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    from quacc import SETTINGS\n\n    # Set defaults\n    use_custodian = (\n        SETTINGS.VASP_USE_CUSTODIAN if use_custodian is None else use_custodian\n    )\n    incar_copilot = (\n        SETTINGS.VASP_INCAR_COPILOT if incar_copilot is None else incar_copilot\n    )\n    copy_magmoms = (\n        SETTINGS.VASP_COPY_MAGMOMS if copy_magmoms is None else copy_magmoms\n    )\n    preset_mag_default = (\n        SETTINGS.VASP_PRESET_MAG_DEFAULT\n        if preset_mag_default is None\n        else preset_mag_default\n    )\n    mag_cutoff = SETTINGS.VASP_MAG_CUTOFF if mag_cutoff is None else mag_cutoff\n\n    # Assign variables to self\n    self.input_atoms = input_atoms\n    self.preset = preset\n    self.use_custodian = use_custodian\n    self.incar_copilot = incar_copilot\n    self.copy_magmoms = copy_magmoms\n    self.preset_mag_default = preset_mag_default\n    self.mag_cutoff = mag_cutoff\n    self.elemental_magmoms = elemental_magmoms\n    self.auto_kpts = auto_kpts\n    self.auto_dipole = auto_dipole\n    self.kwargs = kwargs\n\n    # Initialize for later\n    self.user_calc_params = {}\n\n    # Cleanup parameters\n    self._cleanup_params()\n\n    # Get VASP executable command, if necessary, and specify child\n    # environment variables\n    command = self._manage_environment()\n\n    # Instantiate the calculator!\n    super().__init__(\n        atoms=self.input_atoms, command=command, **self.user_calc_params\n    )\n</code></pre>"},{"location":"reference/quacc/calculators/vasp/vasp_custodian.html","title":"vasp_custodian","text":"<p>Custodian handlers for VASP.</p>"},{"location":"reference/quacc/calculators/vasp/vasp_custodian.html#quacc.calculators.vasp.vasp_custodian.run_custodian","title":"run_custodian","text":"<pre><code>run_custodian(\n    vasp_parallel_cmd=None,\n    vasp_cmd=None,\n    vasp_gamma_cmd=None,\n    vasp_custodian_max_errors=None,\n    vasp_custodian_wall_time=None,\n    vtst_fixes=None,\n    vasp_custodian_handlers=None,\n    vasp_custodian_validators=None,\n    scratch_dir=None,\n    vasp_job_kwargs=None,\n    custodian_kwargs=None,\n)\n</code></pre> <p>Function to run VASP Custodian.</p> <p>Parameters:</p> <ul> <li> <code>vasp_parallel_cmd</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>VASP parallel command, e.g. \"srun -N 2 --ntasks-per-node=24\". Defaults to the $VASP_PARALLEL_CMD environment variable in settings.</p> </li> <li> <code>vasp_cmd</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>VASP command. Defaults to \"vasp_std\" in settings.</p> </li> <li> <code>vasp_gamma_cmd</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>VASP gamma command. Defaults to \"vasp_gam\" in settings.</p> </li> <li> <code>vasp_custodian_max_errors</code>             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>Maximum number of errors to allow before stopping the run. Defaults to 5 in settings.</p> </li> <li> <code>vasp_custodian_wall_time</code>             (<code>float | None</code>, default:                 <code>None</code> )         \u2013          <p>Maximum wall time to allow before creating a STOPCAR. Defaults to infinity in settings.</p> </li> <li> <code>vtst_fixes</code>             (<code>bool | None</code>, default:                 <code>None</code> )         \u2013          <p>Whether to apply VTST input swaps. Defaults to False in settings.</p> </li> <li> <code>vasp_custodian_handlers</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>List of handlers to use in Custodian. See settings for list.</p> </li> <li> <code>vasp_custodian_validators</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>List of validators to use in Custodian. See settings for list.</p> </li> <li> <code>scratch_dir</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>Scratch directory to use. Defaults to None.</p> </li> <li> <code>vasp_job_kwargs</code>             (<code>VaspJobKwargs | None</code>, default:                 <code>None</code> )         \u2013          <p>Keyword arguments to pass to the Custodian VaspJob. Defaults to None.</p> </li> <li> <code>custodian_kwargs</code>             (<code>CustodianKwargs | None</code>, default:                 <code>None</code> )         \u2013          <p>Any remaining keyword arguments to pass to Custodian. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          </li> </ul> Source code in <code>quacc/calculators/vasp/vasp_custodian.py</code> <pre><code>def run_custodian(\n    vasp_parallel_cmd: str | None = None,\n    vasp_cmd: str | None = None,\n    vasp_gamma_cmd: str | None = None,\n    vasp_custodian_max_errors: int | None = None,\n    vasp_custodian_wall_time: float | None = None,\n    vtst_fixes: bool | None = None,\n    vasp_custodian_handlers: list[str] | None = None,\n    vasp_custodian_validators: list[str] | None = None,\n    scratch_dir: str | None = None,\n    vasp_job_kwargs: VaspJobKwargs | None = None,\n    custodian_kwargs: CustodianKwargs | None = None,\n) -&gt; None:\n    \"\"\"\n    Function to run VASP Custodian.\n\n    Parameters\n    ----------\n    vasp_parallel_cmd\n        VASP parallel command, e.g. \"srun -N 2 --ntasks-per-node=24\". Defaults\n        to the $VASP_PARALLEL_CMD environment variable in settings.\n    vasp_cmd\n        VASP command. Defaults to \"vasp_std\" in settings.\n    vasp_gamma_cmd\n        VASP gamma command. Defaults to \"vasp_gam\" in settings.\n    vasp_custodian_max_errors\n        Maximum number of errors to allow before stopping the run. Defaults to 5\n        in settings.\n    vasp_custodian_wall_time\n        Maximum wall time to allow before creating a STOPCAR. Defaults to\n        infinity in settings.\n    vtst_fixes\n        Whether to apply VTST input swaps. Defaults to False in settings.\n    vasp_custodian_handlers\n        List of handlers to use in Custodian. See settings for list.\n    vasp_custodian_validators\n        List of validators to use in Custodian. See settings for list.\n    scratch_dir\n        Scratch directory to use. Defaults to None.\n    vasp_job_kwargs\n        Keyword arguments to pass to the Custodian VaspJob. Defaults to None.\n    custodian_kwargs\n        Any remaining keyword arguments to pass to Custodian. Defaults to None.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    # Adapted from atomate2.vasp.run.run_vasp\n\n    from quacc import SETTINGS\n\n    # Set defaults\n    vasp_parallel_cmd = os.path.expandvars(\n        SETTINGS.VASP_PARALLEL_CMD if vasp_parallel_cmd is None else vasp_parallel_cmd\n    )\n    vasp_cmd = SETTINGS.VASP_CMD if vasp_cmd is None else vasp_cmd\n    vasp_gamma_cmd = (\n        SETTINGS.VASP_GAMMA_CMD if vasp_gamma_cmd is None else vasp_gamma_cmd\n    )\n    vasp_custodian_max_errors = (\n        SETTINGS.VASP_CUSTODIAN_MAX_ERRORS\n        if vasp_custodian_max_errors is None\n        else vasp_custodian_max_errors\n    )\n    vasp_custodian_wall_time = (\n        SETTINGS.VASP_CUSTODIAN_WALL_TIME\n        if vasp_custodian_wall_time is None\n        else vasp_custodian_wall_time\n    )\n    vtst_fixes = SETTINGS.VASP_CUSTODIAN_VTST if vtst_fixes is None else vtst_fixes\n    vasp_custodian_handlers = (\n        SETTINGS.VASP_CUSTODIAN_HANDLERS\n        if vasp_custodian_handlers is None\n        else vasp_custodian_handlers\n    )\n    vasp_custodian_validators = (\n        SETTINGS.VASP_CUSTODIAN_VALIDATORS\n        if vasp_custodian_validators is None\n        else vasp_custodian_validators\n    )\n\n    # Handlers for VASP\n    handlers = []\n    handlers_dict = {\n        \"VaspErrorHandler\": VaspErrorHandler(vtst_fixes=vtst_fixes),\n        \"FrozenJobErrorHandler\": FrozenJobErrorHandler(),\n        \"IncorrectSmearingHandler\": IncorrectSmearingHandler(),\n        \"LargeSigmaHandler\": LargeSigmaHandler(),\n        \"MeshSymmetryErrorHandler\": MeshSymmetryErrorHandler(),\n        \"NonConvergingErrorHandler\": NonConvergingErrorHandler(),\n        \"PositiveEnergyErrorHandler\": PositiveEnergyErrorHandler(),\n        \"PotimErrorHandler\": PotimErrorHandler(),\n        \"StdErrHandler\": StdErrHandler(),\n        \"UnconvergedErrorHandler\": UnconvergedErrorHandler(),\n        \"WalltimeHandler\": WalltimeHandler(),\n        \"ScanMetalHandler\": ScanMetalHandler(),\n    }\n    validators_dict = {\n        \"VaspFilesValidator\": VaspFilesValidator(),\n        \"VasprunXMLValidator\": VasprunXMLValidator(),\n    }\n\n    handlers = []\n    for handler_flag in vasp_custodian_handlers:\n        if handler_flag not in handlers_dict:\n            msg = f\"Unknown VASP error handler: {handler_flag}\"\n            raise ValueError(msg)\n        handlers.append(handlers_dict[handler_flag])\n\n    validators = []\n    for validator_flag in vasp_custodian_validators:\n        if validator_flag not in validators_dict:\n            msg = f\"Unknown VASP validator: {validator_flag}\"\n            raise ValueError(msg)\n        validators.append(validators_dict[validator_flag])\n\n    # Populate settings\n    full_vasp_cmd = f\"{vasp_parallel_cmd} {vasp_cmd}\"\n    full_vasp_gamma_cmd = f\"{vasp_parallel_cmd} {vasp_gamma_cmd}\"\n\n    # Run VASP\n    vasp_job_kwargs = {} if vasp_job_kwargs is None else vasp_job_kwargs\n    custodian_kwargs = {} if custodian_kwargs is None else custodian_kwargs\n    split_vasp_cmd = shlex.split(full_vasp_cmd)\n    split_vasp_gamma_cmd = shlex.split(full_vasp_gamma_cmd)\n    vasp_job_kwargs[\"gamma_vasp_cmd\"] = split_vasp_gamma_cmd\n\n    # Run with Custodian\n    jobs = [VaspJob(split_vasp_cmd, **vasp_job_kwargs)]\n\n    if vasp_custodian_wall_time:\n        handlers = [\n            *list(handlers),\n            WalltimeHandler(wall_time=vasp_custodian_wall_time),\n        ]\n\n    c = Custodian(\n        handlers,\n        jobs,\n        validators=validators,\n        max_errors=vasp_custodian_max_errors,\n        scratch_dir=scratch_dir,\n        **custodian_kwargs,\n    )\n\n    c.run()\n</code></pre>"},{"location":"reference/quacc/recipes/common/defects.html","title":"defects","text":"<p>Common defect workflows</p>"},{"location":"reference/quacc/recipes/common/defects.html#quacc.recipes.common.defects.bulk_to_defects_subflow","title":"bulk_to_defects_subflow","text":"<pre><code>bulk_to_defects_subflow(\n    atoms,\n    relax_job,\n    static_job=None,\n    make_defects_fn=make_defects_from_bulk,\n)\n</code></pre> <p>Workflow consisting of:</p> <ol> <li> <p>Defect generation</p> </li> <li> <p>Defect relaxations</p> </li> <li> <p>Defect statics (optional)</p> </li> </ol> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>Atoms object for the structure.</p> </li> <li> <code>relax_job</code>             (<code>Job</code>)         \u2013          <p>The relaxation function.</p> </li> <li> <code>static_job</code>             (<code>Job | None</code>, default:                 <code>None</code> )         \u2013          <p>The static function.</p> </li> <li> <code>make_defects_fn</code>             (<code>Callable</code>, default:                 <code>make_defects_from_bulk</code> )         \u2013          <p>The function for generating defects.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[dict]</code>         \u2013          <p>List of dictionary of results</p> </li> </ul> Source code in <code>quacc/recipes/common/defects.py</code> <pre><code>@subflow\ndef bulk_to_defects_subflow(\n    atoms: Atoms,\n    relax_job: Job,\n    static_job: Job | None = None,\n    make_defects_fn: Callable = make_defects_from_bulk,\n) -&gt; list[dict]:\n    \"\"\"\n    Workflow consisting of:\n\n    1. Defect generation\n\n    2. Defect relaxations\n\n    3. Defect statics (optional)\n\n    Parameters\n    ----------\n    atoms\n        Atoms object for the structure.\n    relax_job\n        The relaxation function.\n    static_job\n        The static function.\n    make_defects_fn\n        The function for generating defects.\n\n    Returns\n    -------\n    list[dict]\n        List of dictionary of results\n    \"\"\"\n\n    defects = make_defects_fn(atoms)\n\n    results = []\n    for defect in defects:\n        result = relax_job(defect)\n\n        if static_job:\n            result = static_job(result[\"atoms\"])\n\n        results.append(result)\n\n    return results\n</code></pre>"},{"location":"reference/quacc/recipes/common/phonons.html","title":"phonons","text":"<p>Common workflows for phonons</p>"},{"location":"reference/quacc/recipes/common/phonons.html#quacc.recipes.common.phonons.phonon_flow","title":"phonon_flow","text":"<pre><code>phonon_flow(\n    atoms,\n    static_job,\n    supercell_matrix=((2, 0, 0), (0, 2, 0), (0, 0, 2)),\n    atom_disp=0.01,\n    t_step=10,\n    t_min=0,\n    t_max=1000,\n    phonopy_kwargs=None,\n    additional_fields=None,\n)\n</code></pre> <p>Calculate phonon properties.</p> <p>This module is adapted from <code>matcalc</code> (https://github.com/materialsvirtuallab/matcalc)</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>Atoms object with calculator attached.</p> </li> <li> <code>static_job</code>             (<code>Job</code>)         \u2013          <p>The static job to calculate the forces.</p> </li> <li> <code>supercell_matrix</code>             (<code>ArrayLike</code>, default:                 <code>((2, 0, 0), (0, 2, 0), (0, 0, 2))</code> )         \u2013          <p>Supercell matrix to use. Defaults to 2x2x2 supercell.</p> </li> <li> <code>atom_disp</code>             (<code>float</code>, default:                 <code>0.01</code> )         \u2013          <p>Atomic displacement (A).</p> </li> <li> <code>t_step</code>             (<code>float</code>, default:                 <code>10</code> )         \u2013          <p>Temperature step (K).</p> </li> <li> <code>t_min</code>             (<code>float</code>, default:                 <code>0</code> )         \u2013          <p>Min temperature (K).</p> </li> <li> <code>t_max</code>             (<code>float</code>, default:                 <code>1000</code> )         \u2013          <p>Max temperature (K).</p> </li> <li> <code>phonopy_kwargs</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional kwargs to pass to the Phonopy class.</p> </li> <li> <code>additional_fields</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional fields to store in the database.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>PhononSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.phonons.summarize_phonopy</p> </li> </ul> Source code in <code>quacc/recipes/common/phonons.py</code> <pre><code>@flow\n@requires(phonopy, \"Phonopy must be installed. Run `pip install quacc[phonons]`\")\ndef phonon_flow(\n    atoms: Atoms,\n    static_job: Job,\n    supercell_matrix: ArrayLike = ((2, 0, 0), (0, 2, 0), (0, 0, 2)),\n    atom_disp: float = 0.01,\n    t_step: float = 10,\n    t_min: float = 0,\n    t_max: float = 1000,\n    phonopy_kwargs: dict[str, Any] | None = None,\n    additional_fields: dict[str, Any] | None = None,\n) -&gt; PhononSchema:\n    \"\"\"\n    Calculate phonon properties.\n\n    This module is adapted from `matcalc` (https://github.com/materialsvirtuallab/matcalc)\n\n    Parameters\n    ----------\n    atoms\n        Atoms object with calculator attached.\n    static_job\n        The static job to calculate the forces.\n    supercell_matrix\n        Supercell matrix to use. Defaults to 2x2x2 supercell.\n    atom_disp\n        Atomic displacement (A).\n    t_step\n        Temperature step (K).\n    t_min\n        Min temperature (K).\n    t_max\n        Max temperature (K).\n    phonopy_kwargs\n        Additional kwargs to pass to the Phonopy class.\n    additional_fields\n        Additional fields to store in the database.\n\n    Returns\n    -------\n    PhononSchema\n        Dictionary of results from [quacc.schemas.phonons.summarize_phonopy][]\n    \"\"\"\n\n    @subflow\n    def _phonopy_forces_subflow(atoms: Atoms) -&gt; list[dict]:\n        phonon = atoms_to_phonopy(\n            atoms, supercell_matrix, atom_disp, phonopy_kwargs=phonopy_kwargs\n        )\n        supercells = [\n            phonopy_atoms_to_ase_atoms(s) for s in phonon.supercells_with_displacements\n        ]\n        return [\n            static_job(supercell) for supercell in supercells if supercell is not None\n        ]\n\n    @job\n    def _phonopy_thermo_job(\n        atoms: Atoms, force_job_results: list[dict]\n    ) -&gt; PhononSchema:\n        phonon = atoms_to_phonopy(atoms, supercell_matrix, atom_disp)\n        parameters = force_job_results[-1].get(\"parameters\")\n        forces = [output[\"results\"][\"forces\"] for output in force_job_results]\n        phonon.forces = forces\n        phonon.produce_force_constants()\n        phonon.run_mesh()\n        phonon.run_thermal_properties(t_step=t_step, t_max=t_max, t_min=t_min)\n\n        return summarize_phonopy(\n            phonon,\n            input_atoms=atoms,\n            parameters=parameters,\n            additional_fields=additional_fields,\n        )\n\n    force_job_results = _phonopy_forces_subflow(atoms)\n    return _phonopy_thermo_job(atoms, force_job_results)\n</code></pre>"},{"location":"reference/quacc/recipes/common/slabs.html","title":"slabs","text":"<p>Common slab workflows</p>"},{"location":"reference/quacc/recipes/common/slabs.html#quacc.recipes.common.slabs.bulk_to_slabs_subflow","title":"bulk_to_slabs_subflow","text":"<pre><code>bulk_to_slabs_subflow(\n    atoms,\n    relax_job,\n    static_job=None,\n    make_slabs_fn=make_slabs_from_bulk,\n)\n</code></pre> <p>Workflow consisting of:</p> <ol> <li> <p>Slab generation</p> </li> <li> <p>Slab relaxations</p> </li> <li> <p>Slab statics (optional)</p> </li> </ol> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>Atoms object</p> </li> <li> <code>relax_job</code>             (<code>Job</code>)         \u2013          <p>The relaxation function.</p> </li> <li> <code>static_job</code>             (<code>Job | None</code>, default:                 <code>None</code> )         \u2013          <p>The static function.</p> </li> <li> <code>make_slabs_fn</code>             (<code>Callable</code>, default:                 <code>make_slabs_from_bulk</code> )         \u2013          <p>The function for generating slabs.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[dict]</code>         \u2013          <p>List of schemas.</p> </li> </ul> Source code in <code>quacc/recipes/common/slabs.py</code> <pre><code>@subflow\ndef bulk_to_slabs_subflow(\n    atoms: Atoms,\n    relax_job: Job,\n    static_job: Job | None = None,\n    make_slabs_fn: Callable = make_slabs_from_bulk,\n) -&gt; list[dict]:\n    \"\"\"\n    Workflow consisting of:\n\n    1. Slab generation\n\n    2. Slab relaxations\n\n    3. Slab statics (optional)\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    relax_job\n        The relaxation function.\n    static_job\n        The static function.\n    make_slabs_fn\n        The function for generating slabs.\n\n    Returns\n    -------\n    list[dict]\n        List of schemas.\n    \"\"\"\n\n    slabs = make_slabs_fn(atoms)\n\n    results = []\n    for slab in slabs:\n        result = relax_job(slab)\n\n        if static_job:\n            result = static_job(result[\"atoms\"])\n\n        results.append(result)\n\n    return results\n</code></pre>"},{"location":"reference/quacc/recipes/common/slabs.html#quacc.recipes.common.slabs.slab_to_ads_subflow","title":"slab_to_ads_subflow","text":"<pre><code>slab_to_ads_subflow(\n    atoms,\n    adsorbate,\n    relax_job,\n    static_job,\n    make_ads_fn=make_adsorbate_structures,\n)\n</code></pre> <p>Workflow consisting of:</p> <ol> <li> <p>Slab-adsorbate generation</p> </li> <li> <p>Slab-adsorbate relaxations</p> </li> <li> <p>Slab-adsorbate statics (optional)</p> </li> </ol> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>Atoms object for the slab structure.</p> </li> <li> <code>adsorbate</code>             (<code>Atoms</code>)         \u2013          <p>Atoms object for the adsorbate.</p> </li> <li> <code>relax_job</code>             (<code>Job</code>)         \u2013          <p>The slab releaxation job.</p> </li> <li> <code>static_job</code>             (<code>Job | None</code>)         \u2013          <p>The slab static job.</p> </li> <li> <code>make_ads_fn</code>             (<code>Callable</code>, default:                 <code>make_adsorbate_structures</code> )         \u2013          <p>The function to generate slab-adsorbate structures.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[dict]</code>         \u2013          <p>List of schemas.</p> </li> </ul> Source code in <code>quacc/recipes/common/slabs.py</code> <pre><code>@subflow\ndef slab_to_ads_subflow(\n    atoms: Atoms,\n    adsorbate: Atoms,\n    relax_job: Job,\n    static_job: Job | None,\n    make_ads_fn: Callable = make_adsorbate_structures,\n) -&gt; list[dict]:\n    \"\"\"\n    Workflow consisting of:\n\n    1. Slab-adsorbate generation\n\n    2. Slab-adsorbate relaxations\n\n    3. Slab-adsorbate statics (optional)\n\n    Parameters\n    ----------\n    atoms\n        Atoms object for the slab structure.\n    adsorbate\n        Atoms object for the adsorbate.\n    relax_job\n        The slab releaxation job.\n    static_job\n        The slab static job.\n    make_ads_fn\n        The function to generate slab-adsorbate structures.\n\n    Returns\n    -------\n    list[dict]\n        List of schemas.\n    \"\"\"\n\n    slabs = make_ads_fn(atoms, adsorbate)\n\n    results = []\n    for slab in slabs:\n        result = relax_job(slab)\n\n        if static_job:\n            result = static_job(result[\"atoms\"])\n\n        results.append(result)\n\n    return results\n</code></pre>"},{"location":"reference/quacc/recipes/dftb/_base.html","title":"_base","text":"<p>Base jobs for DFTB+</p>"},{"location":"reference/quacc/recipes/dftb/_base.html#quacc.recipes.dftb._base.base_fn","title":"base_fn","text":"<pre><code>base_fn(\n    atoms,\n    calc_defaults=None,\n    calc_swaps=None,\n    additional_fields=None,\n    copy_files=None,\n)\n</code></pre> <p>Base job function for DFTB+ recipes.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>Atoms object</p> </li> <li> <code>calc_defaults</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>The default calculator parameters to use.</p> </li> <li> <code>calc_swaps</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom kwargs for the calculator that would override the calculator defaults. Set a value to <code>None</code> to remove a pre-existing key entirely. For a list of available keys, refer to the <code>ase.calculators.dftb.Dftb</code> calculator.</p> </li> <li> <code>additional_fields</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Any additional fields to supply to the summarizer.</p> </li> <li> <code>copy_files</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>         \u2013          <p>Dictionary of results, specified in quacc.schemas.ase.summarize_run</p> </li> </ul> Source code in <code>quacc/recipes/dftb/_base.py</code> <pre><code>def base_fn(\n    atoms: Atoms,\n    calc_defaults: dict[str, Any] | None = None,\n    calc_swaps: dict[str, Any] | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    copy_files: list[str] | None = None,\n) -&gt; RunSchema:\n    \"\"\"\n    Base job function for DFTB+ recipes.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    calc_defaults\n        The default calculator parameters to use.\n    calc_swaps\n        Dictionary of custom kwargs for the calculator that would override the\n        calculator defaults. Set a value to `None` to remove a pre-existing key\n        entirely. For a list of available keys, refer to the\n        `ase.calculators.dftb.Dftb` calculator.\n    additional_fields\n        Any additional fields to supply to the summarizer.\n    copy_files\n        Files to copy to the runtime directory.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results, specified in [quacc.schemas.ase.summarize_run][]\n    \"\"\"\n\n    calc_flags = merge_dicts(calc_defaults, calc_swaps)\n\n    atoms.calc = Dftb(**calc_flags)\n    final_atoms = run_calc(atoms, geom_file=GEOM_FILE, copy_files=copy_files)\n\n    if SETTINGS.CHECK_CONVERGENCE:\n        if check_logfile(LOG_FILE, \"SCC is NOT converged\"):\n            msg = f\"SCC is not converged in {LOG_FILE}\"\n            raise RuntimeError(msg)\n        if calc_flags.get(\"Driver_\") == \"GeometryOptimization\" and not check_logfile(\n            LOG_FILE, \"Geometry converged\"\n        ):\n            msg = f\"Geometry optimization did not complete in {LOG_FILE}\"\n            raise RuntimeError(msg)\n\n    return summarize_run(\n        final_atoms, input_atoms=atoms, additional_fields=additional_fields\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/dftb/core.html","title":"core","text":"<p>Core recipes for DFTB+</p>"},{"location":"reference/quacc/recipes/dftb/core.html#quacc.recipes.dftb.core.relax_job","title":"relax_job","text":"<pre><code>relax_job(\n    atoms,\n    method=\"GFN2-xTB\",\n    kpts=None,\n    relax_cell=False,\n    **calc_kwargs\n)\n</code></pre> <p>Carry out a structure relaxation.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>Atoms object</p> </li> <li> <code>method</code>             (<code>Literal['GFN1-xTB', 'GFN2-xTB', 'DFTB']</code>, default:                 <code>'GFN2-xTB'</code> )         \u2013          <p>Method to use.</p> </li> <li> <code>kpts</code>             (<code>tuple | list[tuple] | dict | None</code>, default:                 <code>None</code> )         \u2013          <p>k-point grid to use.</p> </li> <li> <code>relax_cell</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to relax the unit cell shape/volume in addition to the positions.</p> </li> <li> <code>**calc_kwargs</code>         \u2013          <p>Custom kwargs for the calculator that would override the calculator defaults. Set a value to <code>None</code> to remove a pre-existing key entirely. For a list of available keys, refer to the <code>ase.calculators.dftb.Dftb</code> calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>         \u2013          <p>Dictionary of results, specified in quacc.schemas.ase.summarize_run</p> </li> </ul> Source code in <code>quacc/recipes/dftb/core.py</code> <pre><code>@job\ndef relax_job(\n    atoms: Atoms,\n    method: Literal[\"GFN1-xTB\", \"GFN2-xTB\", \"DFTB\"] = \"GFN2-xTB\",\n    kpts: tuple | list[tuple] | dict | None = None,\n    relax_cell: bool = False,\n    **calc_kwargs,\n) -&gt; RunSchema:\n    \"\"\"\n    Carry out a structure relaxation.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    method\n        Method to use.\n    kpts\n        k-point grid to use.\n    relax_cell\n        Whether to relax the unit cell shape/volume in addition to the\n        positions.\n    **calc_kwargs\n        Custom kwargs for the calculator that would override the\n        calculator defaults. Set a value to `None` to remove a pre-existing key\n        entirely. For a list of available keys, refer to the\n        `ase.calculators.dftb.Dftb` calculator.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results, specified in [quacc.schemas.ase.summarize_run][]\n    \"\"\"\n\n    calc_defaults = {\n        \"Driver_\": \"GeometryOptimization\",\n        \"Driver_AppendGeometries\": \"Yes\",\n        \"Driver_LatticeOpt\": \"Yes\" if relax_cell else \"No\",\n        \"Driver_MaxSteps\": 2000,\n        \"Hamiltonian_\": \"xTB\" if \"xtb\" in method.lower() else \"DFTB\",\n        \"Hamiltonian_MaxSccIterations\": 200,\n        \"Hamiltonian_Method\": method if \"xtb\" in method.lower() else None,\n        \"kpts\": kpts or ((1, 1, 1) if atoms.pbc.any() else None),\n    }\n\n    return base_fn(\n        atoms,\n        calc_defaults=calc_defaults,\n        calc_swaps=calc_kwargs,\n        additional_fields={\"name\": \"DFTB+ Relax\"},\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/dftb/core.html#quacc.recipes.dftb.core.static_job","title":"static_job","text":"<pre><code>static_job(\n    atoms, method=\"GFN2-xTB\", kpts=None, **calc_kwargs\n)\n</code></pre> <p>Carry out a single-point calculation.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>Atoms object</p> </li> <li> <code>method</code>             (<code>Literal['GFN1-xTB', 'GFN2-xTB', 'DFTB']</code>, default:                 <code>'GFN2-xTB'</code> )         \u2013          <p>Method to use.</p> </li> <li> <code>kpts</code>             (<code>tuple | list[tuple] | dict | None</code>, default:                 <code>None</code> )         \u2013          <p>k-point grid to use.</p> </li> <li> <code>**calc_kwargs</code>         \u2013          <p>Custom kwargs for the calculator that would override the calculator defaults. Set a value to <code>None</code> to remove a pre-existing key entirely. For a list of available keys, refer to the <code>ase.calculators.dftb.Dftb</code> calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>         \u2013          <p>Dictionary of results, specified in quacc.schemas.ase.summarize_run</p> </li> </ul> Source code in <code>quacc/recipes/dftb/core.py</code> <pre><code>@job\ndef static_job(\n    atoms: Atoms,\n    method: Literal[\"GFN1-xTB\", \"GFN2-xTB\", \"DFTB\"] = \"GFN2-xTB\",\n    kpts: tuple | list[tuple] | dict | None = None,\n    **calc_kwargs,\n) -&gt; RunSchema:\n    \"\"\"\n    Carry out a single-point calculation.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    method\n        Method to use.\n    kpts\n        k-point grid to use.\n    **calc_kwargs\n        Custom kwargs for the calculator that would override the\n        calculator defaults. Set a value to `None` to remove a pre-existing key\n        entirely. For a list of available keys, refer to the\n        `ase.calculators.dftb.Dftb` calculator.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results, specified in [quacc.schemas.ase.summarize_run][]\n    \"\"\"\n\n    calc_defaults = {\n        \"Hamiltonian_\": \"xTB\" if \"xtb\" in method.lower() else \"DFTB\",\n        \"Hamiltonian_MaxSccIterations\": 200,\n        \"Hamiltonian_Method\": method if \"xtb\" in method.lower() else None,\n        \"kpts\": kpts or ((1, 1, 1) if atoms.pbc.any() else None),\n    }\n\n    return base_fn(\n        atoms,\n        calc_defaults=calc_defaults,\n        calc_swaps=calc_kwargs,\n        additional_fields={\"name\": \"DFTB+ Static\"},\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/emt/core.html","title":"core","text":"<p>Core recipes for EMT.</p> <p>NOTE: This set of minimal recipes is mainly for demonstration purposes.</p>"},{"location":"reference/quacc/recipes/emt/core.html#quacc.recipes.emt.core.relax_job","title":"relax_job","text":"<pre><code>relax_job(\n    atoms, relax_cell=False, opt_params=None, **calc_kwargs\n)\n</code></pre> <p>Carry out a geometry optimization.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>Atoms object</p> </li> <li> <code>relax_cell</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to relax the cell</p> </li> <li> <code>opt_params</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom kwargs for the optimization process. Set a value to <code>None</code> to remove a pre-existing key entirely. For a list of available keys, refer to quacc.runners.ase.run_opt.</p> </li> <li> <code>**calc_kwargs</code>         \u2013          <p>Custom kwargs for the EMT calculator. Set a value to <code>None</code> to remove a pre-existing key entirely. For a list of available keys, refer to the <code>ase.calculators.emt.EMT</code> calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OptSchema</code>         \u2013          <p>Dictionary of results, specified in quacc.schemas.ase.summarize_opt_run</p> </li> </ul> Source code in <code>quacc/recipes/emt/core.py</code> <pre><code>@job\ndef relax_job(\n    atoms: Atoms,\n    relax_cell: bool = False,\n    opt_params: dict[str, Any] | None = None,\n    **calc_kwargs,\n) -&gt; OptSchema:\n    \"\"\"\n    Carry out a geometry optimization.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    relax_cell\n        Whether to relax the cell\n    opt_params\n        Dictionary of custom kwargs for the optimization process. Set a value\n        to `None` to remove a pre-existing key entirely. For a list of available\n        keys, refer to [quacc.runners.ase.run_opt][].\n    **calc_kwargs\n        Custom kwargs for the EMT calculator. Set a value to\n        `None` to remove a pre-existing key entirely. For a list of available\n        keys, refer to the `ase.calculators.emt.EMT` calculator.\n\n    Returns\n    -------\n    OptSchema\n        Dictionary of results, specified in\n        [quacc.schemas.ase.summarize_opt_run][]\n    \"\"\"\n    opt_defaults = {\"fmax\": 0.01, \"max_steps\": 1000, \"optimizer\": FIRE}\n    opt_flags = merge_dicts(opt_defaults, opt_params)\n\n    atoms.calc = EMT(**calc_kwargs)\n\n    dyn = run_opt(atoms, relax_cell=relax_cell, **opt_flags)\n\n    return summarize_opt_run(dyn, additional_fields={\"name\": \"EMT Relax\"})\n</code></pre>"},{"location":"reference/quacc/recipes/emt/core.html#quacc.recipes.emt.core.static_job","title":"static_job","text":"<pre><code>static_job(atoms, **calc_kwargs)\n</code></pre> <p>Carry out a static calculation.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>Atoms object</p> </li> <li> <code>**calc_kwargs</code>         \u2013          <p>Custom kwargs for the EMT calculator. Set a value to <code>None</code> to remove a pre-existing key entirely. For a list of available keys, refer to the <code>ase.calculators.emt.EMT</code> calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>         \u2013          <p>Dictionary of results, specified in quacc.schemas.ase.summarize_run</p> </li> </ul> Source code in <code>quacc/recipes/emt/core.py</code> <pre><code>@job\ndef static_job(atoms: Atoms, **calc_kwargs) -&gt; RunSchema:\n    \"\"\"\n    Carry out a static calculation.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    **calc_kwargs\n        Custom kwargs for the EMT calculator. Set a value to\n        `None` to remove a pre-existing key entirely. For a list of available\n        keys, refer to the `ase.calculators.emt.EMT` calculator.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results, specified in [quacc.schemas.ase.summarize_run][]\n    \"\"\"\n    atoms.calc = EMT(**calc_kwargs)\n    final_atoms = run_calc(atoms)\n\n    return summarize_run(\n        final_atoms, input_atoms=atoms, additional_fields={\"name\": \"EMT Static\"}\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/emt/defects.html","title":"defects","text":"<p>Defect recipes for EMT.</p>"},{"location":"reference/quacc/recipes/emt/defects.html#quacc.recipes.emt.defects.bulk_to_defects_flow","title":"bulk_to_defects_flow","text":"<pre><code>bulk_to_defects_flow(\n    atoms,\n    defect_gen=VacancyGenerator,\n    defect_charge=0,\n    make_defects_kwargs=None,\n    run_static=True,\n    defect_relax_kwargs=None,\n    defect_static_kwargs=None,\n)\n</code></pre> <p>Workflow consisting of:</p> <ol> <li> <p>Defect generation</p> </li> <li> <p>Defect relaxations</p> </li> <li> <p>Defect statics (optional)</p> </li> </ol> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>Atoms object for the structure.</p> </li> <li> <code>defect_gen</code>             (<code>AntiSiteGenerator | ChargeInterstitialGenerator | InterstitialGenerator | SubstitutionGenerator | VacancyGenerator | VoronoiInterstitialGenerator</code>, default:                 <code>VacancyGenerator</code> )         \u2013          <p>Defect generator</p> </li> <li> <code>defect_charge</code>             (<code>int</code>, default:                 <code>0</code> )         \u2013          <p>Charge state of the defect</p> </li> <li> <code>make_defects_kwargs</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Keyword arguments to pass to quacc.atoms.defects.make_defects_from_bulk</p> </li> <li> <code>run_static</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to run the static calculation.</p> </li> <li> <code>defect_relax_kwargs</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional keyword arguments to pass to quacc.recipes.emt.core.relax_job.</p> </li> <li> <code>defect_static_kwargs</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional keyword arguments to pass to quacc.recipes.emt.core.static_job.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[RunSchema | OptSchema]</code>         \u2013          <p>List of dictionary of results from quacc.schemas.ase.summarize_run or quacc.schemas.ase.summarize_opt_run</p> </li> </ul> Source code in <code>quacc/recipes/emt/defects.py</code> <pre><code>@flow\ndef bulk_to_defects_flow(\n    atoms: Atoms,\n    defect_gen: (\n        AntiSiteGenerator\n        | ChargeInterstitialGenerator\n        | InterstitialGenerator\n        | SubstitutionGenerator\n        | VacancyGenerator\n        | VoronoiInterstitialGenerator\n    ) = VacancyGenerator,\n    defect_charge: int = 0,\n    make_defects_kwargs: dict[str, Any] | None = None,\n    run_static: bool = True,\n    defect_relax_kwargs: dict[str, Any] | None = None,\n    defect_static_kwargs: dict[str, Any] | None = None,\n) -&gt; list[RunSchema | OptSchema]:\n    \"\"\"\n    Workflow consisting of:\n\n    1. Defect generation\n\n    2. Defect relaxations\n\n    3. Defect statics (optional)\n\n    Parameters\n    ----------\n    atoms\n        Atoms object for the structure.\n    defect_gen\n        Defect generator\n    defect_charge\n        Charge state of the defect\n    make_defects_kwargs\n        Keyword arguments to pass to\n        [quacc.atoms.defects.make_defects_from_bulk][]\n    run_static\n        Whether to run the static calculation.\n    defect_relax_kwargs\n        Additional keyword arguments to pass to [quacc.recipes.emt.core.relax_job][].\n    defect_static_kwargs\n        Additional keyword arguments to pass to [quacc.recipes.emt.core.static_job][].\n\n    Returns\n    -------\n    list[RunSchema | OptSchema]\n        List of dictionary of results from [quacc.schemas.ase.summarize_run][]\n        or [quacc.schemas.ase.summarize_opt_run][]\n    \"\"\"\n    make_defects_kwargs = make_defects_kwargs or {}\n    defect_relax_kwargs = defect_relax_kwargs or {}\n    defect_static_kwargs = defect_static_kwargs or {}\n\n    return bulk_to_defects_subflow(\n        atoms,\n        partial(relax_job, **defect_relax_kwargs),\n        static_job=partial(static_job, **defect_static_kwargs) if run_static else None,\n        make_defects_fn=partial(\n            make_defects_from_bulk,\n            defect_gen=defect_gen,\n            defect_charge=defect_charge,\n            **make_defects_kwargs,\n        ),\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/emt/phonons.html","title":"phonons","text":"<p>Phonon recipes for EMT</p>"},{"location":"reference/quacc/recipes/emt/phonons.html#quacc.recipes.emt.phonons.phonon_flow","title":"phonon_flow","text":"<pre><code>phonon_flow(\n    atoms,\n    supercell_matrix=((2, 0, 0), (0, 2, 0), (0, 0, 2)),\n    atom_disp=0.01,\n    symprec=1e-05,\n    t_step=10,\n    t_min=0,\n    t_max=1000,\n    static_job_kwargs=None,\n)\n</code></pre> <p>Carry out a phonon calculation.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>Atoms object</p> </li> <li> <code>supercell_matrix</code>             (<code>ArrayLike</code>, default:                 <code>((2, 0, 0), (0, 2, 0), (0, 0, 2))</code> )         \u2013          <p>Supercell matrix to use. Defaults to 2x2x2 supercell.</p> </li> <li> <code>atom_disp</code>             (<code>float</code>, default:                 <code>0.01</code> )         \u2013          <p>Atomic displacement (A).</p> </li> <li> <code>symprec</code>             (<code>float</code>, default:                 <code>1e-05</code> )         \u2013          <p>Precision for symmetry detection.</p> </li> <li> <code>t_step</code>             (<code>float</code>, default:                 <code>10</code> )         \u2013          <p>Temperature step (K).</p> </li> <li> <code>t_min</code>             (<code>float</code>, default:                 <code>0</code> )         \u2013          <p>Min temperature (K).</p> </li> <li> <code>t_max</code>             (<code>float</code>, default:                 <code>1000</code> )         \u2013          <p>Max temperature (K).</p> </li> <li> <code>static_job_kwargs</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional keyword arguments for quacc.recipes.emt.core.static_job for the force calculations.</p> </li> <li> <code>phonopy_kwargs</code>         \u2013          <p>Additional keyword arguments for the <code>phonopy.Phonopy</code> class.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>PhononSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.phonons.summarize_phonopy</p> </li> </ul> Source code in <code>quacc/recipes/emt/phonons.py</code> <pre><code>@flow\ndef phonon_flow(\n    atoms: Atoms,\n    supercell_matrix: ArrayLike = ((2, 0, 0), (0, 2, 0), (0, 0, 2)),\n    atom_disp: float = 0.01,\n    symprec: float = 1e-5,\n    t_step: float = 10,\n    t_min: float = 0,\n    t_max: float = 1000,\n    static_job_kwargs: dict[str, Any] | None = None,\n) -&gt; PhononSchema:\n    \"\"\"\n    Carry out a phonon calculation.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    supercell_matrix\n        Supercell matrix to use. Defaults to 2x2x2 supercell.\n    atom_disp\n        Atomic displacement (A).\n    symprec\n        Precision for symmetry detection.\n    t_step\n        Temperature step (K).\n    t_min\n        Min temperature (K).\n    t_max\n        Max temperature (K).\n    static_job_kwargs\n        Additional keyword arguments for [quacc.recipes.emt.core.static_job][]\n        for the force calculations.\n    phonopy_kwargs\n        Additional keyword arguments for the `phonopy.Phonopy` class.\n\n    Returns\n    -------\n    PhononSchema\n        Dictionary of results from [quacc.schemas.phonons.summarize_phonopy][]\n    \"\"\"\n    static_job_kwargs = static_job_kwargs or {}\n\n    return phonon_flow_(\n        atoms,\n        partial(static_job, **static_job_kwargs),\n        supercell_matrix=supercell_matrix,\n        atom_disp=atom_disp,\n        t_step=t_step,\n        t_min=t_min,\n        t_max=t_max,\n        phonopy_kwargs={\"symprec\": symprec},\n        additional_fields={\"name\": \"EMT Phonons\"},\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/emt/slabs.html","title":"slabs","text":"<p>Slab recipes for EMT.</p>"},{"location":"reference/quacc/recipes/emt/slabs.html#quacc.recipes.emt.slabs.bulk_to_slabs_flow","title":"bulk_to_slabs_flow","text":"<pre><code>bulk_to_slabs_flow(\n    atoms,\n    make_slabs_kwargs=None,\n    run_static=True,\n    slab_relax_kwargs=None,\n    slab_static_kwargs=None,\n)\n</code></pre> <p>Workflow consisting of:</p> <ol> <li> <p>Slab generation</p> </li> <li> <p>Slab relaxations</p> </li> <li> <p>Slab statics (optional)</p> </li> </ol> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>Atoms object</p> </li> <li> <code>make_slabs_kwargs</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional keyword arguments to pass to quacc.atoms.slabs.make_slabs_from_bulk</p> </li> <li> <code>run_static</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to run the static calculation.</p> </li> <li> <code>slab_relax_kwargs</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional keyword arguments to pass to quacc.recipes.emt.core.relax_job.</p> </li> <li> <code>slab_static_kwargs</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional keyword arguments to pass to quacc.recipes.emt.core.static_job.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[RunSchema | OptSchema]</code>         \u2013          <p>RunSchema or OptSchema for each slab.</p> </li> </ul> Source code in <code>quacc/recipes/emt/slabs.py</code> <pre><code>@flow\ndef bulk_to_slabs_flow(\n    atoms: Atoms,\n    make_slabs_kwargs: dict[str, Any] | None = None,\n    run_static: bool = True,\n    slab_relax_kwargs: dict[str, Any] | None = None,\n    slab_static_kwargs: dict[str, Any] | None = None,\n) -&gt; list[RunSchema | OptSchema]:\n    \"\"\"\n    Workflow consisting of:\n\n    1. Slab generation\n\n    2. Slab relaxations\n\n    3. Slab statics (optional)\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    make_slabs_kwargs\n        Additional keyword arguments to pass to\n        [quacc.atoms.slabs.make_slabs_from_bulk][]\n    run_static\n        Whether to run the static calculation.\n    slab_relax_kwargs\n        Additional keyword arguments to pass to [quacc.recipes.emt.core.relax_job][].\n    slab_static_kwargs\n        Additional keyword arguments to pass to [quacc.recipes.emt.core.static_job][].\n\n    Returns\n    -------\n    list[RunSchema | OptSchema]\n        [RunSchema][quacc.schemas.ase.summarize_run] or\n        [OptSchema][quacc.schemas.ase.summarize_opt_run] for each slab.\n    \"\"\"\n\n    make_slabs_kwargs = make_slabs_kwargs or {}\n    slab_relax_kwargs = slab_relax_kwargs or {}\n    slab_static_kwargs = slab_static_kwargs or {}\n\n    return bulk_to_slabs_subflow(\n        atoms,\n        partial(relax_job, **slab_relax_kwargs),\n        static_job=partial(static_job, **slab_static_kwargs) if run_static else None,\n        make_slabs_fn=partial(make_slabs_from_bulk, **make_slabs_kwargs),\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/gaussian/_base.html","title":"_base","text":"<p>Base jobs for Gaussian</p>"},{"location":"reference/quacc/recipes/gaussian/_base.html#quacc.recipes.gaussian._base.base_fn","title":"base_fn","text":"<pre><code>base_fn(\n    atoms,\n    calc_defaults=None,\n    calc_swaps=None,\n    additional_fields=None,\n    copy_files=None,\n)\n</code></pre> <p>Base job function for carrying out Gaussian recipes.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>Atoms object</p> </li> <li> <code>calc_defaults</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Default parameters for the calculator.</p> </li> <li> <code>calc_swaps</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom kwargs for the Gaussian calculator. Set a value to <code>None</code> to remove a pre-existing key entirely. For a list of available keys, refer to the <code>ase.calculators.gaussian.Gaussian</code> calculator.</p> </li> <li> <code>additional_fields</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional fields to supply to the summarizer.</p> </li> <li> <code>copy_files</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>cclibSchema</code>         \u2013          <p>Dictionary of results, as specified in quacc.schemas.cclib.cclib_summarize_run</p> </li> </ul> Source code in <code>quacc/recipes/gaussian/_base.py</code> <pre><code>def base_fn(\n    atoms: Atoms,\n    calc_defaults: dict[str, Any] | None = None,\n    calc_swaps: dict[str, Any] | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    copy_files: list[str] | None = None,\n) -&gt; cclibSchema:\n    \"\"\"\n    Base job function for carrying out Gaussian recipes.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    calc_defaults\n        Default parameters for the calculator.\n    calc_swaps\n        Dictionary of custom kwargs for the Gaussian calculator. Set a value to\n        `None` to remove a pre-existing key entirely. For a list of available\n        keys, refer to the `ase.calculators.gaussian.Gaussian` calculator.\n    additional_fields\n        Additional fields to supply to the summarizer.\n    copy_files\n        Files to copy to the runtime directory.\n\n    Returns\n    -------\n    cclibSchema\n        Dictionary of results, as specified in\n        [quacc.schemas.cclib.cclib_summarize_run][]\n    \"\"\"\n    calc_flags = merge_dicts(calc_defaults, calc_swaps)\n\n    atoms.calc = Gaussian(command=GAUSSIAN_CMD, label=_LABEL, **calc_flags)\n    atoms = run_calc(atoms, geom_file=LOG_FILE, copy_files=copy_files)\n\n    return cclib_summarize_run(atoms, LOG_FILE, additional_fields=additional_fields)\n</code></pre>"},{"location":"reference/quacc/recipes/gaussian/core.html","title":"core","text":"<p>Core recipes for Gaussian.</p>"},{"location":"reference/quacc/recipes/gaussian/core.html#quacc.recipes.gaussian.core.relax_job","title":"relax_job","text":"<pre><code>relax_job(\n    atoms,\n    charge,\n    spin_multiplicity,\n    xc=\"wb97xd\",\n    basis=\"def2tzvp\",\n    freq=False,\n    copy_files=None,\n    **calc_kwargs\n)\n</code></pre> <p>Carry out a geometry optimization.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>Atoms object</p> </li> <li> <code>charge</code>             (<code>int</code>)         \u2013          <p>Charge of the system.</p> </li> <li> <code>spin_multiplicity</code>             (<code>int</code>)         \u2013          <p>Multiplicity of the system.</p> </li> <li> <code>xc</code>             (<code>str</code>, default:                 <code>'wb97xd'</code> )         \u2013          <p>Exchange-correlation functional</p> </li> <li> <code>basis</code>             (<code>str</code>, default:                 <code>'def2tzvp'</code> )         \u2013          <p>Basis set</p> </li> <li> <code>freq</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>If a frequency calculation should be carried out.</p> </li> <li> <code>copy_files</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> <li> <code>**calc_kwargs</code>         \u2013          <p>Custom kwargs for the Gaussian calculator. Set a value to <code>None</code> to remove a pre-existing key entirely. For a list of available keys, refer to the <code>ase.calculators.gaussian.Gaussian</code> calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>cclibSchema</code>         \u2013          <p>Dictionary of results, as specified in quacc.schemas.cclib.cclib_summarize_run</p> </li> </ul> Source code in <code>quacc/recipes/gaussian/core.py</code> <pre><code>@job\ndef relax_job(\n    atoms: Atoms,\n    charge: int,\n    spin_multiplicity: int,\n    xc: str = \"wb97xd\",\n    basis: str = \"def2tzvp\",\n    freq: bool = False,\n    copy_files: list[str] | None = None,\n    **calc_kwargs,\n) -&gt; cclibSchema:\n    \"\"\"\n    Carry out a geometry optimization.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    charge\n        Charge of the system.\n    spin_multiplicity\n        Multiplicity of the system.\n    xc\n        Exchange-correlation functional\n    basis\n        Basis set\n    freq\n        If a frequency calculation should be carried out.\n    copy_files\n        Files to copy to the runtime directory.\n    **calc_kwargs\n        Custom kwargs for the Gaussian calculator. Set a value to\n        `None` to remove a pre-existing key entirely. For a list of available\n        keys, refer to the `ase.calculators.gaussian.Gaussian` calculator.\n\n    Returns\n    -------\n    cclibSchema\n        Dictionary of results, as specified in\n        [quacc.schemas.cclib.cclib_summarize_run][]\n    \"\"\"\n\n    calc_defaults = {\n        \"mem\": \"16GB\",\n        \"chk\": \"Gaussian.chk\",\n        \"nprocshared\": psutil.cpu_count(logical=False),\n        \"xc\": xc,\n        \"basis\": basis,\n        \"charge\": charge,\n        \"mult\": spin_multiplicity,\n        \"opt\": \"\",\n        \"pop\": \"CM5\",\n        \"scf\": [\"maxcycle=250\", \"xqc\"],\n        \"integral\": \"ultrafine\",\n        \"nosymmetry\": \"\",\n        \"freq\": \"\" if freq else None,\n        \"ioplist\": [\"2/9=2000\"],  # ASE issue #660\n    }\n    return base_fn(\n        atoms,\n        calc_defaults=calc_defaults,\n        calc_swaps=calc_kwargs,\n        additional_fields={\"name\": \"Gaussian Relax\"},\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/gaussian/core.html#quacc.recipes.gaussian.core.static_job","title":"static_job","text":"<pre><code>static_job(\n    atoms,\n    charge=0,\n    spin_multiplicity=1,\n    xc=\"wb97xd\",\n    basis=\"def2tzvp\",\n    copy_files=None,\n    **calc_kwargs\n)\n</code></pre> <p>Carry out a single-point calculation.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>Atoms object</p> </li> <li> <code>charge</code>             (<code>int</code>, default:                 <code>0</code> )         \u2013          <p>Charge of the system.</p> </li> <li> <code>spin_multiplicity</code>             (<code>int</code>, default:                 <code>1</code> )         \u2013          <p>Multiplicity of the system.</p> </li> <li> <code>xc</code>             (<code>str</code>, default:                 <code>'wb97xd'</code> )         \u2013          <p>Exchange-correlation functional</p> </li> <li> <code>basis</code>             (<code>str</code>, default:                 <code>'def2tzvp'</code> )         \u2013          <p>Basis set</p> </li> <li> <code>copy_files</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> <li> <code>**calc_kwargs</code>         \u2013          <p>Custom kwargs for the Gaussian calculator. Set a value to <code>None</code> to remove a pre-existing key entirely. For a list of available keys, refer to the <code>ase.calculators.gaussian.Gaussian</code> calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>cclibSchema</code>         \u2013          <p>Dictionary of results, as specified in quacc.schemas.cclib.cclib_summarize_run</p> </li> </ul> Source code in <code>quacc/recipes/gaussian/core.py</code> <pre><code>@job\ndef static_job(\n    atoms: Atoms,\n    charge: int = 0,\n    spin_multiplicity: int = 1,\n    xc: str = \"wb97xd\",\n    basis: str = \"def2tzvp\",\n    copy_files: list[str] | None = None,\n    **calc_kwargs,\n) -&gt; cclibSchema:\n    \"\"\"\n    Carry out a single-point calculation.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    charge\n        Charge of the system.\n    spin_multiplicity\n        Multiplicity of the system.\n    xc\n        Exchange-correlation functional\n    basis\n        Basis set\n    copy_files\n        Files to copy to the runtime directory.\n    **calc_kwargs\n        Custom kwargs for the Gaussian calculator. Set a value to\n        `None` to remove a pre-existing key entirely. For a list of available\n        keys, refer to the `ase.calculators.gaussian.Gaussian` calculator.\n\n    Returns\n    -------\n    cclibSchema\n        Dictionary of results, as specified in\n        [quacc.schemas.cclib.cclib_summarize_run][]\n    \"\"\"\n\n    calc_defaults = {\n        \"mem\": \"16GB\",\n        \"chk\": \"Gaussian.chk\",\n        \"nprocshared\": psutil.cpu_count(logical=False),\n        \"xc\": xc,\n        \"basis\": basis,\n        \"charge\": charge,\n        \"mult\": spin_multiplicity,\n        \"sp\": \"\",\n        \"scf\": [\"maxcycle=250\", \"xqc\"],\n        \"integral\": \"ultrafine\",\n        \"nosymmetry\": \"\",\n        \"pop\": \"CM5\",\n        \"gfinput\": \"\",\n        \"ioplist\": [\"6/7=3\", \"2/9=2000\"],  # see ASE issue #660\n    }\n    return base_fn(\n        atoms,\n        calc_defaults=calc_defaults,\n        calc_swaps=calc_kwargs,\n        additional_fields={\"name\": \"Gaussian Static\"},\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/gulp/_base.html","title":"_base","text":"<p>Base jobs for GULP</p>"},{"location":"reference/quacc/recipes/gulp/_base.html#quacc.recipes.gulp._base.base_fn","title":"base_fn","text":"<pre><code>base_fn(\n    atoms,\n    library=None,\n    keyword_defaults=None,\n    option_defaults=None,\n    keyword_swaps=None,\n    option_swaps=None,\n    additional_fields=None,\n)\n</code></pre> <p>Base job function for GULP recipes.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>Atoms object</p> </li> <li> <code>library</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>Filename of the potential library file, if required.</p> </li> <li> <code>keyword_defaults</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Default <code>keywords</code> for calculator.</p> </li> <li> <code>option_defaults</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Default <code>options</code> for calculator.</p> </li> <li> <code>keyword_swaps</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom <code>keyword</code> kwargs for the GULP calculator. Set a value to <code>None</code> to remove a pre-existing key entirely. For a list of available keys, refer to the <code>ase.calculators.gulp.GULP</code> calculator.</p> </li> <li> <code>option_swaps</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom <code>options</code> kwargs for the GULP calculator. Set a value to <code>None</code> to remove a pre-existing key entirely. For a list of available keys, refer to the <code>ase.calculators.gulp.GULP</code> calculator.</p> </li> <li> <code>additional_fields</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional field to supply to the summarizer.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.ase.summarize_run</p> </li> </ul> Source code in <code>quacc/recipes/gulp/_base.py</code> <pre><code>def base_fn(\n    atoms: Atoms,\n    library: str | None = None,\n    keyword_defaults: dict[str, Any] | None = None,\n    option_defaults: dict[str, Any] | None = None,\n    keyword_swaps: dict[str, Any] | None = None,\n    option_swaps: dict[str, Any] | None = None,\n    additional_fields: dict[str, Any] | None = None,\n) -&gt; RunSchema:\n    \"\"\"\n    Base job function for GULP recipes.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    library\n        Filename of the potential library file, if required.\n    keyword_defaults\n        Default `keywords` for calculator.\n    option_defaults\n        Default `options` for calculator.\n    keyword_swaps\n        Dictionary of custom `keyword` kwargs for the GULP calculator. Set a\n        value to `None` to remove a pre-existing key entirely. For a list of\n        available keys, refer to the `ase.calculators.gulp.GULP` calculator.\n    option_swaps\n        Dictionary of custom `options` kwargs for the GULP calculator. Set a\n        value to `None` to remove a pre-existing key entirely. For a list of\n        available keys, refer to the `ase.calculators.gulp.GULP` calculator.\n    additional_fields\n        Additional field to supply to the summarizer.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results from [quacc.schemas.ase.summarize_run][]\n    \"\"\"\n    keyword_defaults = keyword_defaults or {}\n\n    if not atoms.pbc.any():\n        if keyword_defaults.get(\"opti\") and not keyword_defaults.get(\"conv\"):\n            keyword_defaults[\"conv\"] = True\n        for k in [\"gwolf\", \"conp\"]:\n            keyword_defaults.pop(k, None)\n\n    option_defaults = merge_dicts(\n        option_defaults,\n        {\n            f\"output cif {GEOM_FILE_PBC}\": True if atoms.pbc.any() else None,\n            f\"output xyz {GEOM_FILE_NOPBC}\": None if atoms.pbc.any() else True,\n        },\n    )\n\n    keywords = merge_dicts(keyword_defaults, keyword_swaps)\n    options = merge_dicts(option_defaults, option_swaps)\n\n    gulp_keywords = \" \".join(list(keywords.keys()))\n    gulp_options = list(options.keys())\n\n    if SETTINGS.GULP_LIB:\n        os.environ[\"GULP_LIB\"] = str(SETTINGS.GULP_LIB)\n    atoms.calc = GULP(\n        command=GULP_CMD, keywords=gulp_keywords, options=gulp_options, library=library\n    )\n    final_atoms = run_calc(\n        atoms, geom_file=GEOM_FILE_PBC if atoms.pbc.any() else GEOM_FILE_NOPBC\n    )\n\n    if (\n        SETTINGS.CHECK_CONVERGENCE\n        and \"opti\" in gulp_keywords\n        and not final_atoms.calc.get_opt_state()\n    ):\n        msg = \"Optimization did not converge.\"\n        raise RuntimeError(msg)\n\n    return summarize_run(\n        final_atoms, input_atoms=atoms, additional_fields=additional_fields\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/gulp/core.html","title":"core","text":"<p>Core recipes for GULP.</p>"},{"location":"reference/quacc/recipes/gulp/core.html#quacc.recipes.gulp.core.relax_job","title":"relax_job","text":"<pre><code>relax_job(\n    atoms,\n    use_gfnff=True,\n    relax_cell=False,\n    keywords=None,\n    options=None,\n    library=None,\n)\n</code></pre> <p>Carry out a structure relaxation.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>Atoms object</p> </li> <li> <code>use_gfnff</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>True if (p)GFN-FF should be used; False if not.</p> </li> <li> <code>relax_cell</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>True if the volume should be relaxed; False if not.</p> </li> <li> <code>keywords</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom <code>keyword</code> kwargs for the GULP calculator. Set a value to <code>None</code> to remove a pre-existing key entirely. For a list of available keys, refer to the <code>ase.calculators.gulp.GULP</code> calculator.</p> </li> <li> <code>options</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom <code>options</code> kwargs for the GULP calculator. Set a value to <code>None</code> to remove a pre-existing key entirely. For a list of available keys, refer to the <code>ase.calculators.gulp.GULP</code> calculator.</p> </li> <li> <code>library</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>Filename of the potential library file, if required.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>Dictionary of results from quacc.schemas.ase.summarize_run</p> </li> </ul> Source code in <code>quacc/recipes/gulp/core.py</code> <pre><code>@job\ndef relax_job(\n    atoms: Atoms,\n    use_gfnff: bool = True,\n    relax_cell: bool = False,\n    keywords: dict[str, Any] | None = None,\n    options: dict[str, Any] | None = None,\n    library: str | None = None,\n) -&gt; RunSchema:\n    \"\"\"\n    Carry out a structure relaxation.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    use_gfnff\n        True if (p)GFN-FF should be used; False if not.\n    relax_cell\n        True if the volume should be relaxed; False if not.\n    keywords\n        Dictionary of custom `keyword` kwargs for the GULP calculator. Set a\n        value to `None` to remove a pre-existing key entirely. For a list of\n        available keys, refer to the `ase.calculators.gulp.GULP` calculator.\n    options\n        Dictionary of custom `options` kwargs for the GULP calculator. Set a\n        value to `None` to remove a pre-existing key entirely. For a list of\n        available keys, refer to the `ase.calculators.gulp.GULP` calculator.\n    library\n        Filename of the potential library file, if required.\n\n    Returns\n    -------\n    dict\n        Dictionary of results from [quacc.schemas.ase.summarize_run][]\n    \"\"\"\n\n    keyword_defaults = {\n        \"opti\": True,\n        \"gfnff\": True if use_gfnff else None,\n        \"gwolf\": True if use_gfnff else None,\n        \"conp\": True if relax_cell else None,\n        \"conv\": None if relax_cell else True,\n    }\n    option_defaults = {\"dump every gulp.res\": True}\n\n    return base_fn(\n        atoms,\n        library=library,\n        keyword_defaults=keyword_defaults,\n        option_defaults=option_defaults,\n        keyword_swaps=keywords,\n        option_swaps=options,\n        additional_fields={\"name\": \"GULP Relax\"},\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/gulp/core.html#quacc.recipes.gulp.core.static_job","title":"static_job","text":"<pre><code>static_job(\n    atoms,\n    use_gfnff=True,\n    keywords=None,\n    options=None,\n    library=None,\n)\n</code></pre> <p>Carry out a single-point calculation.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>Atoms object</p> </li> <li> <code>use_gfnff</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>True if (p)GFN-FF should be used; False if not.</p> </li> <li> <code>keywords</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom <code>keyword</code> kwargs for the GULP calculator. Set a value to <code>None</code> to remove a pre-existing key entirely. For a list of available keys, refer to the <code>ase.calculators.gulp.GULP</code> calculator.</p> </li> <li> <code>options</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom <code>options</code> kwargs for the GULP calculator. Set a value to <code>None</code> to remove a pre-existing key entirely. For a list of available keys, refer to the <code>ase.calculators.gulp.GULP</code> calculator.</p> </li> <li> <code>library</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>Filename of the potential library file, if required.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.ase.summarize_run</p> </li> </ul> Source code in <code>quacc/recipes/gulp/core.py</code> <pre><code>@job\ndef static_job(\n    atoms: Atoms,\n    use_gfnff: bool = True,\n    keywords: dict[str, Any] | None = None,\n    options: dict[str, Any] | None = None,\n    library: str | None = None,\n) -&gt; RunSchema:\n    \"\"\"\n    Carry out a single-point calculation.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    use_gfnff\n        True if (p)GFN-FF should be used; False if not.\n    keywords\n        Dictionary of custom `keyword` kwargs for the GULP calculator. Set a\n        value to `None` to remove a pre-existing key entirely. For a list of\n        available keys, refer to the `ase.calculators.gulp.GULP` calculator.\n    options\n        Dictionary of custom `options` kwargs for the GULP calculator. Set a\n        value to `None` to remove a pre-existing key entirely. For a list of\n        available keys, refer to the `ase.calculators.gulp.GULP` calculator.\n    library\n        Filename of the potential library file, if required.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results from [quacc.schemas.ase.summarize_run][]\n    \"\"\"\n\n    keyword_defaults = {\n        \"gfnff\": True if use_gfnff else None,\n        \"gwolf\": True if use_gfnff else None,\n    }\n    option_defaults = {\"dump every gulp.res\": True}\n\n    return base_fn(\n        atoms,\n        library=library,\n        keyword_defaults=keyword_defaults,\n        option_defaults=option_defaults,\n        keyword_swaps=keywords,\n        option_swaps=options,\n        additional_fields={\"name\": \"GULP Static\"},\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/lj/core.html","title":"core","text":"<p>Core recipes for Lennard-Jones Potential.</p> <p>NOTE: This set of minimal recipes is mainly for demonstration purposes</p>"},{"location":"reference/quacc/recipes/lj/core.html#quacc.recipes.lj.core.freq_job","title":"freq_job","text":"<pre><code>freq_job(\n    atoms,\n    energy=0.0,\n    temperature=298.15,\n    pressure=1.0,\n    vib_kwargs=None,\n    **calc_kwargs\n)\n</code></pre> <p>Run a frequency job and calculate thermochemistry.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>Atoms object</p> </li> <li> <code>energy</code>             (<code>float</code>, default:                 <code>0.0</code> )         \u2013          <p>Potential energy in eV. If 0, then the output is just the correction.</p> </li> <li> <code>temperature</code>             (<code>float</code>, default:                 <code>298.15</code> )         \u2013          <p>Temperature in Kelvins.</p> </li> <li> <code>pressure</code>             (<code>float</code>, default:                 <code>1.0</code> )         \u2013          <p>Pressure in bar.</p> </li> <li> <code>vib_kwargs</code>             (<code>VibKwargs | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of kwargs for the <code>ase.vibrations.Vibrations</code> class.</p> </li> <li> <code>**calc_kwargs</code>         \u2013          <p>Dictionary of custom kwargs for the LJ calculator. Set a value to <code>None</code> to remove a pre-existing key entirely. For a list of available keys, refer to the <code>ase.calculators.lj.LJ</code> calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>VibThermoSchema</code>         \u2013          <p>Dictionary of results, specified in quacc.schemas.ase.summarize_vib_and_thermo</p> </li> </ul> Source code in <code>quacc/recipes/lj/core.py</code> <pre><code>@job\ndef freq_job(\n    atoms: Atoms,\n    energy: float = 0.0,\n    temperature: float = 298.15,\n    pressure: float = 1.0,\n    vib_kwargs: VibKwargs | None = None,\n    **calc_kwargs,\n) -&gt; VibThermoSchema:\n    \"\"\"\n    Run a frequency job and calculate thermochemistry.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    energy\n        Potential energy in eV. If 0, then the output is just the correction.\n    temperature\n        Temperature in Kelvins.\n    pressure\n        Pressure in bar.\n    vib_kwargs\n        Dictionary of kwargs for the `ase.vibrations.Vibrations` class.\n    **calc_kwargs\n        Dictionary of custom kwargs for the LJ calculator. Set a value to\n        `None` to remove a pre-existing key entirely. For a list of available\n        keys, refer to the `ase.calculators.lj.LJ` calculator.\n\n    Returns\n    -------\n    VibThermoSchema\n        Dictionary of results, specified in [quacc.schemas.ase.summarize_vib_and_thermo][]\n    \"\"\"\n    vib_kwargs = vib_kwargs or {}\n\n    atoms.calc = LennardJones(**calc_kwargs)\n    vibrations = run_vib(atoms, vib_kwargs=vib_kwargs)\n    igt = run_ideal_gas(atoms, vibrations.get_frequencies(), energy=energy)\n\n    return summarize_vib_and_thermo(\n        vibrations,\n        igt,\n        temperature=temperature,\n        pressure=pressure,\n        additional_fields={\"name\": \"LJ Frequency and Thermo\"},\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/lj/core.html#quacc.recipes.lj.core.relax_job","title":"relax_job","text":"<pre><code>relax_job(atoms, opt_params=None, **calc_kwargs)\n</code></pre> <p>Function to carry out a geometry optimization.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>Atoms object</p> </li> <li> <code>opt_params</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom kwargs for the optimization process. Set a value to <code>None</code> to remove a pre-existing key entirely. For a list of available keys, refer to quacc.runners.ase.run_opt.</p> </li> <li> <code>**calc_kwargs</code>         \u2013          <p>Custom kwargs for the LJ calculator. Set a value to <code>None</code> to remove a pre-existing key entirely. For a list of available keys, refer to the <code>ase.calculators.lj.LJ</code> calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OptSchema</code>         \u2013          <p>Dictionary of results, specified in quacc.schemas.ase.summarize_run</p> </li> </ul> Source code in <code>quacc/recipes/lj/core.py</code> <pre><code>@job\ndef relax_job(\n    atoms: Atoms, opt_params: dict[str, Any] | None = None, **calc_kwargs\n) -&gt; OptSchema:\n    \"\"\"\n    Function to carry out a geometry optimization.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    opt_params\n        Dictionary of custom kwargs for the optimization process. Set a value\n        to `None` to remove a pre-existing key entirely. For a list of available\n        keys, refer to [quacc.runners.ase.run_opt][].\n    **calc_kwargs\n        Custom kwargs for the LJ calculator. Set a value to\n        `None` to remove a pre-existing key entirely. For a list of available\n        keys, refer to the `ase.calculators.lj.LJ` calculator.\n\n    Returns\n    -------\n    OptSchema\n        Dictionary of results, specified in [quacc.schemas.ase.summarize_run][]\n    \"\"\"\n    opt_defaults = {\"fmax\": 0.01, \"max_steps\": 1000, \"optimizer\": FIRE}\n    opt_flags = merge_dicts(opt_defaults, opt_params)\n\n    atoms.calc = LennardJones(**calc_kwargs)\n    dyn = run_opt(atoms, **opt_flags)\n\n    return summarize_opt_run(dyn, additional_fields={\"name\": \"LJ Relax\"})\n</code></pre>"},{"location":"reference/quacc/recipes/lj/core.html#quacc.recipes.lj.core.static_job","title":"static_job","text":"<pre><code>static_job(atoms, **calc_kwargs)\n</code></pre> <p>Function to carry out a static calculation.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>Atoms object</p> </li> <li> <code>**calc_kwargs</code>         \u2013          <p>Dictionary of custom kwargs for the LJ calculator. Set a value to <code>None</code> to remove a pre-existing key entirely. For a list of available keys, refer to the <code>ase.calculators.lj.LJ</code> calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>         \u2013          <p>Dictionary of results, specified in quacc.schemas.ase.summarize_run</p> </li> </ul> Source code in <code>quacc/recipes/lj/core.py</code> <pre><code>@job\ndef static_job(atoms: Atoms, **calc_kwargs) -&gt; RunSchema:\n    \"\"\"\n    Function to carry out a static calculation.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    **calc_kwargs\n        Dictionary of custom kwargs for the LJ calculator. Set a value to\n        `None` to remove a pre-existing key entirely. For a list of available\n        keys, refer to the `ase.calculators.lj.LJ` calculator.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results, specified in [quacc.schemas.ase.summarize_run][]\n    \"\"\"\n\n    atoms.calc = LennardJones(**calc_kwargs)\n    final_atoms = run_calc(atoms)\n\n    return summarize_run(\n        final_atoms, input_atoms=atoms, additional_fields={\"name\": \"LJ Static\"}\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/newtonnet/core.html","title":"core","text":"<p>Core recipes for the NewtonNet code.</p>"},{"location":"reference/quacc/recipes/newtonnet/core.html#quacc.recipes.newtonnet.core.freq_job","title":"freq_job","text":"<pre><code>freq_job(\n    atoms,\n    temperature=298.15,\n    pressure=1.0,\n    copy_files=None,\n    **calc_kwargs\n)\n</code></pre> <p>Perform a frequency calculation using the given atoms object.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>The atoms object representing the system.</p> </li> <li> <code>temperature</code>             (<code>float</code>, default:                 <code>298.15</code> )         \u2013          <p>The temperature for the thermodynamic analysis.</p> </li> <li> <code>pressure</code>             (<code>float</code>, default:                 <code>1.0</code> )         \u2013          <p>The pressure for the thermodynamic analysis.</p> </li> <li> <code>copy_files</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> <li> <code>**calc_kwargs</code>         \u2013          <p>Custom kwargs for the NewtonNet calculator. Set a value to <code>None</code> to remove a pre-existing key entirely. For a list of available keys, refer to the <code>newtonnet.utils.ase_interface.MLAseCalculator</code> calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>FreqSchema</code>         \u2013          <p>Dictionary of results</p> </li> </ul> Source code in <code>quacc/recipes/newtonnet/core.py</code> <pre><code>@job\n@requires(NewtonNet, \"NewtonNet must be installed. Refer to the quacc documentation.\")\ndef freq_job(\n    atoms: Atoms,\n    temperature: float = 298.15,\n    pressure: float = 1.0,\n    copy_files: list[str] | None = None,\n    **calc_kwargs,\n) -&gt; FreqSchema:\n    \"\"\"\n    Perform a frequency calculation using the given atoms object.\n\n    Parameters\n    ----------\n    atoms\n        The atoms object representing the system.\n    temperature\n        The temperature for the thermodynamic analysis.\n    pressure\n        The pressure for the thermodynamic analysis.\n    copy_files\n        Files to copy to the runtime directory.\n    **calc_kwargs\n        Custom kwargs for the NewtonNet calculator. Set a value to\n        `None` to remove a pre-existing key entirely. For a list of available\n        keys, refer to the `newtonnet.utils.ase_interface.MLAseCalculator` calculator.\n\n    Returns\n    -------\n    FreqSchema\n        Dictionary of results\n    \"\"\"\n\n    defaults = {\n        \"model_path\": SETTINGS.NEWTONNET_MODEL_PATH,\n        \"settings_path\": SETTINGS.NEWTONNET_CONFIG_PATH,\n        \"hess_method\": \"autograd\",\n    }\n    calc_flags = merge_dicts(defaults, calc_kwargs)\n\n    ml_calculator = NewtonNet(**calc_flags)\n    atoms.calc = ml_calculator\n    final_atoms = run_calc(atoms, copy_files=copy_files)\n\n    summary = summarize_run(\n        final_atoms, input_atoms=atoms, additional_fields={\"name\": \"NewtonNet Hessian\"}\n    )\n    energy = summary[\"results\"][\"energy\"]\n    hessian = summary[\"results\"][\"hessian\"]\n\n    vib = VibrationsData(final_atoms, hessian)\n    summary[\"vib\"] = summarize_vib_run(\n        vib, additional_fields={\"name\": \"ASE Vibrations Analysis\"}\n    )\n\n    igt = run_ideal_gas(final_atoms, vib.get_frequencies(), energy=energy)\n    summary[\"thermo\"] = summarize_ideal_gas_thermo(\n        igt,\n        temperature=temperature,\n        pressure=pressure,\n        additional_fields={\"name\": \"ASE Thermo Analysis\"},\n    )\n\n    return summary\n</code></pre>"},{"location":"reference/quacc/recipes/newtonnet/core.html#quacc.recipes.newtonnet.core.relax_job","title":"relax_job","text":"<pre><code>relax_job(\n    atoms, opt_params=None, copy_files=None, **calc_kwargs\n)\n</code></pre> <p>Relax a structure.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>Atoms object</p> </li> <li> <code>opt_params</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom kwargs for the optimization process. Set a value to <code>None</code> to remove a pre-existing key entirely. For a list of available keys, refer to quacc.runners.ase.run_opt.</p> </li> <li> <code>copy_files</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> <li> <code>**calc_kwargs</code>         \u2013          <p>Dictionary of custom kwargs for the NewtonNet calculator. Set a value to <code>None</code> to remove a pre-existing key entirely. For a list of available keys, refer to the <code>newtonnet.utils.ase_interface.MLAseCalculator</code> calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OptSchema</code>         \u2013          <p>Dictionary of results, specified in quacc.schemas.ase.summarize_opt_run</p> </li> </ul> Source code in <code>quacc/recipes/newtonnet/core.py</code> <pre><code>@job\n@requires(NewtonNet, \"NewtonNet must be installed. Refer to the quacc documentation.\")\ndef relax_job(\n    atoms: Atoms,\n    opt_params: dict[str, Any] | None = None,\n    copy_files: list[str] | None = None,\n    **calc_kwargs,\n) -&gt; OptSchema:\n    \"\"\"\n    Relax a structure.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    opt_params\n        Dictionary of custom kwargs for the optimization process. Set a value\n        to `None` to remove a pre-existing key entirely. For a list of available\n        keys, refer to [quacc.runners.ase.run_opt][].\n    copy_files\n        Files to copy to the runtime directory.\n    **calc_kwargs\n        Dictionary of custom kwargs for the NewtonNet calculator. Set a value to\n        `None` to remove a pre-existing key entirely. For a list of available\n        keys, refer to the `newtonnet.utils.ase_interface.MLAseCalculator` calculator.\n\n    Returns\n    -------\n    OptSchema\n        Dictionary of results, specified in [quacc.schemas.ase.summarize_opt_run][]\n    \"\"\"\n\n    calc_defaults = {\n        \"model_path\": SETTINGS.NEWTONNET_MODEL_PATH,\n        \"settings_path\": SETTINGS.NEWTONNET_CONFIG_PATH,\n    }\n    opt_defaults = {\"fmax\": 0.01, \"max_steps\": 1000, \"optimizer\": Sella or FIRE}\n\n    calc_flags = merge_dicts(calc_defaults, calc_kwargs)\n    opt_flags = merge_dicts(opt_defaults, opt_params)\n\n    atoms.calc = NewtonNet(**calc_flags)\n    dyn = run_opt(atoms, copy_files=copy_files, **opt_flags)\n\n    return _add_stdev_and_hess(\n        summarize_opt_run(dyn, additional_fields={\"name\": \"NewtonNet Relax\"})\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/newtonnet/core.html#quacc.recipes.newtonnet.core.static_job","title":"static_job","text":"<pre><code>static_job(atoms, copy_files=None, **calc_kwargs)\n</code></pre> <p>Carry out a single-point calculation.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>Atoms object</p> </li> <li> <code>copy_files</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> <li> <code>**calc_kwargs</code>         \u2013          <p>Custom kwargs for the NewtonNet calculator. Set a value to <code>None</code> to remove a pre-existing key entirely. For a list of available keys, refer to the <code>newtonnet.utils.ase_interface.MLAseCalculator</code> calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>         \u2013          <p>Dictionary of results, specified in quacc.schemas.ase.summarize_run</p> </li> </ul> Source code in <code>quacc/recipes/newtonnet/core.py</code> <pre><code>@job\n@requires(NewtonNet, \"NewtonNet must be installed. Refer to the quacc documentation.\")\ndef static_job(\n    atoms: Atoms, copy_files: list[str] | None = None, **calc_kwargs\n) -&gt; RunSchema:\n    \"\"\"\n    Carry out a single-point calculation.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    copy_files\n        Files to copy to the runtime directory.\n    **calc_kwargs\n        Custom kwargs for the NewtonNet calculator. Set a value to\n        `None` to remove a pre-existing key entirely. For a list of available\n        keys, refer to the `newtonnet.utils.ase_interface.MLAseCalculator` calculator.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results, specified in [quacc.schemas.ase.summarize_run][]\n    \"\"\"\n\n    defaults = {\n        \"model_path\": SETTINGS.NEWTONNET_MODEL_PATH,\n        \"settings_path\": SETTINGS.NEWTONNET_CONFIG_PATH,\n    }\n    calc_flags = merge_dicts(defaults, calc_kwargs)\n\n    atoms.calc = NewtonNet(**calc_flags)\n    final_atoms = run_calc(atoms, copy_files=copy_files)\n\n    return summarize_run(\n        final_atoms, input_atoms=atoms, additional_fields={\"name\": \"NewtonNet Static\"}\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/newtonnet/ts.html","title":"ts","text":"<p>Transition state recipes for the NewtonNet code.</p>"},{"location":"reference/quacc/recipes/newtonnet/ts.html#quacc.recipes.newtonnet.ts.irc_job","title":"irc_job","text":"<pre><code>irc_job(\n    atoms,\n    direction=\"forward\",\n    run_freq=True,\n    freq_job_kwargs=None,\n    opt_params=None,\n    **calc_kwargs\n)\n</code></pre> <p>Perform an intrinsic reaction coordinate (IRC) job using the given atoms object.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>The atoms object representing the system.</p> </li> <li> <code>direction</code>             (<code>Literal['forward', 'reverse']</code>, default:                 <code>'forward'</code> )         \u2013          <p>The direction of the IRC calculation (\"forward\" or \"reverse\").</p> </li> <li> <code>run_freq</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to run the frequency analysis.</p> </li> <li> <code>freq_job_kwargs</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Keyword arguments to use for the quacc.recipes.newtonnet.ts.freq_job</p> </li> <li> <code>opt_params</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom kwargs for the optimization process. Set a value to <code>None</code> to remove a pre-existing key entirely. For a list of available keys, refer to quacc.runners.ase.run_opt.</p> </li> <li> <code>**calc_kwargs</code>         \u2013          <p>Custom kwargs for the NewtonNet calculator. Set a value to <code>None</code> to remove a pre-existing key entirely. For a list of available keys, refer to the <code>newtonnet.utils.ase_interface.MLAseCalculator</code> calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>IRCSchema</code>         \u2013          <p>A dictionary containing the IRC summary and thermodynamic summary.</p> </li> </ul> Source code in <code>quacc/recipes/newtonnet/ts.py</code> <pre><code>@job\n@requires(NewtonNet, \"NewtonNet must be installed. Refer to the quacc documentation.\")\n@requires(Sella, \"Sella must be installed. Refer to the quacc documentation.\")\ndef irc_job(\n    atoms: Atoms,\n    direction: Literal[\"forward\", \"reverse\"] = \"forward\",\n    run_freq: bool = True,\n    freq_job_kwargs: dict[str, Any] | None = None,\n    opt_params: dict[str, Any] | None = None,\n    **calc_kwargs,\n) -&gt; IRCSchema:\n    \"\"\"\n    Perform an intrinsic reaction coordinate (IRC) job using the given atoms object.\n\n    Parameters\n    ----------\n    atoms\n        The atoms object representing the system.\n    direction\n        The direction of the IRC calculation (\"forward\" or \"reverse\").\n    run_freq\n        Whether to run the frequency analysis.\n    freq_job_kwargs\n        Keyword arguments to use for the [quacc.recipes.newtonnet.ts.freq_job][]\n    opt_params\n        Dictionary of custom kwargs for the optimization process. Set a value\n        to `None` to remove a pre-existing key entirely. For a list of available\n        keys, refer to [quacc.runners.ase.run_opt][].\n    **calc_kwargs\n        Custom kwargs for the NewtonNet calculator. Set a value to\n        `None` to remove a pre-existing key entirely. For a list of available\n        keys, refer to the `newtonnet.utils.ase_interface.MLAseCalculator` calculator.\n\n    Returns\n    -------\n    IRCSchema\n        A dictionary containing the IRC summary and thermodynamic summary.\n    \"\"\"\n    freq_job_kwargs = freq_job_kwargs or {}\n    default_settings = SETTINGS.model_copy()\n\n    calc_defaults = {\n        \"model_path\": SETTINGS.NEWTONNET_MODEL_PATH,\n        \"settings_path\": SETTINGS.NEWTONNET_CONFIG_PATH,\n    }\n    opt_defaults = {\n        \"fmax\": 0.01,\n        \"max_steps\": 1000,\n        \"optimizer\": IRC,\n        \"optimizer_kwargs\": {\"dx\": 0.1, \"eta\": 1e-4, \"gamma\": 0.4, \"keep_going\": True},\n        \"run_kwargs\": {\"direction\": direction},\n    }\n\n    calc_flags = merge_dicts(calc_defaults, calc_kwargs)\n    opt_flags = merge_dicts(opt_defaults, opt_params)\n\n    # Define calculator\n    atoms.calc = NewtonNet(**calc_flags)\n\n    # Run IRC\n    SETTINGS.CHECK_CONVERGENCE = False\n    dyn = run_opt(atoms, **opt_flags)\n    opt_irc_summary = _add_stdev_and_hess(\n        summarize_opt_run(\n            dyn, additional_fields={\"name\": f\"NewtonNet IRC: {direction}\"}\n        )\n    )\n    SETTINGS.CHECK_CONVERGENCE = default_settings.CHECK_CONVERGENCE\n\n    # Run frequency job\n    freq_summary = (\n        freq_job.__wrapped__(opt_irc_summary[\"atoms\"], **freq_job_kwargs)\n        if run_freq\n        else None\n    )\n    opt_irc_summary[\"freq_job\"] = freq_summary\n\n    return opt_irc_summary\n</code></pre>"},{"location":"reference/quacc/recipes/newtonnet/ts.html#quacc.recipes.newtonnet.ts.quasi_irc_job","title":"quasi_irc_job","text":"<pre><code>quasi_irc_job(\n    atoms,\n    direction=\"forward\",\n    run_freq=True,\n    irc_job_kwargs=None,\n    relax_job_kwargs=None,\n    freq_job_kwargs=None,\n)\n</code></pre> <p>Perform a quasi-IRC job using the given atoms object. The initial IRC job by default is run with <code>max_steps: 5</code>.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>The atoms object representing the system</p> </li> <li> <code>direction</code>             (<code>Literal['forward', 'reverse']</code>, default:                 <code>'forward'</code> )         \u2013          <p>The direction of the IRC calculation</p> </li> <li> <code>run_freq</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to run the frequency analysis</p> </li> <li> <code>irc_job_kwargs</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Keyword arguments to use for the quacc.recipes.newtonnet.ts.irc_job</p> </li> <li> <code>relax_job_kwargs</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Keyword arguments to use for the quacc.recipes.newtonnet.core.relax_job</p> </li> <li> <code>freq_job_kwargs</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Keyword arguments to use for the quacc.recipes.newtonnet.ts.freq_job</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>QuasiIRCSchema</code>         \u2013          <p>A dictionary containing the IRC summary, optimization summary, and thermodynamic summary.</p> </li> </ul> Source code in <code>quacc/recipes/newtonnet/ts.py</code> <pre><code>@job\n@requires(NewtonNet, \"NewtonNet must be installed. Refer to the quacc documentation.\")\n@requires(Sella, \"Sella must be installed. Refer to the quacc documentation.\")\ndef quasi_irc_job(\n    atoms: Atoms,\n    direction: Literal[\"forward\", \"reverse\"] = \"forward\",\n    run_freq: bool = True,\n    irc_job_kwargs: dict[str, Any] | None = None,\n    relax_job_kwargs: dict[str, Any] | None = None,\n    freq_job_kwargs: dict[str, Any] | None = None,\n) -&gt; QuasiIRCSchema:\n    \"\"\"\n    Perform a quasi-IRC job using the given atoms object. The initial IRC job by default\n    is run with `max_steps: 5`.\n\n    Parameters\n    ----------\n    atoms\n        The atoms object representing the system\n    direction\n        The direction of the IRC calculation\n    run_freq\n        Whether to run the frequency analysis\n    irc_job_kwargs\n        Keyword arguments to use for the [quacc.recipes.newtonnet.ts.irc_job][]\n    relax_job_kwargs\n        Keyword arguments to use for the [quacc.recipes.newtonnet.core.relax_job][]\n    freq_job_kwargs\n        Keyword arguments to use for the [quacc.recipes.newtonnet.ts.freq_job][]\n\n    Returns\n    -------\n    QuasiIRCSchema\n        A dictionary containing the IRC summary, optimization summary, and\n        thermodynamic summary.\n    \"\"\"\n    relax_job_kwargs = relax_job_kwargs or {}\n    freq_job_kwargs = freq_job_kwargs or {}\n\n    irc_job_defaults = {\"max_steps\": 5}\n    irc_job_kwargs = merge_dicts(irc_job_defaults, irc_job_kwargs)\n\n    # Run IRC\n    irc_summary = irc_job.__wrapped__(\n        atoms, direction=direction, run_freq=False, **irc_job_kwargs\n    )\n\n    # Run opt\n    relax_summary = relax_job.__wrapped__(irc_summary[\"atoms\"], **relax_job_kwargs)\n\n    # Run frequency\n    freq_summary = (\n        freq_job.__wrapped__(relax_summary[\"atoms\"], **freq_job_kwargs)\n        if run_freq\n        else None\n    )\n    relax_summary[\"freq_job\"] = freq_summary\n    relax_summary[\"irc_job\"] = irc_summary\n\n    return relax_summary\n</code></pre>"},{"location":"reference/quacc/recipes/newtonnet/ts.html#quacc.recipes.newtonnet.ts.ts_job","title":"ts_job","text":"<pre><code>ts_job(\n    atoms,\n    use_custom_hessian=False,\n    run_freq=True,\n    freq_job_kwargs=None,\n    opt_params=None,\n    **calc_kwargs\n)\n</code></pre> <p>Perform a transition state (TS) job using the given atoms object.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>The atoms object representing the system.</p> </li> <li> <code>use_custom_hessian</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to use a custom Hessian matrix.</p> </li> <li> <code>run_freq</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to run the frequency job.</p> </li> <li> <code>freq_job_kwargs</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Keyword arguments to use for the quacc.recipes.newtonnet.ts.freq_job</p> </li> <li> <code>opt_params</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom kwargs for the optimization process. Set a value to <code>None</code> to remove a pre-existing key entirely. For a list of available keys, refer to quacc.runners.ase.run_opt.</p> </li> <li> <code>**calc_kwargs</code>         \u2013          <p>Dictionary of custom kwargs for the NewtonNet calculator. Set a value to <code>None</code> to remove a pre-existing key entirely. For a list of available keys, refer to the <code>newtonnet.utils.ase_interface.MLAseCalculator</code> calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>TSSchema</code>         \u2013          <p>Dictionary of results</p> </li> </ul> Source code in <code>quacc/recipes/newtonnet/ts.py</code> <pre><code>@job\n@requires(NewtonNet, \"NewtonNet must be installed. Refer to the quacc documentation.\")\n@requires(Sella, \"Sella must be installed. Refer to the quacc documentation.\")\ndef ts_job(\n    atoms: Atoms,\n    use_custom_hessian: bool = False,\n    run_freq: bool = True,\n    freq_job_kwargs: dict[str, Any] | None = None,\n    opt_params: dict[str, Any] | None = None,\n    **calc_kwargs,\n) -&gt; TSSchema:\n    \"\"\"\n    Perform a transition state (TS) job using the given atoms object.\n\n    Parameters\n    ----------\n    atoms\n        The atoms object representing the system.\n    use_custom_hessian\n        Whether to use a custom Hessian matrix.\n    run_freq\n        Whether to run the frequency job.\n    freq_job_kwargs\n        Keyword arguments to use for the [quacc.recipes.newtonnet.ts.freq_job][]\n    opt_params\n        Dictionary of custom kwargs for the optimization process. Set a value\n        to `None` to remove a pre-existing key entirely. For a list of available\n        keys, refer to [quacc.runners.ase.run_opt][].\n    **calc_kwargs\n        Dictionary of custom kwargs for the NewtonNet calculator. Set a value to\n        `None` to remove a pre-existing key entirely. For a list of available\n        keys, refer to the `newtonnet.utils.ase_interface.MLAseCalculator` calculator.\n\n    Returns\n    -------\n    TSSchema\n        Dictionary of results\n    \"\"\"\n    freq_job_kwargs = freq_job_kwargs or {}\n\n    calc_defaults = {\n        \"model_path\": SETTINGS.NEWTONNET_MODEL_PATH,\n        \"settings_path\": SETTINGS.NEWTONNET_CONFIG_PATH,\n        \"hess_method\": \"autograd\",\n    }\n    opt_defaults = {\n        \"fmax\": 0.01,\n        \"max_steps\": 1000,\n        \"optimizer\": Sella,\n        \"optimizer_kwargs\": {\"diag_every_n\": 0, \"order\": 1}\n        if use_custom_hessian\n        else {\"order\": 1},\n    }\n\n    calc_flags = merge_dicts(calc_defaults, calc_kwargs)\n    opt_flags = merge_dicts(opt_defaults, opt_params)\n\n    atoms.calc = NewtonNet(**calc_flags)\n\n    if use_custom_hessian:\n        opt_flags[\"optimizer_kwargs\"][\"hessian_function\"] = _get_hessian\n\n    ml_calculator = NewtonNet(**calc_flags)\n    atoms.calc = ml_calculator\n\n    # Run the TS optimization\n    dyn = run_opt(atoms, **opt_flags)\n    opt_ts_summary = _add_stdev_and_hess(\n        summarize_opt_run(dyn, additional_fields={\"name\": \"NewtonNet TS\"})\n    )\n\n    # Run a frequency calculation\n    freq_summary = (\n        freq_job.__wrapped__(opt_ts_summary[\"atoms\"], **freq_job_kwargs)\n        if run_freq\n        else None\n    )\n    opt_ts_summary[\"freq_job\"] = freq_summary\n\n    return opt_ts_summary\n</code></pre>"},{"location":"reference/quacc/recipes/orca/_base.html","title":"_base","text":"<p>Base jobs for ORCA</p>"},{"location":"reference/quacc/recipes/orca/_base.html#quacc.recipes.orca._base.base_fn","title":"base_fn","text":"<pre><code>base_fn(\n    atoms,\n    charge=0,\n    spin_multiplicity=1,\n    default_inputs=None,\n    default_blocks=None,\n    input_swaps=None,\n    block_swaps=None,\n    additional_fields=None,\n    copy_files=None,\n)\n</code></pre> <p>Base job function for ORCA recipes.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>Atoms object</p> </li> <li> <code>charge</code>             (<code>int</code>, default:                 <code>0</code> )         \u2013          <p>Charge of the system.</p> </li> <li> <code>spin_multiplicity</code>             (<code>int</code>, default:                 <code>1</code> )         \u2013          <p>Multiplicity of the system.</p> </li> <li> <code>default_inputs</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Default input parameters.</p> </li> <li> <code>default_blocks</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Default block input parameters.</p> </li> <li> <code>input_swaps</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of orcasimpleinput swaps for the calculator. To enable new entries, set the value as True. To remove entries from the defaults, set the value as None.</p> </li> <li> <code>block_swaps</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of orcablock swaps for the calculator. To enable new entries, set the value as True. To remove entries from the defaults, set the value as None.</p> </li> <li> <code>additional_fields</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Any additional fields to supply to the summarizer.</p> </li> <li> <code>copy_files</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>cclibSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.cclib.cclib_summarize_run</p> </li> </ul> Source code in <code>quacc/recipes/orca/_base.py</code> <pre><code>def base_fn(\n    atoms: Atoms,\n    charge: int = 0,\n    spin_multiplicity: int = 1,\n    default_inputs: dict[str, Any] | None = None,\n    default_blocks: dict[str, Any] | None = None,\n    input_swaps: dict[str, Any] | None = None,\n    block_swaps: dict[str, Any] | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    copy_files: list[str] | None = None,\n) -&gt; cclibSchema:\n    \"\"\"\n    Base job function for ORCA recipes.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    charge\n        Charge of the system.\n    spin_multiplicity\n        Multiplicity of the system.\n    default_inputs\n        Default input parameters.\n    default_blocks\n        Default block input parameters.\n    input_swaps\n        Dictionary of orcasimpleinput swaps for the calculator. To enable new\n        entries, set the value as True. To remove entries from the defaults, set\n        the value as None.\n    block_swaps\n        Dictionary of orcablock swaps for the calculator. To enable new entries,\n        set the value as True. To remove entries from the defaults, set the\n        value as None.\n    additional_fields\n        Any additional fields to supply to the summarizer.\n    copy_files\n        Files to copy to the runtime directory.\n\n    Returns\n    -------\n    cclibSchema\n        Dictionary of results from [quacc.schemas.cclib.cclib_summarize_run][]\n    \"\"\"\n    inputs = merge_dicts(default_inputs, input_swaps)\n    blocks = merge_dicts(default_blocks, block_swaps)\n    orcasimpleinput = \" \".join(list(inputs.keys()))\n    orcablocks = \" \".join(list(blocks.keys()))\n\n    atoms.calc = ORCA(\n        profile=OrcaProfile(SETTINGS.ORCA_CMD),\n        charge=charge,\n        mult=spin_multiplicity,\n        orcasimpleinput=orcasimpleinput,\n        orcablocks=orcablocks,\n    )\n    atoms = run_calc(atoms, geom_file=GEOM_FILE, copy_files=copy_files)\n\n    return cclib_summarize_run(atoms, LOG_FILE, additional_fields=additional_fields)\n</code></pre>"},{"location":"reference/quacc/recipes/orca/core.html","title":"core","text":"<p>Core recipes for ORCA.</p>"},{"location":"reference/quacc/recipes/orca/core.html#quacc.recipes.orca.core.relax_job","title":"relax_job","text":"<pre><code>relax_job(\n    atoms,\n    charge,\n    spin_multiplicity,\n    xc=\"wb97x-d3bj\",\n    basis=\"def2-tzvp\",\n    run_freq=False,\n    orcasimpleinput=None,\n    orcablocks=None,\n    nprocs=None,\n    copy_files=None,\n)\n</code></pre> <p>Carry out a geometry optimization.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>Atoms object</p> </li> <li> <code>charge</code>             (<code>int</code>)         \u2013          <p>Charge of the system.</p> </li> <li> <code>spin_multiplicity</code>             (<code>int</code>)         \u2013          <p>Multiplicity of the system.</p> </li> <li> <code>xc</code>             (<code>str</code>, default:                 <code>'wb97x-d3bj'</code> )         \u2013          <p>Exchange-correlation functional</p> </li> <li> <code>basis</code>             (<code>str</code>, default:                 <code>'def2-tzvp'</code> )         \u2013          <p>Basis set</p> </li> <li> <code>run_freq</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>If a frequency calculation should be carried out.</p> </li> <li> <code>orcasimpleinput</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of <code>orcasimpleinput</code> swaps for the calculator. To enable new entries, set the value as True. To remove entries from the defaults, set the value as None. For a list of available keys, refer to the <code>ase.calculators.orca.ORCA</code> calculator.</p> </li> <li> <code>orcablocks</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of <code>orcablocks</code> swaps for the calculator. To enable new entries, set the value as True. To remove entries from the defaults, set the value as None. For a list of available keys, refer to the <code>ase.calculators.orca.ORCA</code> calculator.</p> </li> <li> <code>nprocs</code>             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>Number of processors to use. Defaults to the number of physical cores.</p> </li> <li> <code>copy_files</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>cclibSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.cclib.cclib_summarize_run</p> </li> </ul> Source code in <code>quacc/recipes/orca/core.py</code> <pre><code>@job\ndef relax_job(\n    atoms: Atoms,\n    charge: int,\n    spin_multiplicity: int,\n    xc: str = \"wb97x-d3bj\",\n    basis: str = \"def2-tzvp\",\n    run_freq: bool = False,\n    orcasimpleinput: dict[str, Any] | None = None,\n    orcablocks: dict[str, Any] | None = None,\n    nprocs: int | None = None,\n    copy_files: list[str] | None = None,\n) -&gt; cclibSchema:\n    \"\"\"\n    Carry out a geometry optimization.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    charge\n        Charge of the system.\n    spin_multiplicity\n        Multiplicity of the system.\n    xc\n        Exchange-correlation functional\n    basis\n        Basis set\n    run_freq\n        If a frequency calculation should be carried out.\n    orcasimpleinput\n        Dictionary of `orcasimpleinput` swaps for the calculator. To enable new\n        entries, set the value as True. To remove entries from the defaults, set\n        the value as None. For a list of available keys, refer to the\n        `ase.calculators.orca.ORCA` calculator.\n    orcablocks\n        Dictionary of `orcablocks` swaps for the calculator. To enable new entries,\n        set the value as True. To remove entries from the defaults, set the\n        value as None. For a list of available keys, refer to the\n        `ase.calculators.orca.ORCA` calculator.\n    nprocs\n        Number of processors to use. Defaults to the number of physical cores.\n    copy_files\n        Files to copy to the runtime directory.\n\n    Returns\n    -------\n    cclibSchema\n        Dictionary of results from [quacc.schemas.cclib.cclib_summarize_run][]\n    \"\"\"\n\n    nprocs = nprocs or psutil.cpu_count(logical=False)\n    default_inputs = {\n        xc: True,\n        basis: True,\n        \"opt\": True,\n        \"slowconv\": True,\n        \"normalprint\": True,\n        \"freq\": True if run_freq else None,\n        \"xyzfile\": True,\n    }\n    default_blocks = {f\"%pal nprocs {nprocs} end\": True}\n\n    return base_fn(\n        atoms,\n        charge=charge,\n        spin_multiplicity=spin_multiplicity,\n        default_inputs=default_inputs,\n        default_blocks=default_blocks,\n        input_swaps=orcasimpleinput,\n        block_swaps=orcablocks,\n        additional_fields={\"name\": \"ORCA Relax\"},\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/orca/core.html#quacc.recipes.orca.core.static_job","title":"static_job","text":"<pre><code>static_job(\n    atoms,\n    charge=0,\n    spin_multiplicity=1,\n    xc=\"wb97x-d3bj\",\n    basis=\"def2-tzvp\",\n    orcasimpleinput=None,\n    orcablocks=None,\n    nprocs=None,\n    copy_files=None,\n)\n</code></pre> <p>Carry out a single-point calculation.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>Atoms object</p> </li> <li> <code>charge</code>             (<code>int</code>, default:                 <code>0</code> )         \u2013          <p>Charge of the system.</p> </li> <li> <code>spin_multiplicity</code>             (<code>int</code>, default:                 <code>1</code> )         \u2013          <p>Multiplicity of the system.</p> </li> <li> <code>xc</code>             (<code>str</code>, default:                 <code>'wb97x-d3bj'</code> )         \u2013          <p>Exchange-correlation functional</p> </li> <li> <code>basis</code>             (<code>str</code>, default:                 <code>'def2-tzvp'</code> )         \u2013          <p>Basis set</p> </li> <li> <code>orcasimpleinput</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of <code>orcasimpleinput</code> swaps for the calculator. To enable new entries, set the value as True. To remove entries from the defaults, set the value as None. For a list of available keys, refer to the <code>ase.calculators.orca.ORCA</code> calculator.</p> </li> <li> <code>orcablocks</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of <code>orcablocks</code> swaps for the calculator. To enable new entries, set the value as True. To remove entries from the defaults, set the value as None. For a list of available keys, refer to the <code>ase.calculators.orca.ORCA</code> calculator.</p> </li> <li> <code>nprocs</code>             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>Number of processors to use. Defaults to the number of physical cores.</p> </li> <li> <code>copy_files</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>cclibSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.cclib.cclib_summarize_run</p> </li> </ul> Source code in <code>quacc/recipes/orca/core.py</code> <pre><code>@job\ndef static_job(\n    atoms: Atoms,\n    charge: int = 0,\n    spin_multiplicity: int = 1,\n    xc: str = \"wb97x-d3bj\",\n    basis: str = \"def2-tzvp\",\n    orcasimpleinput: dict[str, Any] | None = None,\n    orcablocks: dict[str, Any] | None = None,\n    nprocs: int | None = None,\n    copy_files: list[str] | None = None,\n) -&gt; cclibSchema:\n    \"\"\"\n    Carry out a single-point calculation.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    charge\n        Charge of the system.\n    spin_multiplicity\n        Multiplicity of the system.\n    xc\n        Exchange-correlation functional\n    basis\n        Basis set\n    orcasimpleinput\n        Dictionary of `orcasimpleinput` swaps for the calculator. To enable new\n        entries, set the value as True. To remove entries from the defaults, set\n        the value as None. For a list of available keys, refer to the\n        `ase.calculators.orca.ORCA` calculator.\n    orcablocks\n        Dictionary of `orcablocks` swaps for the calculator. To enable new entries,\n        set the value as True. To remove entries from the defaults, set the\n        value as None. For a list of available keys, refer to the\n        `ase.calculators.orca.ORCA` calculator.\n    nprocs\n        Number of processors to use. Defaults to the number of physical cores.\n    copy_files\n        Files to copy to the runtime directory.\n\n    Returns\n    -------\n    cclibSchema\n        Dictionary of results from [quacc.schemas.cclib.cclib_summarize_run][]\n    \"\"\"\n\n    nprocs = nprocs or psutil.cpu_count(logical=False)\n    default_inputs = {\n        xc: True,\n        basis: True,\n        \"sp\": True,\n        \"slowconv\": True,\n        \"normalprint\": True,\n        \"xyzfile\": True,\n    }\n    default_blocks = {f\"%pal nprocs {nprocs} end\": True}\n\n    return base_fn(\n        atoms,\n        charge,\n        spin_multiplicity,\n        default_inputs=default_inputs,\n        default_blocks=default_blocks,\n        input_swaps=orcasimpleinput,\n        block_swaps=orcablocks,\n        additional_fields={\"name\": \"ORCA Static\"},\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/psi4/_base.html","title":"_base","text":"<p>Base jobs for Psi4</p>"},{"location":"reference/quacc/recipes/psi4/_base.html#quacc.recipes.psi4._base.base_fn","title":"base_fn","text":"<pre><code>base_fn(\n    atoms,\n    charge=0,\n    spin_multiplicity=1,\n    calc_defaults=None,\n    calc_swaps=None,\n    additional_fields=None,\n    copy_files=None,\n)\n</code></pre> <p>Base function to carry out Psi4 recipes.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>Atoms object</p> </li> <li> <code>charge</code>             (<code>int</code>, default:                 <code>0</code> )         \u2013          <p>Charge of the system.</p> </li> <li> <code>spin_multiplicity</code>             (<code>int</code>, default:                 <code>1</code> )         \u2013          <p>Multiplicity of the system.</p> </li> <li> <code>calc_defaults</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>The default calculator parameters.</p> </li> <li> <code>calc_swaps</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Custom kwargs for the Psi4 calculator. Set a value to <code>None</code> to remove a pre-existing key entirely. For a list of available keys, refer to the <code>ase.calculators.psi4.Psi4</code> calculator.</p> </li> <li> <code>additional_fields</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Any additional fields to supply to the summarizer.</p> </li> <li> <code>copy_files</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.ase.summarize_run</p> </li> </ul> Source code in <code>quacc/recipes/psi4/_base.py</code> <pre><code>def base_fn(\n    atoms: Atoms,\n    charge: int = 0,\n    spin_multiplicity: int = 1,\n    calc_defaults: dict[str, Any] | None = None,\n    calc_swaps: dict[str, Any] | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    copy_files: list[str] | None = None,\n) -&gt; RunSchema:\n    \"\"\"\n    Base function to carry out Psi4 recipes.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    charge\n        Charge of the system.\n    spin_multiplicity\n        Multiplicity of the system.\n    calc_defaults\n        The default calculator parameters.\n    calc_swaps\n        Custom kwargs for the Psi4 calculator. Set a value to\n        `None` to remove a pre-existing key entirely. For a list of available\n        keys, refer to the `ase.calculators.psi4.Psi4` calculator.\n    additional_fields\n        Any additional fields to supply to the summarizer.\n    copy_files\n        Files to copy to the runtime directory.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results from [quacc.schemas.ase.summarize_run][]\n    \"\"\"\n    calc_flags = merge_dicts(calc_defaults, calc_swaps)\n\n    atoms.calc = Psi4(**calc_flags)\n    final_atoms = run_calc(atoms, copy_files=copy_files)\n\n    return summarize_run(\n        final_atoms,\n        input_atoms=atoms,\n        charge_and_multiplicity=(charge, spin_multiplicity),\n        additional_fields=additional_fields,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/psi4/core.html","title":"core","text":"<p>Core recipes for Psi4.</p>"},{"location":"reference/quacc/recipes/psi4/core.html#quacc.recipes.psi4.core.static_job","title":"static_job","text":"<pre><code>static_job(\n    atoms,\n    charge=0,\n    spin_multiplicity=1,\n    method=\"wb97x-v\",\n    basis=\"def2-tzvp\",\n    copy_files=None,\n    **kwargs\n)\n</code></pre> <p>Function to carry out a single-point calculation.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>Atoms object</p> </li> <li> <code>charge</code>             (<code>int</code>, default:                 <code>0</code> )         \u2013          <p>Charge of the system.</p> </li> <li> <code>spin_multiplicity</code>             (<code>int</code>, default:                 <code>1</code> )         \u2013          <p>Multiplicity of the system.</p> </li> <li> <code>method</code>             (<code>str</code>, default:                 <code>'wb97x-v'</code> )         \u2013          <p>The level of theory to use.</p> </li> <li> <code>basis</code>             (<code>str</code>, default:                 <code>'def2-tzvp'</code> )         \u2013          <p>Basis set</p> </li> <li> <code>copy_files</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> <li> <code>**kwargs</code>         \u2013          <p>Custom kwargs for the Psi4 calculator. Set a value to <code>None</code> to remove a pre-existing key entirely. For a list of available keys, refer to the <code>ase.calculators.psi4.Psi4</code> calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.ase.summarize_run</p> </li> </ul> Source code in <code>quacc/recipes/psi4/core.py</code> <pre><code>@job\n@requires(psi4, \"Psi4 not installed. Try conda install -c psi4 psi4\")\ndef static_job(\n    atoms: Atoms,\n    charge: int = 0,\n    spin_multiplicity: int = 1,\n    method: str = \"wb97x-v\",\n    basis: str = \"def2-tzvp\",\n    copy_files: list[str] | None = None,\n    **kwargs,\n) -&gt; RunSchema:\n    \"\"\"\n    Function to carry out a single-point calculation.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    charge\n        Charge of the system.\n    spin_multiplicity\n        Multiplicity of the system.\n    method\n        The level of theory to use.\n    basis\n        Basis set\n    copy_files\n        Files to copy to the runtime directory.\n    **kwargs\n        Custom kwargs for the Psi4 calculator. Set a value to\n        `None` to remove a pre-existing key entirely. For a list of available\n        keys, refer to the `ase.calculators.psi4.Psi4` calculator.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results from [quacc.schemas.ase.summarize_run][]\n    \"\"\"\n\n    calc_defaults = {\n        \"mem\": \"16GB\",\n        \"num_threads\": \"max\",\n        \"method\": method,\n        \"basis\": basis,\n        \"charge\": charge,\n        \"multiplicity\": spin_multiplicity,\n        \"reference\": \"uks\" if spin_multiplicity &gt; 1 else \"rks\",\n    }\n    return base_fn(\n        atoms,\n        charge=charge,\n        spin_multiplicity=spin_multiplicity,\n        calc_defaults=calc_defaults,\n        calc_swaps=kwargs,\n        additional_fields={\"name\": \"Psi4 Static\"},\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/qchem/_base.html","title":"_base","text":"<p>Base jobs for Q-Chem</p>"},{"location":"reference/quacc/recipes/qchem/_base.html#quacc.recipes.qchem._base.base_fn","title":"base_fn","text":"<pre><code>base_fn(\n    atoms,\n    charge=0,\n    spin_multiplicity=1,\n    defaults=None,\n    additional_fields=None,\n    copy_files=None,\n)\n</code></pre> <p>Base job function used for Q-Chem recipes that don't rely on ASE optimizers or other ASE dynamics classes.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>Atoms object</p> </li> <li> <code>charge</code>             (<code>int</code>, default:                 <code>0</code> )         \u2013          <p>Charge of the system.</p> </li> <li> <code>spin_multiplicity</code>             (<code>int</code>, default:                 <code>1</code> )         \u2013          <p>Multiplicity of the system.</p> </li> <li> <code>defaults</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>The default parameters for the recipe.</p> </li> <li> <code>additional_fields</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Any additional fields to set in the summary.</p> </li> <li> <code>copy_files</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.ase.summarize_run</p> </li> </ul> Source code in <code>quacc/recipes/qchem/_base.py</code> <pre><code>def base_fn(\n    atoms: Atoms,\n    charge: int = 0,\n    spin_multiplicity: int = 1,\n    defaults: dict[str, Any] | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    copy_files: list[str] | None = None,\n) -&gt; RunSchema:\n    \"\"\"\n    Base job function used for Q-Chem recipes that don't rely on ASE optimizers or other\n    ASE dynamics classes.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    charge\n        Charge of the system.\n    spin_multiplicity\n        Multiplicity of the system.\n    defaults\n        The default parameters for the recipe.\n    additional_fields\n        Any additional fields to set in the summary.\n    copy_files\n        Files to copy to the runtime directory.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results from [quacc.schemas.ase.summarize_run][]\n    \"\"\"\n\n    qchem_flags = remove_dict_nones(defaults)\n\n    atoms.calc = QChem(atoms, **qchem_flags)\n    final_atoms = run_calc(atoms, copy_files=copy_files)\n\n    return summarize_run(\n        final_atoms,\n        input_atoms=atoms,\n        charge_and_multiplicity=(charge, spin_multiplicity),\n        additional_fields=additional_fields,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/qchem/_base.html#quacc.recipes.qchem._base.base_opt_fn","title":"base_opt_fn","text":"<pre><code>base_opt_fn(\n    atoms,\n    charge=0,\n    spin_multiplicity=1,\n    calc_defaults=None,\n    opt_defaults=None,\n    opt_params=None,\n    additional_fields=None,\n    copy_files=None,\n)\n</code></pre> <p>Base function for Q-Chem recipes that involve ASE optimizers.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>Atoms object</p> </li> <li> <code>charge</code>             (<code>int</code>, default:                 <code>0</code> )         \u2013          <p>Charge of the system.</p> </li> <li> <code>spin_multiplicity</code>             (<code>int</code>, default:                 <code>1</code> )         \u2013          <p>Multiplicity of the system.</p> </li> <li> <code>calc_defaults</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Default arguments for the Q-Chem calculator.</p> </li> <li> <code>opt_defaults</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Default arguments for the ASE optimizer.</p> </li> <li> <code>opt_params</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom kwargs for quacc.runners.ase.run_opt</p> </li> <li> <code>copy_files</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OptSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.ase.summarize_opt_run</p> </li> </ul> Source code in <code>quacc/recipes/qchem/_base.py</code> <pre><code>def base_opt_fn(\n    atoms: Atoms,\n    charge: int = 0,\n    spin_multiplicity: int = 1,\n    calc_defaults: dict[str, Any] | None = None,\n    opt_defaults: dict[str, Any] | None = None,\n    opt_params: dict[str, Any] | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    copy_files: list[str] | None = None,\n) -&gt; OptSchema:\n    \"\"\"\n    Base function for Q-Chem recipes that involve ASE optimizers.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    charge\n        Charge of the system.\n    spin_multiplicity\n        Multiplicity of the system.\n    calc_defaults\n        Default arguments for the Q-Chem calculator.\n    opt_defaults\n        Default arguments for the ASE optimizer.\n    opt_params\n        Dictionary of custom kwargs for [quacc.runners.ase.run_opt][]\n    copy_files\n        Files to copy to the runtime directory.\n\n    Returns\n    -------\n    OptSchema\n        Dictionary of results from [quacc.schemas.ase.summarize_opt_run][]\n    \"\"\"\n    # TODO:\n    #   - passing initial Hessian?\n\n    qchem_flags = remove_dict_nones(calc_defaults)\n    opt_flags = merge_dicts(opt_defaults, opt_params)\n\n    atoms.calc = QChem(atoms, **qchem_flags)\n    dyn = run_opt(atoms, copy_files=copy_files, **opt_flags)\n\n    return summarize_opt_run(\n        dyn,\n        charge_and_multiplicity=(charge, spin_multiplicity),\n        additional_fields=additional_fields,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/qchem/core.html","title":"core","text":"<p>Core recipes for the Q-Chem.</p>"},{"location":"reference/quacc/recipes/qchem/core.html#quacc.recipes.qchem.core.freq_job","title":"freq_job","text":"<pre><code>freq_job(\n    atoms,\n    charge=0,\n    spin_multiplicity=1,\n    method=\"wb97mv\",\n    basis=\"def2-svpd\",\n    scf_algorithm=\"diis\",\n    pcm_dielectric=None,\n    smd_solvent=None,\n    n_cores=None,\n    overwrite_inputs=None,\n    copy_files=None,\n)\n</code></pre> <p>Perform a frequency calculation on a molecular structure.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>Atoms object</p> </li> <li> <code>charge</code>             (<code>int</code>, default:                 <code>0</code> )         \u2013          <p>Charge of the system.</p> </li> <li> <code>spin_multiplicity</code>             (<code>int</code>, default:                 <code>1</code> )         \u2013          <p>Multiplicity of the system.</p> </li> <li> <code>method</code>             (<code>str</code>, default:                 <code>'wb97mv'</code> )         \u2013          <p>DFT exchange-correlation functional or other electronic structure method. Defaults to wB97M-V.</p> </li> <li> <code>basis</code>             (<code>str</code>, default:                 <code>'def2-svpd'</code> )         \u2013          <p>Basis set. Defaults to def2-SVPD.</p> </li> <li> <code>scf_algorithm</code>             (<code>str</code>, default:                 <code>'diis'</code> )         \u2013          <p>Algorithm used to converge the SCF. Defaults to \"diis\", but for particularly difficult cases, \"gdm\" should be employed instead.</p> </li> <li> <code>pcm_dielectric</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>Dielectric constant of the optional polarizable continuum implicit solvation model. Defaults to None, in which case PCM will not be employed.</p> </li> <li> <code>smd_solvent</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>Solvent to use for SMD implicit solvation model. Examples include \"water\", \"ethanol\", \"methanol\", and \"acetonitrile\". Refer to the Q-Chem manual for a complete list of solvents available. Defaults to None, in which case SMD will not be employed.</p> </li> <li> <code>n_cores</code>             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>Number of cores to use for the Q-Chem calculation. Defaults to use all cores available on a given node.</p> </li> <li> <code>overwrite_inputs</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary passed to <code>pymatgen.io.qchem.QChemDictSet</code> which can modify default values set therein as well as set additional Q-Chem parameters. See QChemDictSet documentation for more details.</p> </li> <li> <code>copy_files</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.ase.summarize_run</p> </li> </ul> Source code in <code>quacc/recipes/qchem/core.py</code> <pre><code>@job\ndef freq_job(\n    atoms: Atoms,\n    charge: int = 0,\n    spin_multiplicity: int = 1,\n    method: str = \"wb97mv\",\n    basis: str = \"def2-svpd\",\n    scf_algorithm: str = \"diis\",\n    pcm_dielectric: str | None = None,\n    smd_solvent: str | None = None,\n    n_cores: int | None = None,\n    overwrite_inputs: dict[str, Any] | None = None,\n    copy_files: list[str] | None = None,\n) -&gt; RunSchema:\n    \"\"\"\n    Perform a frequency calculation on a molecular structure.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    charge\n        Charge of the system.\n    spin_multiplicity\n        Multiplicity of the system.\n    method\n        DFT exchange-correlation functional or other electronic structure\n        method. Defaults to wB97M-V.\n    basis\n        Basis set. Defaults to def2-SVPD.\n    scf_algorithm\n        Algorithm used to converge the SCF. Defaults to \"diis\", but for\n        particularly difficult cases, \"gdm\" should be employed instead.\n    pcm_dielectric\n        Dielectric constant of the optional polarizable continuum implicit\n        solvation model. Defaults to None, in which case PCM will not be\n        employed.\n    smd_solvent\n        Solvent to use for SMD implicit solvation model. Examples include\n        \"water\", \"ethanol\", \"methanol\", and \"acetonitrile\". Refer to the Q-Chem\n        manual for a complete list of solvents available. Defaults to None, in\n        which case SMD will not be employed.\n    n_cores\n        Number of cores to use for the Q-Chem calculation. Defaults to use all\n        cores available on a given node.\n    overwrite_inputs\n        Dictionary passed to `pymatgen.io.qchem.QChemDictSet` which can modify\n        default values set therein as well as set additional Q-Chem parameters.\n        See QChemDictSet documentation for more details.\n    copy_files\n        Files to copy to the runtime directory.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results from [quacc.schemas.ase.summarize_run][]\n    \"\"\"\n\n    defaults = {\n        \"job_type\": \"freq\",\n        \"basis_set\": basis,\n        \"scf_algorithm\": scf_algorithm,\n        \"method\": method,\n        \"charge\": charge,\n        \"spin_multiplicity\": spin_multiplicity,\n        \"cores\": n_cores or psutil.cpu_count(logical=False),\n        \"qchem_input_params\": {\n            \"pcm_dielectric\": pcm_dielectric,\n            \"smd_solvent\": smd_solvent,\n            \"overwrite_inputs\": overwrite_inputs,\n            \"max_scf_cycles\": 200 if scf_algorithm.lower() == \"gdm\" else None,\n        },\n    }\n    return base_fn(\n        atoms,\n        charge=charge,\n        spin_multiplicity=spin_multiplicity,\n        defaults=defaults,\n        copy_files=copy_files,\n        additional_fields={\"name\": \"Q-Chem Frequency\"},\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/qchem/core.html#quacc.recipes.qchem.core.relax_job","title":"relax_job","text":"<pre><code>relax_job(\n    atoms,\n    charge=0,\n    spin_multiplicity=1,\n    method=\"wb97mv\",\n    basis=\"def2-svpd\",\n    scf_algorithm=\"diis\",\n    pcm_dielectric=None,\n    smd_solvent=None,\n    n_cores=None,\n    overwrite_inputs=None,\n    opt_params=None,\n    copy_files=None,\n)\n</code></pre> <p>Optimize aka \"relax\" a molecular structure with an ASE optimizer.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>Atoms object</p> </li> <li> <code>charge</code>             (<code>int</code>, default:                 <code>0</code> )         \u2013          <p>Charge of the system.</p> </li> <li> <code>spin_multiplicity</code>             (<code>int</code>, default:                 <code>1</code> )         \u2013          <p>Multiplicity of the system.</p> </li> <li> <code>method</code>             (<code>str</code>, default:                 <code>'wb97mv'</code> )         \u2013          <p>DFT exchange-correlation functional or other electronic structure method. Defaults to wB97M-V.</p> </li> <li> <code>basis</code>             (<code>str</code>, default:                 <code>'def2-svpd'</code> )         \u2013          <p>Basis set. Defaults to def2-SVPD.</p> </li> <li> <code>scf_algorithm</code>             (<code>str</code>, default:                 <code>'diis'</code> )         \u2013          <p>Algorithm used to converge the SCF. Defaults to \"diis\", but for particularly difficult cases, \"gdm\" should be employed instead.</p> </li> <li> <code>pcm_dielectric</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>Dielectric constant of the optional polarizable continuum implicit solvation model. Defaults to None, in which case PCM will not be employed.</p> </li> <li> <code>smd_solvent</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>Solvent to use for SMD implicit solvation model. Examples include \"water\", \"ethanol\", \"methanol\", and \"acetonitrile\". Refer to the Q-Chem manual for a complete list of solvents available. Defaults to None, in which case SMD will not be employed.</p> </li> <li> <code>n_cores</code>             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>Number of cores to use for the Q-Chem calculation. Defaults to use all cores available on a given node.</p> </li> <li> <code>overwrite_inputs</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary passed to <code>pymatgen.io.qchem.QChemDictSet</code> which can modify default values set therein as well as set additional Q-Chem parameters. See QChemDictSet documentation for more details.</p> </li> <li> <code>opt_params</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom kwargs for quacc.runners.ase.run_opt</p> </li> <li> <code>copy_files</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OptSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.ase.summarize_opt_run</p> </li> </ul> Source code in <code>quacc/recipes/qchem/core.py</code> <pre><code>@job\ndef relax_job(\n    atoms: Atoms,\n    charge: int = 0,\n    spin_multiplicity: int = 1,\n    method: str = \"wb97mv\",\n    basis: str = \"def2-svpd\",\n    scf_algorithm: str = \"diis\",\n    pcm_dielectric: str | None = None,\n    smd_solvent: str | None = None,\n    n_cores: int | None = None,\n    overwrite_inputs: dict[str, Any] | None = None,\n    opt_params: dict[str, Any] | None = None,\n    copy_files: list[str] | None = None,\n) -&gt; OptSchema:\n    \"\"\"\n    Optimize aka \"relax\" a molecular structure with an ASE optimizer.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    charge\n        Charge of the system.\n    spin_multiplicity\n        Multiplicity of the system.\n    method\n        DFT exchange-correlation functional or other electronic structure\n        method. Defaults to wB97M-V.\n    basis\n        Basis set. Defaults to def2-SVPD.\n    scf_algorithm\n        Algorithm used to converge the SCF. Defaults to \"diis\", but for\n        particularly difficult cases, \"gdm\" should be employed instead.\n    pcm_dielectric\n        Dielectric constant of the optional polarizable continuum implicit\n        solvation model. Defaults to None, in which case PCM will not be\n        employed.\n    smd_solvent\n        Solvent to use for SMD implicit solvation model. Examples include\n        \"water\", \"ethanol\", \"methanol\", and \"acetonitrile\". Refer to the Q-Chem\n        manual for a complete list of solvents available. Defaults to None, in\n        which case SMD will not be employed.\n    n_cores\n        Number of cores to use for the Q-Chem calculation. Defaults to use all\n        cores available on a given node.\n    overwrite_inputs\n        Dictionary passed to `pymatgen.io.qchem.QChemDictSet` which can modify\n        default values set therein as well as set additional Q-Chem parameters.\n        See QChemDictSet documentation for more details.\n    opt_params\n        Dictionary of custom kwargs for [quacc.runners.ase.run_opt][]\n    copy_files\n        Files to copy to the runtime directory.\n\n    Returns\n    -------\n    OptSchema\n        Dictionary of results from [quacc.schemas.ase.summarize_opt_run][]\n    \"\"\"\n\n    calc_defaults = {\n        \"basis_set\": basis,\n        \"scf_algorithm\": scf_algorithm,\n        \"method\": method,\n        \"charge\": charge,\n        \"spin_multiplicity\": spin_multiplicity,\n        \"cores\": n_cores or psutil.cpu_count(logical=False),\n        \"qchem_input_params\": {\n            \"pcm_dielectric\": pcm_dielectric,\n            \"smd_solvent\": smd_solvent,\n            \"overwrite_inputs\": overwrite_inputs,\n            \"max_scf_cycles\": 200 if scf_algorithm.lower() == \"gdm\" else None,\n        },\n    }\n    opt_defaults = {\n        \"fmax\": 0.01,\n        \"max_steps\": 1000,\n        \"optimizer\": Sella if has_sella else FIRE,\n        \"optimizer_kwargs\": {\"use_TRICs\": False},\n    }\n\n    return base_opt_fn(\n        atoms,\n        charge=charge,\n        spin_multiplicity=spin_multiplicity,\n        calc_defaults=calc_defaults,\n        opt_defaults=opt_defaults,\n        opt_params=opt_params,\n        additional_fields={\"name\": \"Q-Chem Optimization\"},\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/qchem/core.html#quacc.recipes.qchem.core.static_job","title":"static_job","text":"<pre><code>static_job(\n    atoms,\n    charge=0,\n    spin_multiplicity=1,\n    method=\"wb97mv\",\n    basis=\"def2-tzvpd\",\n    scf_algorithm=\"diis\",\n    pcm_dielectric=None,\n    smd_solvent=None,\n    n_cores=None,\n    overwrite_inputs=None,\n    copy_files=None,\n)\n</code></pre> <p>Carry out a single-point calculation.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>Atoms object</p> </li> <li> <code>charge</code>             (<code>int</code>, default:                 <code>0</code> )         \u2013          <p>Charge of the system.</p> </li> <li> <code>spin_multiplicity</code>             (<code>int</code>, default:                 <code>1</code> )         \u2013          <p>Multiplicity of the system.</p> </li> <li> <code>method</code>             (<code>str</code>, default:                 <code>'wb97mv'</code> )         \u2013          <p>DFT exchange-correlation functional or other electronic structure method. Defaults to wB97M-V.</p> </li> <li> <code>basis</code>             (<code>str</code>, default:                 <code>'def2-tzvpd'</code> )         \u2013          <p>Basis set. Defaults to def2-TZVPD.</p> </li> <li> <code>scf_algorithm</code>             (<code>str</code>, default:                 <code>'diis'</code> )         \u2013          <p>Algorithm used to converge the SCF. Defaults to \"diis\", but for particularly difficult cases, \"gdm\" should be employed instead.</p> </li> <li> <code>pcm_dielectric</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>Dielectric constant of the optional polarizable continuum implicit solvation model. Defaults to None, in which case PCM will not be employed.</p> </li> <li> <code>smd_solvent</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>Solvent to use for SMD implicit solvation model. Examples include \"water\", \"ethanol\", \"methanol\", and \"acetonitrile\". Refer to the Q-Chem manual for a complete list of solvents available. Defaults to None, in which case SMD will not be employed.</p> </li> <li> <code>n_cores</code>             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>Number of cores to use for the Q-Chem calculation. Defaults to use all cores available on a given node.</p> </li> <li> <code>overwrite_inputs</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary passed to <code>pymatgen.io.qchem.QChemDictSet</code> which can modify default values set therein as well as set additional Q-Chem parameters. See QChemDictSet documentation for more details.</p> </li> <li> <code>copy_files</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.ase.summarize_run</p> </li> </ul> Source code in <code>quacc/recipes/qchem/core.py</code> <pre><code>@job\ndef static_job(\n    atoms: Atoms,\n    charge: int = 0,\n    spin_multiplicity: int = 1,\n    method: str = \"wb97mv\",\n    basis: str = \"def2-tzvpd\",\n    scf_algorithm: str = \"diis\",\n    pcm_dielectric: str | None = None,\n    smd_solvent: str | None = None,\n    n_cores: int | None = None,\n    overwrite_inputs: dict[str, Any] | None = None,\n    copy_files: list[str] | None = None,\n) -&gt; RunSchema:\n    \"\"\"\n    Carry out a single-point calculation.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    charge\n        Charge of the system.\n    spin_multiplicity\n        Multiplicity of the system.\n    method\n        DFT exchange-correlation functional or other electronic structure\n        method. Defaults to wB97M-V.\n    basis\n        Basis set. Defaults to def2-TZVPD.\n    scf_algorithm\n        Algorithm used to converge the SCF. Defaults to \"diis\", but for\n        particularly difficult cases, \"gdm\" should be employed instead.\n    pcm_dielectric\n        Dielectric constant of the optional polarizable continuum implicit\n        solvation model. Defaults to None, in which case PCM will not be\n        employed.\n    smd_solvent\n        Solvent to use for SMD implicit solvation model. Examples include\n        \"water\", \"ethanol\", \"methanol\", and \"acetonitrile\". Refer to the Q-Chem\n        manual for a complete list of solvents available. Defaults to None, in\n        which case SMD will not be employed.\n    n_cores\n        Number of cores to use for the Q-Chem calculation. Defaults to use all\n        cores available on a given node.\n    overwrite_inputs\n        Dictionary passed to `pymatgen.io.qchem.QChemDictSet` which can modify\n        default values set therein as well as set additional Q-Chem parameters.\n        See QChemDictSet documentation for more details.\n    copy_files\n        Files to copy to the runtime directory.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results from [quacc.schemas.ase.summarize_run][]\n    \"\"\"\n    defaults = {\n        \"basis_set\": basis,\n        \"scf_algorithm\": scf_algorithm,\n        \"method\": method,\n        \"charge\": charge,\n        \"spin_multiplicity\": spin_multiplicity,\n        \"cores\": n_cores or psutil.cpu_count(logical=False),\n        \"qchem_input_params\": {\n            \"pcm_dielectric\": pcm_dielectric,\n            \"smd_solvent\": smd_solvent,\n            \"overwrite_inputs\": overwrite_inputs,\n            \"max_scf_cycles\": 200 if scf_algorithm.lower() == \"gdm\" else None,\n            \"nbo_params\": {\"version\": 7} if SETTINGS.QCHEM_NBO_EXE else None,\n        },\n    }\n\n    return base_fn(\n        atoms,\n        charge,\n        spin_multiplicity,\n        defaults=defaults,\n        additional_fields={\"name\": \"Q-Chem Static\"},\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/qchem/ts.html","title":"ts","text":"<p>Transition state recipes for the Q-Chem.</p>"},{"location":"reference/quacc/recipes/qchem/ts.html#quacc.recipes.qchem.ts.irc_job","title":"irc_job","text":"<pre><code>irc_job(\n    atoms,\n    charge,\n    spin_multiplicity,\n    direction=\"forward\",\n    method=\"wb97mv\",\n    basis=\"def2-svpd\",\n    scf_algorithm=\"diis\",\n    pcm_dielectric=None,\n    smd_solvent=None,\n    n_cores=None,\n    overwrite_inputs=None,\n    opt_params=None,\n    copy_files=None,\n)\n</code></pre> <p>IRC optimize a molecular structure.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>Atoms object</p> </li> <li> <code>charge</code>             (<code>int</code>)         \u2013          <p>Charge of the system.</p> </li> <li> <code>spin_multiplicity</code>             (<code>int</code>)         \u2013          <p>Multiplicity of the system.</p> </li> <li> <code>direction</code>             (<code>Literal['forward', 'reverse']</code>, default:                 <code>'forward'</code> )         \u2013          <p>Direction of the IRC. Should be \"forward\" or \"reverse\".</p> </li> <li> <code>method</code>             (<code>str</code>, default:                 <code>'wb97mv'</code> )         \u2013          <p>DFT exchange-correlation functional or other electronic structure method. Defaults to wB97M-V.</p> </li> <li> <code>basis</code>             (<code>str</code>, default:                 <code>'def2-svpd'</code> )         \u2013          <p>Basis set. Defaults to def2-SVPD.</p> </li> <li> <code>scf_algorithm</code>             (<code>str</code>, default:                 <code>'diis'</code> )         \u2013          <p>Algorithm used to converge the SCF. Defaults to \"diis\", but for particularly difficult cases, \"gdm\" should be employed instead.</p> </li> <li> <code>pcm_dielectric</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>Dielectric constant of the optional polarizable continuum implicit solvation model. Defaults to None, in which case PCM will not be employed.</p> </li> <li> <code>smd_solvent</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>Solvent to use for SMD implicit solvation model. Examples include \"water\", \"ethanol\", \"methanol\", and \"acetonitrile\". Refer to the Q-Chem manual for a complete list of solvents available. Defaults to None, in which case SMD will not be employed.</p> </li> <li> <code>n_cores</code>             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>Number of cores to use for the Q-Chem calculation. Defaults to use all cores available on a given node.</p> </li> <li> <code>overwrite_inputs</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary passed to <code>pymatgen.io.qchem.QChemDictSet</code> which can modify default values set therein as well as set additional Q-Chem parameters. See QChemDictSet documentation for more details.</p> </li> <li> <code>opt_params</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom kwargs for quacc.runners.ase.run_opt</p> </li> <li> <code>copy_files</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OptSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.ase.summarize_opt_run</p> </li> </ul> Source code in <code>quacc/recipes/qchem/ts.py</code> <pre><code>@job\n@requires(has_sella, \"Sella must be installed. Refer to the quacc documentation.\")\ndef irc_job(\n    atoms: Atoms,\n    charge: int,\n    spin_multiplicity: int,\n    direction: Literal[\"forward\", \"reverse\"] = \"forward\",\n    method: str = \"wb97mv\",\n    basis: str = \"def2-svpd\",\n    scf_algorithm: str = \"diis\",\n    pcm_dielectric: str | None = None,\n    smd_solvent: str | None = None,\n    n_cores: int | None = None,\n    overwrite_inputs: dict[str, Any] | None = None,\n    opt_params: dict[str, Any] | None = None,\n    copy_files: list[str] | None = None,\n) -&gt; OptSchema:\n    \"\"\"\n    IRC optimize a molecular structure.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    charge\n        Charge of the system.\n    spin_multiplicity\n        Multiplicity of the system.\n    direction\n        Direction of the IRC. Should be \"forward\" or \"reverse\".\n    method\n        DFT exchange-correlation functional or other electronic structure\n        method. Defaults to wB97M-V.\n    basis\n        Basis set. Defaults to def2-SVPD.\n    scf_algorithm\n        Algorithm used to converge the SCF. Defaults to \"diis\", but for\n        particularly difficult cases, \"gdm\" should be employed instead.\n    pcm_dielectric\n        Dielectric constant of the optional polarizable continuum implicit\n        solvation model. Defaults to None, in which case PCM will not be\n        employed.\n    smd_solvent\n        Solvent to use for SMD implicit solvation model. Examples include\n        \"water\", \"ethanol\", \"methanol\", and \"acetonitrile\". Refer to the Q-Chem\n        manual for a complete list of solvents available. Defaults to None, in\n        which case SMD will not be employed.\n    n_cores\n        Number of cores to use for the Q-Chem calculation. Defaults to use all\n        cores available on a given node.\n    overwrite_inputs\n        Dictionary passed to `pymatgen.io.qchem.QChemDictSet` which can modify\n        default values set therein as well as set additional Q-Chem parameters.\n        See QChemDictSet documentation for more details.\n    opt_params\n        Dictionary of custom kwargs for [quacc.runners.ase.run_opt][]\n    copy_files\n        Files to copy to the runtime directory.\n\n    Returns\n    -------\n    OptSchema\n        Dictionary of results from [quacc.schemas.ase.summarize_opt_run][]\n    \"\"\"\n\n    calc_defaults = {\n        \"basis_set\": basis,\n        \"scf_algorithm\": scf_algorithm,\n        \"method\": method,\n        \"charge\": charge,\n        \"spin_multiplicity\": spin_multiplicity,\n        \"cores\": n_cores or psutil.cpu_count(logical=False),\n        \"qchem_input_params\": {\n            \"pcm_dielectric\": pcm_dielectric,\n            \"smd_solvent\": smd_solvent,\n            \"overwrite_inputs\": overwrite_inputs,\n            \"max_scf_cycles\": 200 if scf_algorithm.lower() == \"gdm\" else None,\n        },\n    }\n    opt_defaults = {\n        \"fmax\": 0.01,\n        \"max_steps\": 1000,\n        \"optimizer\": IRC,\n        \"optimizer_kwargs\": {\"keep_going\": True},\n        \"run_kwargs\": {\"direction\": direction},\n    }\n    if opt_params and opt_params.get(\"optimizer\", IRC) is not IRC:\n        raise ValueError(\"Only Sella's IRC should be used for IRC optimization.\")\n\n    return base_opt_fn(\n        atoms,\n        charge,\n        spin_multiplicity,\n        calc_defaults=calc_defaults,\n        opt_defaults=opt_defaults,\n        opt_params=opt_params,\n        additional_fields={\"name\": \"Q-Chem IRC\"},\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/qchem/ts.html#quacc.recipes.qchem.ts.quasi_irc_job","title":"quasi_irc_job","text":"<pre><code>quasi_irc_job(\n    atoms,\n    charge,\n    spin_multiplicity,\n    direction=\"forward\",\n    method=\"wb97mv\",\n    basis=\"def2-svpd\",\n    scf_algorithm=\"diis\",\n    pcm_dielectric=None,\n    smd_solvent=None,\n    n_cores=None,\n    overwrite_inputs=None,\n    irc_opt_params=None,\n    relax_opt_params=None,\n    copy_files=None,\n)\n</code></pre> <p>Quasi-IRC optimize a molecular structure. Runs <code>irc_job</code> for 10 steps (default) followed by <code>relax_job</code>.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>Atoms object.</p> </li> <li> <code>charge</code>             (<code>int</code>)         \u2013          <p>Charge of the system.</p> </li> <li> <code>spin_multiplicity</code>             (<code>int</code>)         \u2013          <p>Multiplicity of the system.</p> </li> <li> <code>direction</code>             (<code>Literal['forward', 'reverse']</code>, default:                 <code>'forward'</code> )         \u2013          <p>Direction of the IRC. Should be \"forward\" or \"reverse\".</p> </li> <li> <code>irc_opt_params</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of opt_params kwargs for the irc_job.</p> </li> <li> <code>relax_opt_params</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of opt_params kwargs for the relax_job.</p> </li> <li> <code>copy_files</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OptSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.ase.summarize_opt_run</p> </li> </ul> Source code in <code>quacc/recipes/qchem/ts.py</code> <pre><code>@job\n@requires(has_sella, \"Sella must be installed. Refer to the quacc documentation.\")\ndef quasi_irc_job(\n    atoms: Atoms,\n    charge: int,\n    spin_multiplicity: int,\n    direction: Literal[\"forward\", \"reverse\"] = \"forward\",\n    method: str = \"wb97mv\",\n    basis: str = \"def2-svpd\",\n    scf_algorithm: str = \"diis\",\n    pcm_dielectric: str | None = None,\n    smd_solvent: str | None = None,\n    n_cores: int | None = None,\n    overwrite_inputs: dict[str, Any] | None = None,\n    irc_opt_params: dict[str, Any] | None = None,\n    relax_opt_params: dict[str, Any] | None = None,\n    copy_files: list[str] | None = None,\n) -&gt; OptSchema:\n    \"\"\"\n    Quasi-IRC optimize a molecular structure. Runs `irc_job` for 10 steps (default)\n    followed by `relax_job`.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object.\n    charge\n        Charge of the system.\n    spin_multiplicity\n        Multiplicity of the system.\n    direction\n        Direction of the IRC. Should be \"forward\" or \"reverse\".\n    irc_opt_params\n        Dictionary of opt_params kwargs for the irc_job.\n    relax_opt_params\n        Dictionary of opt_params kwargs for the relax_job.\n    copy_files\n        Files to copy to the runtime directory.\n\n    Returns\n    -------\n    OptSchema\n        Dictionary of results from [quacc.schemas.ase.summarize_opt_run][]\n    \"\"\"\n\n    default_settings = SETTINGS.model_copy()\n\n    irc_opt_params_defaults = {\"fmax\": 100, \"max_steps\": 10}\n    irc_opt_params = merge_dicts(irc_opt_params_defaults, irc_opt_params)\n\n    SETTINGS.CHECK_CONVERGENCE = False\n    irc_summary = irc_job.__wrapped__(\n        atoms,\n        charge,\n        spin_multiplicity,\n        direction=direction,\n        method=method,\n        basis=basis,\n        scf_algorithm=scf_algorithm,\n        pcm_dielectric=pcm_dielectric,\n        smd_solvent=smd_solvent,\n        n_cores=n_cores,\n        overwrite_inputs=overwrite_inputs,\n        opt_params=irc_opt_params,\n        copy_files=copy_files,\n    )\n\n    SETTINGS.CHECK_CONVERGENCE = default_settings.CHECK_CONVERGENCE\n    relax_summary = relax_job.__wrapped__(\n        irc_summary[\"atoms\"],\n        charge,\n        spin_multiplicity,\n        method=method,\n        basis=basis,\n        scf_algorithm=scf_algorithm,\n        pcm_dielectric=pcm_dielectric,\n        smd_solvent=smd_solvent,\n        n_cores=n_cores,\n        overwrite_inputs=overwrite_inputs,\n        opt_params=relax_opt_params,\n    )\n\n    relax_summary[\"initial_irc\"] = irc_summary\n\n    return relax_summary\n</code></pre>"},{"location":"reference/quacc/recipes/qchem/ts.html#quacc.recipes.qchem.ts.ts_job","title":"ts_job","text":"<pre><code>ts_job(\n    atoms,\n    charge,\n    spin_multiplicity,\n    method=\"wb97mv\",\n    basis=\"def2-svpd\",\n    scf_algorithm=\"diis\",\n    pcm_dielectric=None,\n    smd_solvent=None,\n    n_cores=None,\n    overwrite_inputs=None,\n    opt_params=None,\n    copy_files=None,\n)\n</code></pre> <p>TS optimize a molecular structure.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>Atoms object</p> </li> <li> <code>charge</code>             (<code>int</code>)         \u2013          <p>Charge of the system.</p> </li> <li> <code>spin_multiplicity</code>             (<code>int</code>)         \u2013          <p>Multiplicity of the system.</p> </li> <li> <code>method</code>             (<code>str</code>, default:                 <code>'wb97mv'</code> )         \u2013          <p>DFT exchange-correlation functional or other electronic structure method. Defaults to wB97M-V.</p> </li> <li> <code>basis</code>             (<code>str</code>, default:                 <code>'def2-svpd'</code> )         \u2013          <p>Basis set. Defaults to def2-SVPD.</p> </li> <li> <code>scf_algorithm</code>             (<code>str</code>, default:                 <code>'diis'</code> )         \u2013          <p>Algorithm used to converge the SCF. Defaults to \"diis\", but for particularly difficult cases, \"gdm\" should be employed instead.</p> </li> <li> <code>pcm_dielectric</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>Dielectric constant of the optional polarizable continuum implicit solvation model. Defaults to None, in which case PCM will not be employed.</p> </li> <li> <code>smd_solvent</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>Solvent to use for SMD implicit solvation model. Examples include \"water\", \"ethanol\", \"methanol\", and \"acetonitrile\". Refer to the Q-Chem manual for a complete list of solvents available. Defaults to None, in which case SMD will not be employed.</p> </li> <li> <code>n_cores</code>             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>Number of cores to use for the Q-Chem calculation. Defaults to use all cores available on a given node.</p> </li> <li> <code>overwrite_inputs</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary passed to <code>pymatgen.io.qchem.QChemDictSet</code> which can modify default values set therein as well as set additional Q-Chem parameters. See QChemDictSet documentation for more details.</p> </li> <li> <code>opt_params</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom kwargs for quacc.runners.ase.run_opt</p> </li> <li> <code>copy_files</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OptSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.ase.summarize_opt_run</p> </li> </ul> Source code in <code>quacc/recipes/qchem/ts.py</code> <pre><code>@job\n@requires(has_sella, \"Sella must be installed. Refer to the quacc documentation.\")\ndef ts_job(\n    atoms: Atoms,\n    charge: int,\n    spin_multiplicity: int,\n    method: str = \"wb97mv\",\n    basis: str = \"def2-svpd\",\n    scf_algorithm: str = \"diis\",\n    pcm_dielectric: str | None = None,\n    smd_solvent: str | None = None,\n    n_cores: int | None = None,\n    overwrite_inputs: dict[str, Any] | None = None,\n    opt_params: dict[str, Any] | None = None,\n    copy_files: list[str] | None = None,\n) -&gt; OptSchema:\n    \"\"\"\n    TS optimize a molecular structure.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    charge\n        Charge of the system.\n    spin_multiplicity\n        Multiplicity of the system.\n    method\n        DFT exchange-correlation functional or other electronic structure\n        method. Defaults to wB97M-V.\n    basis\n        Basis set. Defaults to def2-SVPD.\n    scf_algorithm\n        Algorithm used to converge the SCF. Defaults to \"diis\", but for\n        particularly difficult cases, \"gdm\" should be employed instead.\n    pcm_dielectric\n        Dielectric constant of the optional polarizable continuum implicit\n        solvation model. Defaults to None, in which case PCM will not be\n        employed.\n    smd_solvent\n        Solvent to use for SMD implicit solvation model. Examples include\n        \"water\", \"ethanol\", \"methanol\", and \"acetonitrile\". Refer to the Q-Chem\n        manual for a complete list of solvents available. Defaults to None, in\n        which case SMD will not be employed.\n    n_cores\n        Number of cores to use for the Q-Chem calculation. Defaults to use all\n        cores available on a given node.\n    overwrite_inputs\n        Dictionary passed to `pymatgen.io.qchem.QChemDictSet` which can modify\n        default values set therein as well as set additional Q-Chem parameters.\n        See QChemDictSet documentation for more details.\n    opt_params\n        Dictionary of custom kwargs for [quacc.runners.ase.run_opt][]\n    copy_files\n        Files to copy to the runtime directory.\n\n    Returns\n    -------\n    OptSchema\n        Dictionary of results from [quacc.schemas.ase.summarize_opt_run][]\n    \"\"\"\n\n    calc_defaults = {\n        \"basis_set\": basis,\n        \"scf_algorithm\": scf_algorithm,\n        \"method\": method,\n        \"charge\": charge,\n        \"spin_multiplicity\": spin_multiplicity,\n        \"cores\": n_cores or psutil.cpu_count(logical=False),\n        \"qchem_input_params\": {\n            \"pcm_dielectric\": pcm_dielectric,\n            \"smd_solvent\": smd_solvent,\n            \"overwrite_inputs\": overwrite_inputs,\n            \"max_scf_cycles\": 200 if scf_algorithm.lower() == \"gdm\" else None,\n        },\n    }\n    opt_defaults = {\n        \"fmax\": 0.01,\n        \"max_steps\": 1000,\n        \"optimizer\": Sella,\n        \"optimizer_kwargs\": {\"order\": 1, \"use_TRICs\": False},\n    }\n\n    if opt_params and opt_params.get(\"optimizer\", Sella) is not Sella:\n        raise ValueError(\"Only Sella should be used for TS optimization.\")\n\n    return base_opt_fn(\n        atoms,\n        charge,\n        spin_multiplicity,\n        calc_defaults=calc_defaults,\n        opt_defaults=opt_defaults,\n        opt_params=opt_params,\n        additional_fields={\"name\": \"Q-Chem TS\"},\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/tblite/core.html","title":"core","text":"<p>Core recipes for the tblite code.</p>"},{"location":"reference/quacc/recipes/tblite/core.html#quacc.recipes.tblite.core.freq_job","title":"freq_job","text":"<pre><code>freq_job(\n    atoms,\n    method=\"GFN2-xTB\",\n    energy=0.0,\n    temperature=298.15,\n    pressure=1.0,\n    vib_kwargs=None,\n    **calc_kwargs\n)\n</code></pre> <p>Run a frequency job and calculate thermochemistry.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>Atoms object</p> </li> <li> <code>method</code>             (<code>Literal['GFN1-xTB', 'GFN2-xTB', 'IPEA1-xTB']</code>, default:                 <code>'GFN2-xTB'</code> )         \u2013          <p>xTB method to use</p> </li> <li> <code>energy</code>             (<code>float</code>, default:                 <code>0.0</code> )         \u2013          <p>Potential energy in eV. If 0, then the output is just the correction.</p> </li> <li> <code>temperature</code>             (<code>float</code>, default:                 <code>298.15</code> )         \u2013          <p>Temperature in Kelvins.</p> </li> <li> <code>pressure</code>             (<code>float</code>, default:                 <code>1.0</code> )         \u2013          <p>Pressure in bar.</p> </li> <li> <code>vib_kwargs</code>             (<code>VibKwargs | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of kwargs for quacc.runners.ase.run_vib.</p> </li> <li> <code>**calc_kwargs</code>         \u2013          <p>Custom kwargs for the tblite calculator. Set a value to <code>None</code> to remove a pre-existing key entirely. For a list of available keys, refer to the <code>tblite.ase.TBLite</code> calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>VibThermoSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.ase.summarize_vib_and_thermo</p> </li> </ul> Source code in <code>quacc/recipes/tblite/core.py</code> <pre><code>@job\n@requires(TBLite, \"tblite must be installed. Refer to the quacc documentation.\")\ndef freq_job(\n    atoms: Atoms,\n    method: Literal[\"GFN1-xTB\", \"GFN2-xTB\", \"IPEA1-xTB\"] = \"GFN2-xTB\",\n    energy: float = 0.0,\n    temperature: float = 298.15,\n    pressure: float = 1.0,\n    vib_kwargs: VibKwargs | None = None,\n    **calc_kwargs,\n) -&gt; VibThermoSchema:\n    \"\"\"\n    Run a frequency job and calculate thermochemistry.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    method\n        xTB method to use\n    energy\n        Potential energy in eV. If 0, then the output is just the correction.\n    temperature\n        Temperature in Kelvins.\n    pressure\n        Pressure in bar.\n    vib_kwargs\n        Dictionary of kwargs for [quacc.runners.ase.run_vib][].\n    **calc_kwargs\n        Custom kwargs for the tblite calculator. Set a value to\n        `None` to remove a pre-existing key entirely. For a list of available\n        keys, refer to the `tblite.ase.TBLite` calculator.\n\n    Returns\n    -------\n    VibThermoSchema\n        Dictionary of results from [quacc.schemas.ase.summarize_vib_and_thermo][]\n    \"\"\"\n    vib_kwargs = vib_kwargs or {}\n\n    defaults = {\"method\": method}\n    calc_flags = merge_dicts(defaults, calc_kwargs)\n    atoms.calc = TBLite(**calc_flags)\n\n    vibrations = run_vib(atoms, vib_kwargs=vib_kwargs)\n    igt = run_ideal_gas(atoms, vibrations.get_frequencies(), energy=energy)\n\n    return summarize_vib_and_thermo(\n        vibrations,\n        igt,\n        temperature=temperature,\n        pressure=pressure,\n        additional_fields={\"name\": \"TBLite Frequency and Thermo\"},\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/tblite/core.html#quacc.recipes.tblite.core.relax_job","title":"relax_job","text":"<pre><code>relax_job(\n    atoms,\n    method=\"GFN2-xTB\",\n    relax_cell=False,\n    opt_params=None,\n    **calc_kwargs\n)\n</code></pre> <p>Relax a structure.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>Atoms object</p> </li> <li> <code>method</code>             (<code>Literal['GFN1-xTB', 'GFN2-xTB', 'IPEA1-xTB']</code>, default:                 <code>'GFN2-xTB'</code> )         \u2013          <p>xTB method to use</p> </li> <li> <code>relax_cell</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to relax the cell.</p> </li> <li> <code>opt_params</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom kwargs for the optimization process. Set a value to <code>None</code> to remove a pre-existing key entirely. For a list of available keys, refer to quacc.runners.ase.run_opt.</p> </li> <li> <code>**calc_kwargs</code>         \u2013          <p>Custom kwargs for the tblite calculator. Set a value to <code>None</code> to remove a pre-existing key entirely. For a list of available keys, refer to the <code>tblite.ase.TBLite</code> calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OptSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.ase.summarize_opt_run</p> </li> </ul> Source code in <code>quacc/recipes/tblite/core.py</code> <pre><code>@job\n@requires(TBLite, \"tblite must be installed. Refer to the quacc documentation.\")\ndef relax_job(\n    atoms: Atoms,\n    method: Literal[\"GFN1-xTB\", \"GFN2-xTB\", \"IPEA1-xTB\"] = \"GFN2-xTB\",\n    relax_cell: bool = False,\n    opt_params: dict[str, Any] | None = None,\n    **calc_kwargs,\n) -&gt; OptSchema:\n    \"\"\"\n    Relax a structure.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    method\n        xTB method to use\n    relax_cell\n        Whether to relax the cell.\n    opt_params\n        Dictionary of custom kwargs for the optimization process. Set a value\n        to `None` to remove a pre-existing key entirely. For a list of available\n        keys, refer to [quacc.runners.ase.run_opt][].\n    **calc_kwargs\n        Custom kwargs for the tblite calculator. Set a value to\n        `None` to remove a pre-existing key entirely. For a list of available\n        keys, refer to the `tblite.ase.TBLite` calculator.\n\n    Returns\n    -------\n    OptSchema\n        Dictionary of results from [quacc.schemas.ase.summarize_opt_run][]\n    \"\"\"\n\n    defaults = {\"method\": method}\n    calc_flags = merge_dicts(defaults, calc_kwargs)\n    atoms.calc = TBLite(**calc_flags)\n\n    opt_defaults = {\"fmax\": 0.01, \"max_steps\": 1000, \"optimizer\": FIRE}\n    opt_flags = merge_dicts(opt_defaults, opt_params)\n\n    dyn = run_opt(atoms, relax_cell=relax_cell, **opt_flags)\n\n    return summarize_opt_run(dyn, additional_fields={\"name\": \"TBLite Relax\"})\n</code></pre>"},{"location":"reference/quacc/recipes/tblite/core.html#quacc.recipes.tblite.core.static_job","title":"static_job","text":"<pre><code>static_job(atoms, method='GFN2-xTB', **calc_kwargs)\n</code></pre> <p>Carry out a single-point calculation.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>Atoms object</p> </li> <li> <code>method</code>             (<code>Literal['GFN1-xTB', 'GFN2-xTB', 'IPEA1-xTB']</code>, default:                 <code>'GFN2-xTB'</code> )         \u2013          <p>xTB method to use</p> </li> <li> <code>**calc_kwargs</code>         \u2013          <p>Custom kwargs for the TBLite calculator. Set a value to <code>None</code> to remove a pre-existing key entirely. For a list of available keys, refer to the <code>tblite.ase.TBLite</code> calculator</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.ase.summarize_run</p> </li> </ul> Source code in <code>quacc/recipes/tblite/core.py</code> <pre><code>@job\n@requires(TBLite, \"tblite must be installed. Refer to the quacc documentation.\")\ndef static_job(\n    atoms: Atoms,\n    method: Literal[\"GFN1-xTB\", \"GFN2-xTB\", \"IPEA1-xTB\"] = \"GFN2-xTB\",\n    **calc_kwargs,\n) -&gt; RunSchema:\n    \"\"\"\n    Carry out a single-point calculation.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    method\n        xTB method to use\n    **calc_kwargs\n        Custom kwargs for the TBLite calculator. Set a value to\n        `None` to remove a pre-existing key entirely. For a list of available\n        keys, refer to the `tblite.ase.TBLite` calculator\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results from [quacc.schemas.ase.summarize_run][]\n    \"\"\"\n\n    calc_defaults = {\"method\": method}\n    calc_flags = merge_dicts(calc_defaults, calc_kwargs)\n    atoms.calc = TBLite(**calc_flags)\n\n    final_atoms = run_calc(atoms)\n    return summarize_run(\n        final_atoms, input_atoms=atoms, additional_fields={\"name\": \"TBLite Static\"}\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/tblite/phonons.html","title":"phonons","text":"<p>Phonon recipes for TBLite</p>"},{"location":"reference/quacc/recipes/tblite/phonons.html#quacc.recipes.tblite.phonons.phonon_flow","title":"phonon_flow","text":"<pre><code>phonon_flow(\n    atoms,\n    supercell_matrix=((2, 0, 0), (0, 2, 0), (0, 0, 2)),\n    atom_disp=0.01,\n    symprec=1e-05,\n    t_step=10,\n    t_min=0,\n    t_max=1000,\n    static_job_kwargs=None,\n)\n</code></pre> <p>Carry out a phonon calculation.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>Atoms object</p> </li> <li> <code>supercell_matrix</code>             (<code>ArrayLike</code>, default:                 <code>((2, 0, 0), (0, 2, 0), (0, 0, 2))</code> )         \u2013          <p>Supercell matrix to use. Defaults to 2x2x2 supercell.</p> </li> <li> <code>atom_disp</code>             (<code>float</code>, default:                 <code>0.01</code> )         \u2013          <p>Atomic displacement (A).</p> </li> <li> <code>symprec</code>             (<code>float</code>, default:                 <code>1e-05</code> )         \u2013          <p>Precision for symmetry detection.</p> </li> <li> <code>t_step</code>             (<code>float</code>, default:                 <code>10</code> )         \u2013          <p>Temperature step (K).</p> </li> <li> <code>t_min</code>             (<code>float</code>, default:                 <code>0</code> )         \u2013          <p>Min temperature (K).</p> </li> <li> <code>t_max</code>             (<code>float</code>, default:                 <code>1000</code> )         \u2013          <p>Max temperature (K).</p> </li> <li> <code>static_job_kwargs</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Keyword arguments for quacc.recipes.tblite.core.static_job for the force calculations.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>PhononSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.phonons.summarize_phonopy</p> </li> </ul> Source code in <code>quacc/recipes/tblite/phonons.py</code> <pre><code>@flow\ndef phonon_flow(\n    atoms: Atoms,\n    supercell_matrix: ArrayLike = ((2, 0, 0), (0, 2, 0), (0, 0, 2)),\n    atom_disp: float = 0.01,\n    symprec: float = 1e-5,\n    t_step: float = 10,\n    t_min: float = 0,\n    t_max: float = 1000,\n    static_job_kwargs: dict[str, Any] | None = None,\n) -&gt; PhononSchema:\n    \"\"\"\n    Carry out a phonon calculation.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    supercell_matrix\n        Supercell matrix to use. Defaults to 2x2x2 supercell.\n    atom_disp\n        Atomic displacement (A).\n    symprec\n        Precision for symmetry detection.\n    t_step\n        Temperature step (K).\n    t_min\n        Min temperature (K).\n    t_max\n        Max temperature (K).\n    static_job_kwargs\n        Keyword arguments for [quacc.recipes.tblite.core.static_job][]\n        for the force calculations.\n\n    Returns\n    -------\n    PhononSchema\n        Dictionary of results from [quacc.schemas.phonons.summarize_phonopy][]\n    \"\"\"\n    static_job_kwargs = static_job_kwargs or {}\n\n    return phonon_flow_(\n        atoms,\n        partial(static_job, **static_job_kwargs),\n        supercell_matrix=supercell_matrix,\n        atom_disp=atom_disp,\n        t_step=t_step,\n        t_min=t_min,\n        t_max=t_max,\n        phonopy_kwargs={\"symprec\": symprec},\n        additional_fields={\"name\": \"TBLite Phonons\"},\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/_base.html","title":"_base","text":"<p>Core recipes for VASP.</p>"},{"location":"reference/quacc/recipes/vasp/_base.html#quacc.recipes.vasp._base.base_fn","title":"base_fn","text":"<pre><code>base_fn(\n    atoms,\n    preset=None,\n    calc_defaults=None,\n    calc_swaps=None,\n    additional_fields=None,\n    copy_files=None,\n)\n</code></pre> <p>Base job function for VASP recipes.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>Atoms object</p> </li> <li> <code>preset</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>Preset to use from <code>quacc.calculators.vasp.presets</code>.</p> </li> <li> <code>calc_defaults</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Default parameters for the recipe.</p> </li> <li> <code>calc_swaps</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom kwargs for the Vasp calculator. Set a value to <code>None</code> to remove a pre-existing key entirely. For a list of available keys, refer to the <code>quacc.calculators.vasp.vasp.Vasp</code> calculator.</p> </li> <li> <code>additional_fields</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional fields to supply to the summarizer.</p> </li> <li> <code>copy_files</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>VaspSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.vasp.vasp_summarize_run</p> </li> </ul> Source code in <code>quacc/recipes/vasp/_base.py</code> <pre><code>def base_fn(\n    atoms: Atoms,\n    preset: str | None = None,\n    calc_defaults: dict[str, Any] | None = None,\n    calc_swaps: dict[str, Any] | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    copy_files: list[str] | None = None,\n) -&gt; VaspSchema:\n    \"\"\"\n    Base job function for VASP recipes.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    preset\n        Preset to use from `quacc.calculators.vasp.presets`.\n    calc_defaults\n        Default parameters for the recipe.\n    calc_swaps\n        Dictionary of custom kwargs for the Vasp calculator. Set a value to\n        `None` to remove a pre-existing key entirely. For a list of available\n        keys, refer to the `quacc.calculators.vasp.vasp.Vasp` calculator.\n    additional_fields\n        Additional fields to supply to the summarizer.\n    copy_files\n        Files to copy to the runtime directory.\n\n    Returns\n    -------\n    VaspSchema\n        Dictionary of results from [quacc.schemas.vasp.vasp_summarize_run][]\n    \"\"\"\n    calc_flags = merge_dicts(calc_defaults, calc_swaps, remove_nones=False)\n\n    atoms.calc = Vasp(atoms, preset=preset, **calc_flags)\n    atoms = run_calc(atoms, copy_files=copy_files)\n\n    return vasp_summarize_run(atoms, additional_fields=additional_fields)\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/core.html","title":"core","text":"<p>Core recipes for VASP.</p>"},{"location":"reference/quacc/recipes/vasp/core.html#quacc.recipes.vasp.core.double_relax_job","title":"double_relax_job","text":"<pre><code>double_relax_job(\n    atoms,\n    preset=\"BulkSet\",\n    relax_cell=True,\n    relax1_kwargs=None,\n    relax2_kwargs=None,\n)\n</code></pre> <p>Double-relax a structure. This is particularly useful for a few reasons:</p> <ol> <li> <p>To carry out a cheaper pre-relaxation before the high-quality run.</p> </li> <li> <p>To carry out a GGA calculation before a meta-GGA or hybrid calculation that requires the GGA wavefunction.</p> </li> <li> <p>To carry out volume relaxations where large changes in volume can require a second relaxation to resolve forces.</p> </li> </ol> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>Atoms object</p> </li> <li> <code>preset</code>             (<code>str | None</code>, default:                 <code>'BulkSet'</code> )         \u2013          <p>Preset to use from <code>quacc.calculators.vasp.presets</code>.</p> </li> <li> <code>relax_cell</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>True if a volume relaxation (ISIF = 3) should be performed. False if only the positions (ISIF = 2) should be updated.</p> </li> <li> <code>relax1_kwargs</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom kwargs for the first relaxation.</p> </li> <li> <code>relax2_kwargs</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom kwargs for the second relaxation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DoubleRelaxSchema</code>         \u2013          <p>Dictionary of results</p> </li> </ul> Source code in <code>quacc/recipes/vasp/core.py</code> <pre><code>@job\ndef double_relax_job(\n    atoms: Atoms,\n    preset: str | None = \"BulkSet\",\n    relax_cell: bool = True,\n    relax1_kwargs: dict[str, Any] | None = None,\n    relax2_kwargs: dict[str, Any] | None = None,\n) -&gt; DoubleRelaxSchema:\n    \"\"\"\n    Double-relax a structure. This is particularly useful for a few reasons:\n\n    1. To carry out a cheaper pre-relaxation before the high-quality run.\n\n    2. To carry out a GGA calculation before a meta-GGA or hybrid calculation\n    that requires the GGA wavefunction.\n\n    3. To carry out volume relaxations where large changes in volume\n    can require a second relaxation to resolve forces.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    preset\n        Preset to use from `quacc.calculators.vasp.presets`.\n    relax_cell\n        True if a volume relaxation (ISIF = 3) should be performed. False if\n        only the positions (ISIF = 2) should be updated.\n    relax1_kwargs\n        Dictionary of custom kwargs for the first relaxation.\n    relax2_kwargs\n        Dictionary of custom kwargs for the second relaxation.\n\n    Returns\n    -------\n    DoubleRelaxSchema\n        Dictionary of results\n    \"\"\"\n    relax1_kwargs = relax1_kwargs or {}\n    relax2_kwargs = relax2_kwargs or {}\n\n    # Run first relaxation\n    summary1 = relax_job.__wrapped__(\n        atoms, preset=preset, relax_cell=relax_cell, **relax1_kwargs\n    )\n\n    # Run second relaxation\n    summary2 = relax_job.__wrapped__(\n        summary1[\"atoms\"],\n        preset=preset,\n        relax_cell=relax_cell,\n        copy_files=[Path(summary1[\"dir_name\"]) / \"WAVECAR\"],\n        **relax2_kwargs,\n    )\n    summary2[\"relax1\"] = summary1\n\n    return summary2\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/core.html#quacc.recipes.vasp.core.relax_job","title":"relax_job","text":"<pre><code>relax_job(\n    atoms,\n    preset=\"BulkSet\",\n    relax_cell=True,\n    copy_files=None,\n    **calc_kwargs\n)\n</code></pre> <p>Relax a structure.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>Atoms object</p> </li> <li> <code>preset</code>             (<code>str | None</code>, default:                 <code>'BulkSet'</code> )         \u2013          <p>Preset to use from <code>quacc.calculators.vasp.presets</code>.</p> </li> <li> <code>relax_cell</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>True if a volume relaxation (ISIF = 3) should be performed. False if only the positions (ISIF = 2) should be updated.</p> </li> <li> <code>copy_files</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> <li> <code>**calc_kwargs</code>         \u2013          <p>Custom kwargs for the Vasp calculator. Set a value to <code>None</code> to remove a pre-existing key entirely. For a list of available keys, refer to the <code>quacc.calculators.vasp.vasp.Vasp</code> calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>VaspSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.vasp.vasp_summarize_run</p> </li> </ul> Source code in <code>quacc/recipes/vasp/core.py</code> <pre><code>@job\ndef relax_job(\n    atoms: Atoms,\n    preset: str | None = \"BulkSet\",\n    relax_cell: bool = True,\n    copy_files: list[str] | None = None,\n    **calc_kwargs,\n) -&gt; VaspSchema:\n    \"\"\"\n    Relax a structure.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    preset\n        Preset to use from `quacc.calculators.vasp.presets`.\n    relax_cell\n        True if a volume relaxation (ISIF = 3) should be performed. False if\n        only the positions (ISIF = 2) should be updated.\n    copy_files\n        Files to copy to the runtime directory.\n    **calc_kwargs\n        Custom kwargs for the Vasp calculator. Set a value to\n        `None` to remove a pre-existing key entirely. For a list of available\n        keys, refer to the `quacc.calculators.vasp.vasp.Vasp` calculator.\n\n    Returns\n    -------\n    VaspSchema\n        Dictionary of results from [quacc.schemas.vasp.vasp_summarize_run][]\n    \"\"\"\n\n    calc_defaults = {\n        \"ediffg\": -0.02,\n        \"isif\": 3 if relax_cell else 2,\n        \"ibrion\": 2,\n        \"isym\": 0,\n        \"lcharg\": False,\n        \"lwave\": False,\n        \"nsw\": 200,\n        \"symprec\": 1e-8,\n    }\n    return base_fn(\n        atoms,\n        preset=preset,\n        calc_defaults=calc_defaults,\n        calc_swaps=calc_kwargs,\n        additional_fields={\"name\": \"VASP Relax\"},\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/core.html#quacc.recipes.vasp.core.static_job","title":"static_job","text":"<pre><code>static_job(\n    atoms, preset=\"BulkSet\", copy_files=None, **calc_kwargs\n)\n</code></pre> <p>Carry out a single-point calculation.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>Atoms object</p> </li> <li> <code>preset</code>             (<code>str | None</code>, default:                 <code>'BulkSet'</code> )         \u2013          <p>Preset to use from <code>quacc.calculators.vasp.presets</code>.</p> </li> <li> <code>copy_files</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> <li> <code>**calc_kwargs</code>         \u2013          <p>Custom kwargs for the Vasp calculator. Set a value to <code>None</code> to remove a pre-existing key entirely. For a list of available keys, refer to the <code>quacc.calculators.vasp.vasp.Vasp</code> calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>VaspSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.vasp.vasp_summarize_run</p> </li> </ul> Source code in <code>quacc/recipes/vasp/core.py</code> <pre><code>@job\ndef static_job(\n    atoms: Atoms,\n    preset: str | None = \"BulkSet\",\n    copy_files: list[str] | None = None,\n    **calc_kwargs,\n) -&gt; VaspSchema:\n    \"\"\"\n    Carry out a single-point calculation.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    preset\n        Preset to use from `quacc.calculators.vasp.presets`.\n    copy_files\n        Files to copy to the runtime directory.\n    **calc_kwargs\n        Custom kwargs for the Vasp calculator. Set a value to\n        `None` to remove a pre-existing key entirely. For a list of available\n        keys, refer to the `quacc.calculators.vasp.vasp.Vasp` calculator.\n\n    Returns\n    -------\n    VaspSchema\n        Dictionary of results from [quacc.schemas.vasp.vasp_summarize_run][]\n    \"\"\"\n\n    calc_defaults = {\n        \"ismear\": -5,\n        \"laechg\": True,\n        \"lcharg\": True,\n        \"lreal\": False,\n        \"lwave\": True,\n        \"nedos\": 5001,\n        \"nsw\": 0,\n    }\n    return base_fn(\n        atoms,\n        preset=preset,\n        calc_defaults=calc_defaults,\n        calc_swaps=calc_kwargs,\n        additional_fields={\"name\": \"VASP Static\"},\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/mp.html","title":"mp","text":"<p>Materials Project-compatible recipes.</p> <p>This set of recipes is meant to be compatible with the Materials Project Reference: https://doi.org/10.1103/PhysRevMaterials.6.013801</p> <p>Info</p> <p>The one true source of Materials Project workflows is atomate2. If you need an MP-compatible workflow, we strongly encourage you to use atomate2 to ensure that all of your settings are fully compatible and up-to-date. This module is a best effort to be used at your own discretion.</p>"},{"location":"reference/quacc/recipes/vasp/mp.html#quacc.recipes.vasp.mp.mp_prerelax_job","title":"mp_prerelax_job","text":"<pre><code>mp_prerelax_job(\n    atoms,\n    preset=\"MPScanSet\",\n    bandgap=None,\n    copy_files=None,\n    **calc_kwargs\n)\n</code></pre> <p>Function to pre-relax a structure with Materials Project settings. By default, this uses a PBEsol pre-relax step.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>Atoms object</p> </li> <li> <code>preset</code>             (<code>str | None</code>, default:                 <code>'MPScanSet'</code> )         \u2013          <p>Preset to use from <code>quacc.calculators.vasp.presets</code>.</p> </li> <li> <code>bandgap</code>             (<code>float | None</code>, default:                 <code>None</code> )         \u2013          <p>Estimate for the bandgap in eV.</p> </li> <li> <code>copy_files</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> <li> <code>**calc_kwargs</code>         \u2013          <p>Custom kwargs for the Vasp calculator. Set a value to <code>None</code> to remove a pre-existing key entirely. For a list of available keys, refer to the <code>quacc.calculators.vasp.vasp.Vasp</code> calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>VaspSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.vasp.vasp_summarize_run</p> </li> </ul> Source code in <code>quacc/recipes/vasp/mp.py</code> <pre><code>@job\ndef mp_prerelax_job(\n    atoms: Atoms,\n    preset: str | None = \"MPScanSet\",\n    bandgap: float | None = None,\n    copy_files: list[str] | None = None,\n    **calc_kwargs,\n) -&gt; VaspSchema:\n    \"\"\"\n    Function to pre-relax a structure with Materials Project settings. By default, this\n    uses a PBEsol pre-relax step.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    preset\n        Preset to use from `quacc.calculators.vasp.presets`.\n    bandgap\n        Estimate for the bandgap in eV.\n    copy_files\n        Files to copy to the runtime directory.\n    **calc_kwargs\n        Custom kwargs for the Vasp calculator. Set a value to\n        `None` to remove a pre-existing key entirely. For a list of available\n        keys, refer to the `quacc.calculators.vasp.vasp.Vasp` calculator.\n\n    Returns\n    -------\n    VaspSchema\n        Dictionary of results from [quacc.schemas.vasp.vasp_summarize_run][]\n    \"\"\"\n\n    calc_defaults = {\n        \"ediffg\": -0.05,\n        \"xc\": \"pbesol\",\n        \"lwave\": True,\n        \"lcharg\": True,\n    } | _get_bandgap_swaps(bandgap)\n\n    return base_fn(\n        atoms,\n        preset=preset,\n        calc_defaults=calc_defaults,\n        calc_swaps=calc_kwargs,\n        additional_fields={\"name\": \"MP Pre-Relax\"},\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/mp.html#quacc.recipes.vasp.mp.mp_relax_flow","title":"mp_relax_flow","text":"<pre><code>mp_relax_flow(\n    atoms, prerelax_job_kwargs=None, relax_job_kwargs=None\n)\n</code></pre> <p>Workflow consisting of:</p> <ol> <li> <p>MP-compatible pre-relax</p> </li> <li> <p>MP-compatible relax</p> </li> </ol> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>Atoms object for the structure.</p> </li> <li> <code>prerelax_job_kwargs</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional keyword arguments to pass to quacc.recipes.vasp.mp.mp_prerelax_job.</p> </li> <li> <code>relax_job_kwargs</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional keyword arguments to pass to quacc.recipes.vasp.mp.mp_relax_job.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>MPRelaxFlowSchema</code>         \u2013          <p>Dictionary of results</p> </li> </ul> Source code in <code>quacc/recipes/vasp/mp.py</code> <pre><code>@flow\ndef mp_relax_flow(\n    atoms: Atoms,\n    prerelax_job_kwargs: dict[str, Any] | None = None,\n    relax_job_kwargs: dict[str, Any] | None = None,\n) -&gt; MPRelaxFlowSchema:\n    \"\"\"\n    Workflow consisting of:\n\n    1. MP-compatible pre-relax\n\n    2. MP-compatible relax\n\n    Parameters\n    ----------\n    atoms\n        Atoms object for the structure.\n    prerelax_job_kwargs\n        Additional keyword arguments to pass to [quacc.recipes.vasp.mp.mp_prerelax_job][].\n    relax_job_kwargs\n        Additional keyword arguments to pass to [quacc.recipes.vasp.mp.mp_relax_job][].\n\n    Returns\n    -------\n    MPRelaxFlowSchema\n        Dictionary of results\n    \"\"\"\n    prerelax_job_kwargs = prerelax_job_kwargs or {}\n    relax_job_kwargs = relax_job_kwargs or {}\n\n    # Run the prerelax\n    prerelax_results = mp_prerelax_job(atoms, **prerelax_job_kwargs)\n\n    # Run the relax\n    relax_results = mp_relax_job(\n        prerelax_results[\"atoms\"],\n        bandgap=prerelax_results[\"output\"][\"bandgap\"],\n        copy_files=[\n            Path(prerelax_results[\"dir_name\"]) / \"CHGCAR\",\n            Path(prerelax_results[\"dir_name\"]) / \"WAVECAR\",\n        ],\n        **relax_job_kwargs,\n    )\n    relax_results[\"prerelax\"] = prerelax_results\n\n    return relax_results\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/mp.html#quacc.recipes.vasp.mp.mp_relax_job","title":"mp_relax_job","text":"<pre><code>mp_relax_job(\n    atoms,\n    preset=\"MPScanSet\",\n    bandgap=None,\n    copy_files=None,\n    **calc_kwargs\n)\n</code></pre> <p>Function to relax a structure with Materials Project settings. By default, this uses an r2SCAN relax step.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>Atoms object</p> </li> <li> <code>preset</code>             (<code>str | None</code>, default:                 <code>'MPScanSet'</code> )         \u2013          <p>Preset to use from <code>quacc.calculators.vasp.presets</code>.</p> </li> <li> <code>bandgap</code>             (<code>float | None</code>, default:                 <code>None</code> )         \u2013          <p>Estimate for the bandgap in eV.</p> </li> <li> <code>copy_files</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> <li> <code>**calc_kwargs</code>         \u2013          <p>Dictionary of custom kwargs for the Vasp calculator. Set a value to <code>None</code> to remove a pre-existing key entirely. For a list of available keys, refer to the <code>quacc.calculators.vasp.vasp.Vasp</code> calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>VaspSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.vasp.vasp_summarize_run</p> </li> </ul> Source code in <code>quacc/recipes/vasp/mp.py</code> <pre><code>@job\ndef mp_relax_job(\n    atoms: Atoms,\n    preset: str | None = \"MPScanSet\",\n    bandgap: float | None = None,\n    copy_files: list[str] | None = None,\n    **calc_kwargs,\n) -&gt; VaspSchema:\n    \"\"\"\n    Function to relax a structure with Materials Project settings. By default, this uses\n    an r2SCAN relax step.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    preset\n        Preset to use from `quacc.calculators.vasp.presets`.\n    bandgap\n        Estimate for the bandgap in eV.\n    copy_files\n        Files to copy to the runtime directory.\n    **calc_kwargs\n        Dictionary of custom kwargs for the Vasp calculator. Set a value to\n        `None` to remove a pre-existing key entirely. For a list of available\n        keys, refer to the `quacc.calculators.vasp.vasp.Vasp` calculator.\n\n    Returns\n    -------\n    VaspSchema\n        Dictionary of results from [quacc.schemas.vasp.vasp_summarize_run][]\n    \"\"\"\n\n    calc_defaults = {\"lcharg\": True, \"lwave\": True} | _get_bandgap_swaps(bandgap)\n    return base_fn(\n        atoms,\n        preset=preset,\n        calc_defaults=calc_defaults,\n        calc_swaps=calc_kwargs,\n        additional_fields={\"name\": \"MP Relax\"},\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/qmof.html","title":"qmof","text":"<p>QMOF-compatible recipes.</p> <p>This set of recipes is meant to be compatible with the QMOF Database workflow. Reference: https://doi.org/10.1016/j.matt.2021.02.015</p>"},{"location":"reference/quacc/recipes/vasp/qmof.html#quacc.recipes.vasp.qmof.qmof_relax_job","title":"qmof_relax_job","text":"<pre><code>qmof_relax_job(\n    atoms,\n    preset=\"QMOFSet\",\n    relax_cell=True,\n    run_prerelax=True,\n    **calc_kwargs\n)\n</code></pre> <p>Relax a structure in a multi-step process for increased computational efficiency. This is all done in a single compute job. Settings are such that they are compatible with the QMOF Database.</p> <ol> <li> <p>A \"pre-relaxation\" with BFGSLineSearch to resolve very high forces.</p> </li> <li> <p>Position relaxation with default ENCUT and coarse k-point grid.</p> </li> <li> <p>Optional: volume relaxation with coarse k-point grid.</p> </li> <li> <p>Double relaxation using production-quality settings.</p> </li> <li> <p>Static calculation.</p> </li> </ol> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>Atoms object</p> </li> <li> <code>preset</code>             (<code>str | None</code>, default:                 <code>'QMOFSet'</code> )         \u2013          <p>Preset to use from <code>quacc.calculators.vasp.presets</code>. Applies for all jobs.</p> </li> <li> <code>relax_cell</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>True if a volume relaxation should be performed. False if only the positions should be updated.</p> </li> <li> <code>run_prerelax</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>If True, a pre-relax will be carried out with BFGSLineSearch. Recommended if starting from hypothetical structures or materials with very high starting forces.</p> </li> <li> <code>**kwargs</code>         \u2013          <p>Custom kwargs for the calculator. Set a value to <code>None</code> to remove a pre-existing key entirely. Applies for all jobs.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>QMOFRelaxSchema</code>         \u2013          <p>Dictionary of results</p> </li> </ul> Source code in <code>quacc/recipes/vasp/qmof.py</code> <pre><code>@job\ndef qmof_relax_job(\n    atoms: Atoms,\n    preset: str | None = \"QMOFSet\",\n    relax_cell: bool = True,\n    run_prerelax: bool = True,\n    **calc_kwargs,\n) -&gt; QMOFRelaxSchema:\n    \"\"\"\n    Relax a structure in a multi-step process for increased computational efficiency.\n    This is all done in a single compute job. Settings are such that they are compatible\n    with the QMOF Database.\n\n    1. A \"pre-relaxation\" with BFGSLineSearch to resolve very high forces.\n\n    2. Position relaxation with default ENCUT and coarse k-point grid.\n\n    3. Optional: volume relaxation with coarse k-point grid.\n\n    4. Double relaxation using production-quality settings.\n\n    5. Static calculation.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    preset\n        Preset to use from `quacc.calculators.vasp.presets`. Applies for all jobs.\n    relax_cell\n        True if a volume relaxation should be performed. False if only the\n        positions should be updated.\n    run_prerelax\n        If True, a pre-relax will be carried out with BFGSLineSearch.\n        Recommended if starting from hypothetical structures or materials with\n        very high starting forces.\n    **kwargs\n        Custom kwargs for the calculator. Set a value to `None` to remove\n        a pre-existing key entirely. Applies for all jobs.\n\n    Returns\n    -------\n    QMOFRelaxSchema\n        Dictionary of results\n    \"\"\"\n\n    # 1. Pre-relaxation\n    if run_prerelax:\n        summary1 = _prerelax(atoms, preset, fmax=5.0, **calc_kwargs)\n        atoms = summary1[\"atoms\"]\n\n    # 2. Position relaxation (loose)\n    summary2 = _loose_relax_positions(atoms, preset, **calc_kwargs)\n    atoms = summary2[\"atoms\"]\n\n    # 3. Optional: Volume relaxation (loose)\n    if relax_cell:\n        summary3 = _loose_relax_cell(atoms, preset, **calc_kwargs)\n        atoms = summary3[\"atoms\"]\n\n    # 4. Double Relaxation This is done for two reasons: a) because it can\n    # resolve repadding issues when dV is large; b) because we can use LREAL =\n    # Auto for the first relaxation and the default LREAL for the second.\n    summary4 = _double_relax(atoms, preset, relax_cell=relax_cell, **calc_kwargs)\n    atoms = summary4[1][\"atoms\"]\n\n    # 5. Static Calculation\n    summary5 = _static(atoms, preset, **calc_kwargs)\n    summary5[\"prerelax_lowacc\"] = summary1 if run_prerelax else None\n    summary5[\"position_relax_lowacc\"] = summary2\n    summary5[\"volume_relax_lowacc\"] = summary3 if relax_cell else None\n    summary5[\"double_relax\"] = summary4\n\n    return summary5\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/slabs.html","title":"slabs","text":"<p>Recipes for slabs.</p>"},{"location":"reference/quacc/recipes/vasp/slabs.html#quacc.recipes.vasp.slabs.bulk_to_slabs_flow","title":"bulk_to_slabs_flow","text":"<pre><code>bulk_to_slabs_flow(\n    atoms,\n    make_slabs_kwargs=None,\n    run_static=True,\n    slab_relax_kwargs=None,\n    slab_static_kwargs=None,\n)\n</code></pre> <p>Workflow consisting of:</p> <ol> <li> <p>Slab generation</p> </li> <li> <p>Slab relaxations</p> </li> <li> <p>Slab statics (optional)</p> </li> </ol> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>Atoms object</p> </li> <li> <code>make_slabs_kwargs</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional keyword arguments to pass to quacc.atoms.slabs.make_slabs_from_bulk</p> </li> <li> <code>run_static</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to run the static calculation.</p> </li> <li> <code>slab_relax_kwargs</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional keyword arguments to pass to quacc.recipes.vasp.slabs.slab_relax_job.</p> </li> <li> <code>slab_static_kwargs</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional keyword arguments to pass to quacc.recipes.vasp.slabs.slab_static_job.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[VaspSchema]</code>         \u2013          <p>List of dictionary results from quacc.schemas.vasp.vasp_summarize_run</p> </li> </ul> Source code in <code>quacc/recipes/vasp/slabs.py</code> <pre><code>@flow\ndef bulk_to_slabs_flow(\n    atoms: Atoms,\n    make_slabs_kwargs: dict[str, Any] | None = None,\n    run_static: bool = True,\n    slab_relax_kwargs: dict[str, Any] | None = None,\n    slab_static_kwargs: dict[str, Any] | None = None,\n) -&gt; list[VaspSchema]:\n    \"\"\"\n    Workflow consisting of:\n\n    1. Slab generation\n\n    2. Slab relaxations\n\n    3. Slab statics (optional)\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    make_slabs_kwargs\n        Additional keyword arguments to pass to [quacc.atoms.slabs.make_slabs_from_bulk][]\n    run_static\n        Whether to run the static calculation.\n    slab_relax_kwargs\n        Additional keyword arguments to pass to [quacc.recipes.vasp.slabs.slab_relax_job][].\n    slab_static_kwargs\n        Additional keyword arguments to pass to [quacc.recipes.vasp.slabs.slab_static_job][].\n\n    Returns\n    -------\n    list[VaspSchema]\n        List of dictionary results from [quacc.schemas.vasp.vasp_summarize_run][]\n    \"\"\"\n\n    make_slabs_kwargs = make_slabs_kwargs or {}\n    slab_relax_kwargs = slab_relax_kwargs or {}\n    slab_static_kwargs = slab_static_kwargs or {}\n\n    relax_job = partial(slab_relax_job, **slab_relax_kwargs)\n    static_job = partial(slab_static_job, **slab_static_kwargs)\n    make_slabs_fn = partial(make_slabs_from_bulk, **make_slabs_kwargs)\n\n    return bulk_to_slabs_subflow(\n        atoms,\n        relax_job,\n        static_job=static_job if run_static else None,\n        make_slabs_fn=make_slabs_fn,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/slabs.html#quacc.recipes.vasp.slabs.slab_relax_job","title":"slab_relax_job","text":"<pre><code>slab_relax_job(\n    atoms, preset=\"SlabSet\", copy_files=None, **calc_kwargs\n)\n</code></pre> <p>Function to relax a slab.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>Atoms object</p> </li> <li> <code>preset</code>             (<code>str | None</code>, default:                 <code>'SlabSet'</code> )         \u2013          <p>Preset to use from <code>quacc.calculators.vasp.presets</code>.</p> </li> <li> <code>copy_files</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> <li> <code>**calc_kwargs</code>         \u2013          <p>Custom kwargs for the Vasp calculator. Set a value to <code>None</code> to remove a pre-existing key entirely. For a list of available keys, refer to the <code>quacc.calculators.vasp.vasp.Vasp</code> calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>VaspSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.vasp.vasp_summarize_run</p> </li> </ul> Source code in <code>quacc/recipes/vasp/slabs.py</code> <pre><code>@job\ndef slab_relax_job(\n    atoms: Atoms,\n    preset: str | None = \"SlabSet\",\n    copy_files: list[str] | None = None,\n    **calc_kwargs,\n) -&gt; VaspSchema:\n    \"\"\"\n    Function to relax a slab.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    preset\n        Preset to use from `quacc.calculators.vasp.presets`.\n    copy_files\n        Files to copy to the runtime directory.\n    **calc_kwargs\n        Custom kwargs for the Vasp calculator. Set a value to\n        `None` to remove a pre-existing key entirely. For a list of available\n        keys, refer to the `quacc.calculators.vasp.vasp.Vasp` calculator.\n\n    Returns\n    -------\n    VaspSchema\n        Dictionary of results from [quacc.schemas.vasp.vasp_summarize_run][]\n    \"\"\"\n\n    calc_defaults = {\n        \"auto_dipole\": True,\n        \"ediffg\": -0.02,\n        \"isif\": 2,\n        \"ibrion\": 2,\n        \"isym\": 0,\n        \"lcharg\": False,\n        \"lwave\": False,\n        \"nsw\": 200,\n        \"symprec\": 1e-8,\n    }\n    return base_fn(\n        atoms,\n        preset=preset,\n        calc_defaults=calc_defaults,\n        calc_swaps=calc_kwargs,\n        additional_fields={\"name\": \"VASP Slab Relax\"},\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/slabs.html#quacc.recipes.vasp.slabs.slab_static_job","title":"slab_static_job","text":"<pre><code>slab_static_job(\n    atoms, preset=\"SlabSet\", copy_files=None, **calc_kwargs\n)\n</code></pre> <p>Function to carry out a single-point calculation on a slab.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>Atoms object</p> </li> <li> <code>preset</code>             (<code>str | None</code>, default:                 <code>'SlabSet'</code> )         \u2013          <p>Preset to use from <code>quacc.calculators.vasp.presets</code>.</p> </li> <li> <code>copy_files</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> <li> <code>**calc_kwargs</code>         \u2013          <p>Custom kwargs for the Vasp calculator. Set a value to <code>None</code> to remove a pre-existing key entirely. For a list of available keys, refer to the <code>quacc.calculators.vasp.vasp.Vasp</code> calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>VaspSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.vasp.vasp_summarize_run</p> </li> </ul> Source code in <code>quacc/recipes/vasp/slabs.py</code> <pre><code>@job\ndef slab_static_job(\n    atoms: Atoms,\n    preset: str | None = \"SlabSet\",\n    copy_files: list[str] | None = None,\n    **calc_kwargs,\n) -&gt; VaspSchema:\n    \"\"\"\n    Function to carry out a single-point calculation on a slab.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    preset\n        Preset to use from `quacc.calculators.vasp.presets`.\n    copy_files\n        Files to copy to the runtime directory.\n    **calc_kwargs\n        Custom kwargs for the Vasp calculator. Set a value to\n        `None` to remove a pre-existing key entirely. For a list of available\n        keys, refer to the `quacc.calculators.vasp.vasp.Vasp` calculator.\n\n    Returns\n    -------\n    VaspSchema\n        Dictionary of results from [quacc.schemas.vasp.vasp_summarize_run][]\n    \"\"\"\n\n    calc_defaults = {\n        \"auto_dipole\": True,\n        \"ismear\": -5,\n        \"laechg\": True,\n        \"lcharg\": True,\n        \"lreal\": False,\n        \"lvhar\": True,\n        \"lwave\": True,\n        \"nedos\": 5001,\n        \"nsw\": 0,\n    }\n    return base_fn(\n        atoms,\n        preset=preset,\n        calc_defaults=calc_defaults,\n        calc_swaps=calc_kwargs,\n        additional_fields={\"name\": \"VASP Slab Static\"},\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/slabs.html#quacc.recipes.vasp.slabs.slab_to_ads_flow","title":"slab_to_ads_flow","text":"<pre><code>slab_to_ads_flow(\n    slab,\n    adsorbate,\n    make_ads_kwargs=None,\n    run_static=True,\n    slab_relax_kwargs=None,\n    slab_static_kwargs=None,\n)\n</code></pre> <p>Workflow consisting of:</p> <ol> <li> <p>Slab-adsorbate generation</p> </li> <li> <p>Slab-adsorbate relaxations</p> </li> <li> <p>Slab-adsorbate statics (optional)</p> </li> </ol> <p>Parameters:</p> <ul> <li> <code>slab</code>             (<code>Atoms</code>)         \u2013          <p>Atoms object for the slab structure.</p> </li> <li> <code>adsorbate</code>             (<code>Atoms</code>)         \u2013          <p>Atoms object for the adsorbate.</p> </li> <li> <code>make_ads_kwargs</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional keyword arguments to pass to quacc.atoms.slabs.make_adsorbate_structures</p> </li> <li> <code>run_static</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to run the static calculation.</p> </li> <li> <code>slab_relax_kwargs</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional keyword arguments to pass to quacc.recipes.vasp.slabs.slab_relax_job.</p> </li> <li> <code>slab_static_kwargs</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional keyword arguments to pass to quacc.recipes.vasp.slabs.slab_static_job.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[VaspSchema]</code>         \u2013          <p>List of dictionaries of results from quacc.schemas.vasp.vasp_summarize_run</p> </li> </ul> Source code in <code>quacc/recipes/vasp/slabs.py</code> <pre><code>@flow\ndef slab_to_ads_flow(\n    slab: Atoms,\n    adsorbate: Atoms,\n    make_ads_kwargs: dict[str, Any] | None = None,\n    run_static: bool = True,\n    slab_relax_kwargs: dict[str, Any] | None = None,\n    slab_static_kwargs: dict[str, Any] | None = None,\n) -&gt; list[VaspSchema]:\n    \"\"\"\n    Workflow consisting of:\n\n    1. Slab-adsorbate generation\n\n    2. Slab-adsorbate relaxations\n\n    3. Slab-adsorbate statics (optional)\n\n    Parameters\n    ----------\n    slab\n        Atoms object for the slab structure.\n    adsorbate\n        Atoms object for the adsorbate.\n    make_ads_kwargs\n        Additional keyword arguments to pass to [quacc.atoms.slabs.make_adsorbate_structures][]\n    run_static\n        Whether to run the static calculation.\n    slab_relax_kwargs\n        Additional keyword arguments to pass to [quacc.recipes.vasp.slabs.slab_relax_job][].\n    slab_static_kwargs\n        Additional keyword arguments to pass to [quacc.recipes.vasp.slabs.slab_static_job][].\n\n    Returns\n    -------\n    list[VaspSchema]\n        List of dictionaries of results from [quacc.schemas.vasp.vasp_summarize_run][]\n    \"\"\"\n\n    make_ads_kwargs = make_ads_kwargs or {}\n    slab_relax_kwargs = slab_relax_kwargs or {}\n    slab_static_kwargs = slab_static_kwargs or {}\n\n    return slab_to_ads_subflow(\n        slab,\n        adsorbate,\n        partial(slab_relax_job, **slab_relax_kwargs),\n        static_job=partial(slab_static_job, **slab_static_kwargs)\n        if run_static\n        else None,\n        make_ads_fn=partial(make_adsorbate_structures, **make_ads_kwargs),\n    )\n</code></pre>"},{"location":"reference/quacc/runners/ase.html","title":"ase","text":"<p>Utility functions for running ASE calculators with ASE-based methods.</p>"},{"location":"reference/quacc/runners/ase.html#quacc.runners.ase.run_calc","title":"run_calc","text":"<pre><code>run_calc(atoms, geom_file=None, copy_files=None)\n</code></pre> <p>Run a calculation in a scratch directory and copy the results back to the original directory. This can be useful if file I/O is slow in the working directory, so long as file transfer speeds are reasonable.</p> <p>This is a wrapper around atoms.get_potential_energy(). Note: This function does not modify the atoms object in-place.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>The Atoms object to run the calculation on.</p> </li> <li> <code>geom_file</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>The filename of the log file that contains the output geometry, used to update the atoms object's positions and cell after a job. It is better to specify this rather than relying on ASE's atoms.get_potential_energy() function to update the positions, as this varies between codes.</p> </li> <li> <code>copy_files</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Filenames to copy from source to scratch directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Atoms</code>         \u2013          <p>The updated Atoms object.</p> </li> </ul> Source code in <code>quacc/runners/ase.py</code> <pre><code>def run_calc(\n    atoms: Atoms, geom_file: str | None = None, copy_files: list[str] | None = None\n) -&gt; Atoms:\n    \"\"\"\n    Run a calculation in a scratch directory and copy the results back to the original\n    directory. This can be useful if file I/O is slow in the working directory, so long\n    as file transfer speeds are reasonable.\n\n    This is a wrapper around atoms.get_potential_energy(). Note: This function\n    does not modify the atoms object in-place.\n\n    Parameters\n    ----------\n    atoms\n        The Atoms object to run the calculation on.\n    geom_file\n        The filename of the log file that contains the output geometry, used to\n        update the atoms object's positions and cell after a job. It is better\n        to specify this rather than relying on ASE's\n        atoms.get_potential_energy() function to update the positions, as this\n        varies between codes.\n    copy_files\n        Filenames to copy from source to scratch directory.\n\n    Returns\n    -------\n    Atoms\n        The updated Atoms object.\n    \"\"\"\n\n    # Copy atoms so we don't modify it in-place\n    atoms = copy_atoms(atoms)\n\n    # Perform staging operations\n    tmpdir, job_results_dir = calc_setup(copy_files=copy_files)\n\n    # Run calculation via get_potential_energy()\n    atoms.get_potential_energy()\n\n    # Most ASE calculators do not update the atoms object in-place with a call\n    # to .get_potential_energy(), which is important if an internal optimizer is\n    # used. This section is done to ensure that the atoms object is updated with\n    # the correct positions and cell if a `geom_file` is provided.\n    if geom_file:\n        # Note: We have to be careful to make sure we don't lose the converged\n        # magnetic moments, if present. That's why we simply update the\n        # positions and cell in-place.\n        atoms_new = read(zpath(tmpdir / geom_file))\n        if isinstance(atoms_new, list):\n            atoms_new = atoms_new[-1]\n\n        # Make sure the atom indices didn't get updated somehow (sanity check).\n        # If this happens, there is a serious problem.\n        if (\n            np.array_equal(atoms_new.get_atomic_numbers(), atoms.get_atomic_numbers())\n            is False\n        ):\n            raise ValueError(\"Atomic numbers do not match between atoms and geom_file.\")\n\n        atoms.positions = atoms_new.positions\n        atoms.cell = atoms_new.cell\n\n    # Perform cleanup operations\n    calc_cleanup(tmpdir, job_results_dir)\n\n    return atoms\n</code></pre>"},{"location":"reference/quacc/runners/ase.html#quacc.runners.ase.run_opt","title":"run_opt","text":"<pre><code>run_opt(\n    atoms,\n    relax_cell=False,\n    fmax=0.01,\n    max_steps=500,\n    optimizer=FIRE,\n    optimizer_kwargs=None,\n    run_kwargs=None,\n    copy_files=None,\n)\n</code></pre> <p>Run an ASE-based optimization in a scratch directory and copy the results back to the original directory. This can be useful if file I/O is slow in the working directory, so long as file transfer speeds are reasonable.</p> <p>This is a wrapper around the optimizers in ASE. Note: This function does not modify the atoms object in-place.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>The Atoms object to run the calculation on.</p> </li> <li> <code>fmax</code>             (<code>float</code>, default:                 <code>0.01</code> )         \u2013          <p>Tolerance for the force convergence (in eV/A).</p> </li> <li> <code>max_steps</code>             (<code>int</code>, default:                 <code>500</code> )         \u2013          <p>Maximum number of steps to take.</p> </li> <li> <code>optimizer</code>             (<code>Optimizer</code>, default:                 <code>FIRE</code> )         \u2013          <p>Optimizer class to use.</p> </li> <li> <code>optimizer_kwargs</code>             (<code>OptimizerKwargs | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of kwargs for the optimizer. Takes all valid kwargs for ASE Optimizer classes. Refer to <code>_set_sella_kwargs</code> for Sella-related kwargs and how they are set.</p> </li> <li> <code>run_kwargs</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of kwargs for the run() method of the optimizer.</p> </li> <li> <code>copy_files</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Filenames to copy from source to scratch directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optimizer</code>         \u2013          <p>The ASE Optimizer object.</p> </li> </ul> Source code in <code>quacc/runners/ase.py</code> <pre><code>def run_opt(\n    atoms: Atoms,\n    relax_cell: bool = False,\n    fmax: float = 0.01,\n    max_steps: int = 500,\n    optimizer: Optimizer = FIRE,\n    optimizer_kwargs: OptimizerKwargs | None = None,\n    run_kwargs: dict[str, Any] | None = None,\n    copy_files: list[str] | None = None,\n) -&gt; Optimizer:\n    \"\"\"\n    Run an ASE-based optimization in a scratch directory and copy the results back to\n    the original directory. This can be useful if file I/O is slow in the working\n    directory, so long as file transfer speeds are reasonable.\n\n    This is a wrapper around the optimizers in ASE. Note: This function does not\n    modify the atoms object in-place.\n\n    Parameters\n    ----------\n    atoms\n        The Atoms object to run the calculation on.\n    fmax\n        Tolerance for the force convergence (in eV/A).\n    max_steps\n        Maximum number of steps to take.\n    optimizer\n        Optimizer class to use.\n    optimizer_kwargs\n        Dictionary of kwargs for the optimizer. Takes all valid kwargs for ASE\n        Optimizer classes. Refer to `_set_sella_kwargs` for Sella-related\n        kwargs and how they are set.\n    run_kwargs\n        Dictionary of kwargs for the run() method of the optimizer.\n    copy_files\n        Filenames to copy from source to scratch directory.\n\n    Returns\n    -------\n    Optimizer\n        The ASE Optimizer object.\n    \"\"\"\n\n    # Copy atoms so we don't modify it in-place\n    atoms = copy_atoms(atoms)\n\n    # Set defaults\n    optimizer_kwargs = optimizer_kwargs or {}\n    run_kwargs = run_kwargs or {}\n\n    # Check if trajectory kwarg is specified\n    if \"trajectory\" in optimizer_kwargs:\n        msg = \"Quacc does not support setting the `trajectory` kwarg.\"\n        raise ValueError(msg)\n\n    # Perform staging operations\n    tmpdir, job_results_dir = calc_setup(copy_files=copy_files)\n\n    # Set Sella kwargs\n    if optimizer.__name__ == \"Sella\":\n        _set_sella_kwargs(atoms, optimizer_kwargs)\n    optimizer_kwargs.pop(\"use_TRICs\", None)\n\n    # Define the Trajectory object\n    traj_filename = tmpdir / \"opt.traj\"\n    traj = Trajectory(traj_filename, \"w\", atoms=atoms)\n    optimizer_kwargs[\"trajectory\"] = traj\n\n    # Set volume relaxation constraints, if relevant\n    if relax_cell and atoms.pbc.any():\n        atoms = FrechetCellFilter(atoms)\n\n    # Run calculation\n    with traj, optimizer(atoms, **optimizer_kwargs) as dyn:\n        dyn.run(fmax=fmax, steps=max_steps, **run_kwargs)\n\n    # Store the trajectory atoms\n    dyn.traj_atoms = read(traj_filename, index=\":\")\n\n    # Perform cleanup operations\n    calc_cleanup(tmpdir, job_results_dir)\n\n    return dyn\n</code></pre>"},{"location":"reference/quacc/runners/ase.html#quacc.runners.ase.run_vib","title":"run_vib","text":"<pre><code>run_vib(atoms, vib_kwargs=None, copy_files=None)\n</code></pre> <p>Run an ASE-based vibration analysis in a scratch directory and copy the results back to the original directory. This can be useful if file I/O is slow in the working directory, so long as file transfer speeds are reasonable.</p> <p>This is a wrapper around the vibrations module in ASE. Note: This function does not modify the atoms object in-place.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>The Atoms object to run the calculation on.</p> </li> <li> <code>vib_kwargs</code>             (<code>VibKwargs | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of kwargs for the <code>ase.vibrations.Vibrations</code> class.</p> </li> <li> <code>copy_files</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Filenames to copy from source to scratch directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Vibrations</code>         \u2013          <p>The updated Vibrations module</p> </li> </ul> Source code in <code>quacc/runners/ase.py</code> <pre><code>def run_vib(\n    atoms: Atoms,\n    vib_kwargs: VibKwargs | None = None,\n    copy_files: list[str] | None = None,\n) -&gt; Vibrations:\n    \"\"\"\n    Run an ASE-based vibration analysis in a scratch directory and copy the results back\n    to the original directory. This can be useful if file I/O is slow in the working\n    directory, so long as file transfer speeds are reasonable.\n\n    This is a wrapper around the vibrations module in ASE. Note: This function\n    does not modify the atoms object in-place.\n\n    Parameters\n    ----------\n    atoms\n        The Atoms object to run the calculation on.\n    vib_kwargs\n        Dictionary of kwargs for the `ase.vibrations.Vibrations` class.\n    copy_files\n        Filenames to copy from source to scratch directory.\n\n    Returns\n    -------\n    Vibrations\n        The updated Vibrations module\n    \"\"\"\n\n    # Copy atoms so we don't modify it in-place\n    atoms = copy_atoms(atoms)\n\n    # Set defaults\n    vib_kwargs = vib_kwargs or {}\n\n    # Perform staging operations\n    tmpdir, job_results_dir = calc_setup(copy_files=copy_files)\n\n    # Run calculation\n    vib = Vibrations(atoms, name=str(tmpdir / \"vib\"), **vib_kwargs)\n    vib.run()\n\n    # Summarize run\n    vib.summary(log=str(tmpdir / \"vib_summary.log\"))\n\n    # Perform cleanup operations\n    calc_cleanup(tmpdir, job_results_dir)\n\n    return vib\n</code></pre>"},{"location":"reference/quacc/runners/prep.html","title":"prep","text":"<p>Prepration for runners</p>"},{"location":"reference/quacc/runners/prep.html#quacc.runners.prep.calc_cleanup","title":"calc_cleanup","text":"<pre><code>calc_cleanup(tmpdir, job_results_dir)\n</code></pre> <p>Perform cleanup operations for a calculation, including gzipping files, copying files back to the original directory, and removing the tmpdir.</p> <p>Parameters:</p> <ul> <li> <code>tmpdir</code>             (<code>str | Path</code>)         \u2013          <p>The path to the tmpdir, where the calculation will be run. It will be deleted after the calculation is complete.</p> </li> <li> <code>job_results_dir</code>             (<code>str | Path</code>)         \u2013          <p>The path to the job_results_dir, where the files will ultimately be stored. A symlink to the tmpdir will be made here during the calculation for convenience.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          </li> </ul> Source code in <code>quacc/runners/prep.py</code> <pre><code>def calc_cleanup(tmpdir: str | Path, job_results_dir: str | Path) -&gt; None:\n    \"\"\"\n    Perform cleanup operations for a calculation, including gzipping files, copying\n    files back to the original directory, and removing the tmpdir.\n\n    Parameters\n    ----------\n    tmpdir\n        The path to the tmpdir, where the calculation will be run. It will be\n        deleted after the calculation is complete.\n    job_results_dir\n        The path to the job_results_dir, where the files will ultimately be\n        stored. A symlink to the tmpdir will be made here during the calculation\n        for convenience.\n\n    Returns\n    -------\n    None\n    \"\"\"\n\n    # Change to the results directory\n    os.chdir(job_results_dir)\n\n    # Gzip files in tmpdir\n    if SETTINGS.GZIP_FILES:\n        gzip_dir(tmpdir)\n\n    # Copy files back to job_results_dir\n    copy_r(tmpdir, job_results_dir)\n\n    # Remove symlink to tmpdir\n    symlink_path = job_results_dir / f\"{tmpdir.name}-symlink\"\n    symlink_path.unlink(missing_ok=True)\n\n    # Remove the tmpdir\n    rmtree(tmpdir, ignore_errors=True)\n</code></pre>"},{"location":"reference/quacc/runners/prep.html#quacc.runners.prep.calc_setup","title":"calc_setup","text":"<pre><code>calc_setup(copy_files=None)\n</code></pre> <p>Perform staging operations for a calculation, including copying files to the scratch directory, setting the calculator's directory, decompressing files, and creating a symlink to the scratch directory.</p> <p>Parameters:</p> <ul> <li> <code>copy_files</code>             (<code>list[str | Path] | None</code>, default:                 <code>None</code> )         \u2013          <p>Filenames to copy from source to scratch directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Path</code>         \u2013          <p>The path to the tmpdir, where the calculation will be run. It will be deleted after the calculation is complete.</p> </li> <li> <code>Path</code>         \u2013          <p>The path to the results_dir, where the files will ultimately be stored. A symlink to the tmpdir will be made here during the calculation for convenience.</p> </li> </ul> Source code in <code>quacc/runners/prep.py</code> <pre><code>def calc_setup(copy_files: list[str | Path] | None = None) -&gt; tuple[Path, Path]:\n    \"\"\"\n    Perform staging operations for a calculation, including copying files to the scratch\n    directory, setting the calculator's directory, decompressing files, and creating a\n    symlink to the scratch directory.\n\n    Parameters\n    ----------\n    copy_files\n        Filenames to copy from source to scratch directory.\n\n    Returns\n    -------\n    Path\n        The path to the tmpdir, where the calculation will be run. It will be\n        deleted after the calculation is complete.\n    Path\n        The path to the results_dir, where the files will ultimately be stored.\n        A symlink to the tmpdir will be made here during the calculation for\n        convenience.\n    \"\"\"\n\n    # Set where to store the results\n    job_results_dir = (\n        make_unique_dir(base_path=SETTINGS.RESULTS_DIR)\n        if SETTINGS.CREATE_UNIQUE_WORKDIR\n        else SETTINGS.RESULTS_DIR\n    )\n\n    # Create a tmpdir for the calculation within the scratch_dir\n    time_now = datetime.now(timezone.utc).strftime(\"%Y-%m-%d-%H-%M-%S-%f\")\n    tmpdir = Path(\n        mkdtemp(prefix=f\"quacc-tmp-{time_now}-\", dir=SETTINGS.SCRATCH_DIR)\n    ).resolve()\n\n    # Create a symlink to the tmpdir in the results_dir\n    if os.name != \"nt\" and SETTINGS.SCRATCH_DIR != SETTINGS.RESULTS_DIR:\n        symlink = job_results_dir / f\"{tmpdir.name}-symlink\"\n        symlink.unlink(missing_ok=True)\n        symlink.symlink_to(tmpdir, target_is_directory=True)\n\n    # Copy files to tmpdir and decompress them if needed\n    if copy_files:\n        copy_decompress(copy_files, tmpdir)\n\n    os.chdir(tmpdir)\n\n    return tmpdir, job_results_dir\n</code></pre>"},{"location":"reference/quacc/runners/thermo.html","title":"thermo","text":"<p>Utility functions for thermochemistry.</p>"},{"location":"reference/quacc/runners/thermo.html#quacc.runners.thermo.run_ideal_gas","title":"run_ideal_gas","text":"<pre><code>run_ideal_gas(\n    atoms, vib_freqs, energy=0.0, spin_multiplicity=None\n)\n</code></pre> <p>Create an IdealGasThermo object for a molecule from a given vibrational analysis. This is for free gases only and will not be valid for solids or adsorbates on surfaces. Any imaginary vibrational modes after the 3N-5/3N-6 cut will simply be ignored.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>The Atoms object associated with the vibrational analysis.</p> </li> <li> <code>vib_freqs</code>             (<code>list[float | complex]</code>)         \u2013          <p>The list of vibrations to use in cm^-1, typically obtained from Vibrations.get_frequencies().</p> </li> <li> <code>energy</code>             (<code>float</code>, default:                 <code>0.0</code> )         \u2013          <p>Potential energy in eV. If 0 eV, then the thermochemical correction is computed.</p> </li> <li> <code>spin_multiplicity</code>             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>The spin multiplicity (2S+1). If None, this will be determined automatically from the attached magnetic moments.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>IdealGasThermo object</code>         \u2013          </li> </ul> Source code in <code>quacc/runners/thermo.py</code> <pre><code>def run_ideal_gas(\n    atoms: Atoms,\n    vib_freqs: list[float | complex],\n    energy: float = 0.0,\n    spin_multiplicity: int | None = None,\n) -&gt; IdealGasThermo:\n    \"\"\"\n    Create an IdealGasThermo object for a molecule from a given vibrational analysis.\n    This is for free gases only and will not be valid for solids or adsorbates on\n    surfaces. Any imaginary vibrational modes after the 3N-5/3N-6 cut will simply be\n    ignored.\n\n    Parameters\n    ----------\n    atoms\n        The Atoms object associated with the vibrational analysis.\n    vib_freqs\n        The list of vibrations to use in cm^-1, typically obtained from\n        Vibrations.get_frequencies().\n    energy\n        Potential energy in eV. If 0 eV, then the thermochemical correction is\n        computed.\n    spin_multiplicity\n        The spin multiplicity (2S+1). If None, this will be determined\n        automatically from the attached magnetic moments.\n\n    Returns\n    -------\n    IdealGasThermo object\n    \"\"\"\n\n    # Switch off PBC since this is only for molecules\n    atoms.set_pbc(False)\n\n    # Ensure all negative modes are made complex\n    for i, f in enumerate(vib_freqs):\n        if not isinstance(f, complex) and f &lt; 0:\n            vib_freqs[i] = complex(0 - f * 1j)\n\n    # Convert vibrational frequencies to energies\n    vib_energies = [f * units.invcm for f in vib_freqs]\n\n    # Get the spin from the Atoms object.\n    if spin_multiplicity:\n        spin = (spin_multiplicity - 1) / 2\n    elif (\n        getattr(atoms, \"calc\", None) is not None\n        and getattr(atoms.calc, \"results\", None) is not None\n        and atoms.calc.results.get(\"magmom\", None) is not None\n    ):\n        spin = round(atoms.calc.results[\"magmom\"]) / 2\n    elif (\n        getattr(atoms, \"calc\", None) is not None\n        and getattr(atoms.calc, \"results\", None) is not None\n        and atoms.calc.results.get(\"magmoms\", None) is not None\n    ):\n        spin = round(np.sum(atoms.calc.results[\"magmoms\"])) / 2\n    elif atoms.has(\"initial_magmoms\"):\n        spin = round(np.sum(atoms.get_initial_magnetic_moments())) / 2\n    else:\n        spin = 0\n\n    # Get symmetry for later use\n    natoms = len(atoms)\n    metadata = atoms_to_metadata(atoms)\n\n    # Get the geometry\n    if natoms == 1:\n        geometry = \"monatomic\"\n    elif metadata[\"symmetry\"][\"linear\"]:\n        geometry = \"linear\"\n    else:\n        geometry = \"nonlinear\"\n\n    return IdealGasThermo(\n        vib_energies,\n        geometry,\n        potentialenergy=energy,\n        atoms=atoms,\n        symmetrynumber=metadata[\"symmetry\"][\"rotation_number\"],\n        spin=spin,\n        ignore_imag_modes=True,\n    )\n</code></pre>"},{"location":"reference/quacc/schemas/ase.html","title":"ase","text":"<p>Schemas for storing ASE-based data.</p>"},{"location":"reference/quacc/schemas/ase.html#quacc.schemas.ase.summarize_ideal_gas_thermo","title":"summarize_ideal_gas_thermo","text":"<pre><code>summarize_ideal_gas_thermo(\n    igt,\n    temperature=298.15,\n    pressure=1.0,\n    charge_and_multiplicity=None,\n    additional_fields=None,\n    store=None,\n)\n</code></pre> <p>Get tabulated results from an ASE IdealGasThermo object and store them in a database-friendly format.</p> <p>Parameters:</p> <ul> <li> <code>igt</code>             (<code>IdealGasThermo</code>)         \u2013          <p>ASE IdealGasThermo object.</p> </li> <li> <code>temperature</code>             (<code>float</code>, default:                 <code>298.15</code> )         \u2013          <p>Temperature in Kelvins.</p> </li> <li> <code>pressure</code>             (<code>float</code>, default:                 <code>1.0</code> )         \u2013          <p>Pressure in bar.</p> </li> <li> <code>charge_and_multiplicity</code>             (<code>tuple[int, int] | None</code>, default:                 <code>None</code> )         \u2013          <p>Charge and spin multiplicity of the Atoms object, only used for Molecule metadata.</p> </li> <li> <code>additional_fields</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional fields to add to the task document.</p> </li> <li> <code>store</code>             (<code>Store | bool | None</code>, default:                 <code>None</code> )         \u2013          <p>Maggma Store object to store the results in. If None, <code>SETTINGS.PRIMARY_STORE</code> will be used.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ThermoSchema</code>         \u2013          <p>Dictionary representation of the task document</p> </li> </ul> Source code in <code>quacc/schemas/ase.py</code> <pre><code>def summarize_ideal_gas_thermo(\n    igt: IdealGasThermo,\n    temperature: float = 298.15,\n    pressure: float = 1.0,\n    charge_and_multiplicity: tuple[int, int] | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    store: Store | bool | None = None,\n) -&gt; ThermoSchema:\n    \"\"\"\n    Get tabulated results from an ASE IdealGasThermo object and store them in a\n    database-friendly format.\n\n    Parameters\n    ----------\n    igt\n        ASE IdealGasThermo object.\n    temperature\n        Temperature in Kelvins.\n    pressure\n        Pressure in bar.\n    charge_and_multiplicity\n        Charge and spin multiplicity of the Atoms object, only used for Molecule\n        metadata.\n    additional_fields\n        Additional fields to add to the task document.\n    store\n        Maggma Store object to store the results in. If None,\n        `SETTINGS.PRIMARY_STORE` will be used.\n\n    Returns\n    -------\n    ThermoSchema\n        Dictionary representation of the task document\n    \"\"\"\n\n    additional_fields = additional_fields or {}\n    store = SETTINGS.PRIMARY_STORE if store is None else store\n\n    uri = get_uri(Path.cwd())\n    spin_multiplicity = round(2 * igt.spin + 1)\n\n    inputs = {\n        \"parameters_thermo\": {\n            \"temperature\": temperature,\n            \"pressure\": pressure,\n            \"sigma\": igt.sigma,\n            \"spin_multiplicity\": spin_multiplicity,\n            \"vib_freqs\": [e / units.invcm for e in igt.vib_energies],\n            \"vib_energies\": igt.vib_energies.tolist(),\n            \"n_imag\": igt.n_imag,\n        },\n        \"nid\": uri.split(\":\")[0],\n        \"dir_name\": \":\".join(uri.split(\":\")[1:]),\n    }\n\n    results = {\n        \"results\": {\n            \"energy\": igt.potentialenergy,\n            \"enthalpy\": igt.get_enthalpy(temperature),\n            \"entropy\": igt.get_entropy(temperature, pressure * 10**5),\n            \"gibbs_energy\": igt.get_gibbs_energy(temperature, pressure * 10**5),\n            \"zpe\": igt.get_ZPE_correction(),\n        }\n    }\n\n    if charge_and_multiplicity and spin_multiplicity != charge_and_multiplicity[1]:\n        msg = (\n            \"The IdealGasThermo spin multiplicity does not match the user-specified multiplicity.\",\n        )\n        raise ValueError(msg)\n\n    atoms_metadata = atoms_to_metadata(\n        igt.atoms, charge_and_multiplicity=charge_and_multiplicity\n    )\n\n    unsorted_task_doc = merge_several_dicts(\n        atoms_metadata, inputs, results, additional_fields\n    )\n    task_doc = sort_dict(unsorted_task_doc)\n\n    if store:\n        results_to_db(store, task_doc)\n\n    return task_doc\n</code></pre>"},{"location":"reference/quacc/schemas/ase.html#quacc.schemas.ase.summarize_opt_run","title":"summarize_opt_run","text":"<pre><code>summarize_opt_run(\n    dyn,\n    trajectory=None,\n    check_convergence=None,\n    charge_and_multiplicity=None,\n    prep_next_run=True,\n    additional_fields=None,\n    store=None,\n)\n</code></pre> <p>Get tabulated results from an ASE Atoms trajectory and store them in a database- friendly format. This is meant to be compatible with all calculator types.</p> <p>Parameters:</p> <ul> <li> <code>dyn</code>             (<code>Optimizer</code>)         \u2013          <p>ASE Optimizer object.</p> </li> <li> <code>trajectory</code>             (<code>Trajectory | list[Atoms]</code>, default:                 <code>None</code> )         \u2013          <p>ASE Trajectory object or list[Atoms] from reading a trajectory file. If None, the trajectory must be found in dyn.traj_atoms.</p> </li> <li> <code>check_convergence</code>             (<code>bool | None</code>, default:                 <code>None</code> )         \u2013          <p>Whether to check the convergence of the calculation. Defaults to True in settings.</p> </li> <li> <code>charge_and_multiplicity</code>             (<code>tuple[int, int] | None</code>, default:                 <code>None</code> )         \u2013          <p>Charge and spin multiplicity of the Atoms object, only used for Molecule metadata.</p> </li> <li> <code>prep_next_run</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether the Atoms object stored in {\"atoms\": atoms} should be prepared for the next run This clears out any attached calculator and moves the final magmoms to the initial magmoms.</p> </li> <li> <code>additional_fields</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional fields to add to the task document.</p> </li> <li> <code>store</code>             (<code>Store | bool | None</code>, default:                 <code>None</code> )         \u2013          <p>Maggma Store object to store the results in. If None, <code>SETTINGS.PRIMARY_STORE</code> will be used.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OptSchema</code>         \u2013          <p>Dictionary representation of the task document</p> </li> </ul> Source code in <code>quacc/schemas/ase.py</code> <pre><code>def summarize_opt_run(\n    dyn: Optimizer,\n    trajectory: Trajectory | list[Atoms] = None,\n    check_convergence: bool | None = None,\n    charge_and_multiplicity: tuple[int, int] | None = None,\n    prep_next_run: bool = True,\n    additional_fields: dict[str, Any] | None = None,\n    store: Store | bool | None = None,\n) -&gt; OptSchema:\n    \"\"\"\n    Get tabulated results from an ASE Atoms trajectory and store them in a database-\n    friendly format. This is meant to be compatible with all calculator types.\n\n    Parameters\n    ----------\n    dyn\n        ASE Optimizer object.\n    trajectory\n        ASE Trajectory object or list[Atoms] from reading a trajectory file. If\n        None, the trajectory must be found in dyn.traj_atoms.\n    check_convergence\n        Whether to check the convergence of the calculation. Defaults to True in\n        settings.\n    charge_and_multiplicity\n        Charge and spin multiplicity of the Atoms object, only used for Molecule\n        metadata.\n    prep_next_run\n        Whether the Atoms object stored in {\"atoms\": atoms} should be prepared\n        for the next run This clears out any attached calculator and moves the\n        final magmoms to the initial magmoms.\n    additional_fields\n        Additional fields to add to the task document.\n    store\n        Maggma Store object to store the results in. If None,\n        `SETTINGS.PRIMARY_STORE` will be used.\n\n    Returns\n    -------\n    OptSchema\n        Dictionary representation of the task document\n    \"\"\"\n\n    check_convergence = (\n        SETTINGS.CHECK_CONVERGENCE if check_convergence is None else check_convergence\n    )\n    additional_fields = additional_fields or {}\n    store = SETTINGS.PRIMARY_STORE if store is None else store\n\n    # Check convergence\n    is_converged = dyn.converged()\n    if check_convergence and not is_converged:\n        msg = f\"Optimization did not converge. Refer to {Path.cwd()}\"\n        raise RuntimeError(msg)\n\n    # Get trajectory\n    if not trajectory:\n        trajectory = (\n            dyn.traj_atoms\n            if hasattr(dyn, \"traj_atoms\")\n            else read(dyn.trajectory.filename, index=\":\")\n        )\n\n    initial_atoms = trajectory[0]\n    final_atoms = dyn.atoms.atoms if isinstance(dyn.atoms, Filter) else dyn.atoms\n\n    # Base task doc\n    base_task_doc = summarize_run(\n        final_atoms,\n        input_atoms=initial_atoms,\n        charge_and_multiplicity=charge_and_multiplicity,\n        prep_next_run=prep_next_run,\n        store=False,\n    )\n\n    opt_fields = {\n        \"fmax\": getattr(dyn, \"fmax\", None),\n        \"parameters_opt\": dyn.todict(),\n        \"converged\": is_converged,\n        \"nsteps\": dyn.get_number_of_steps(),\n        \"trajectory\": [\n            atoms_to_metadata(atoms, charge_and_multiplicity=charge_and_multiplicity)\n            for atoms in trajectory\n        ],\n        \"trajectory_results\": [atoms.calc.results for atoms in trajectory],\n    }\n\n    # Create a dictionary of the inputs/outputs\n    unsorted_task_doc = merge_several_dicts(\n        base_task_doc, opt_fields, additional_fields\n    )\n    task_doc = sort_dict(unsorted_task_doc)\n\n    if store:\n        results_to_db(store, task_doc)\n\n    return task_doc\n</code></pre>"},{"location":"reference/quacc/schemas/ase.html#quacc.schemas.ase.summarize_run","title":"summarize_run","text":"<pre><code>summarize_run(\n    atoms,\n    input_atoms=None,\n    charge_and_multiplicity=None,\n    prep_next_run=True,\n    additional_fields=None,\n    store=None,\n)\n</code></pre> <p>Get tabulated results from an Atoms object and calculator and store them in a database-friendly format. This is meant to be compatible with all calculator types.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>ASE Atoms following a calculation. A calculator must be attached.</p> </li> <li> <code>input_atoms</code>             (<code>Atoms | None</code>, default:                 <code>None</code> )         \u2013          <p>Input ASE Atoms object to store.</p> </li> <li> <code>charge_and_multiplicity</code>             (<code>tuple[int, int] | None</code>, default:                 <code>None</code> )         \u2013          <p>Charge and spin multiplicity of the Atoms object, only used for Molecule metadata.</p> </li> <li> <code>prep_next_run</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether the Atoms object stored in <code>{\"atoms\": atoms}</code> should be prepared for the next run. This clears out any attached calculator and moves the final magmoms to the initial magmoms.</p> </li> <li> <code>additional_fields</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional fields to add to the task document.</p> </li> <li> <code>store</code>             (<code>Store | bool | None</code>, default:                 <code>None</code> )         \u2013          <p>Maggma Store object to store the results in. If None, <code>SETTINGS.PRIMARY_STORE</code> will be used.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>         \u2013          <p>Dictionary representation of the task document</p> </li> </ul> Source code in <code>quacc/schemas/ase.py</code> <pre><code>def summarize_run(\n    atoms: Atoms,\n    input_atoms: Atoms | None = None,\n    charge_and_multiplicity: tuple[int, int] | None = None,\n    prep_next_run: bool = True,\n    additional_fields: dict[str, Any] | None = None,\n    store: Store | bool | None = None,\n) -&gt; RunSchema:\n    \"\"\"\n    Get tabulated results from an Atoms object and calculator and store them in a\n    database-friendly format. This is meant to be compatible with all calculator types.\n\n    Parameters\n    ----------\n    atoms\n        ASE Atoms following a calculation. A calculator must be attached.\n    input_atoms\n        Input ASE Atoms object to store.\n    charge_and_multiplicity\n        Charge and spin multiplicity of the Atoms object, only used for Molecule\n        metadata.\n    prep_next_run\n        Whether the Atoms object stored in `{\"atoms\": atoms}` should be prepared\n        for the next run. This clears out any attached calculator and moves the\n        final magmoms to the initial magmoms.\n    additional_fields\n        Additional fields to add to the task document.\n    store\n        Maggma Store object to store the results in. If None,\n        `SETTINGS.PRIMARY_STORE` will be used.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary representation of the task document\n    \"\"\"\n\n    additional_fields = additional_fields or {}\n    store = SETTINGS.PRIMARY_STORE if store is None else store\n\n    if not atoms.calc:\n        msg = \"ASE Atoms object has no attached calculator.\"\n        raise ValueError(msg)\n    if not atoms.calc.results:\n        msg = \"ASE Atoms object's calculator has no results.\"\n        raise ValueError(msg)\n\n    uri = get_uri(Path.cwd())\n    input_atoms_metadata = (\n        atoms_to_metadata(input_atoms, charge_and_multiplicity=charge_and_multiplicity)\n        if input_atoms\n        else None\n    )\n    inputs = {\n        \"parameters\": atoms.calc.parameters,\n        \"nid\": uri.split(\":\")[0],\n        \"dir_name\": \":\".join(uri.split(\":\")[1:]),\n        \"input_atoms\": input_atoms_metadata,\n    }\n\n    results = {\"results\": atoms.calc.results}\n\n    atoms_to_store = prep_next_run_(atoms) if prep_next_run else atoms\n    final_atoms_metadata = atoms_to_metadata(\n        atoms_to_store, charge_and_multiplicity=charge_and_multiplicity\n    )\n\n    unsorted_task_doc = merge_several_dicts(\n        final_atoms_metadata, inputs, results, additional_fields\n    )\n    task_doc = sort_dict(unsorted_task_doc)\n\n    if store:\n        results_to_db(store, task_doc)\n\n    return task_doc\n</code></pre>"},{"location":"reference/quacc/schemas/ase.html#quacc.schemas.ase.summarize_vib_and_thermo","title":"summarize_vib_and_thermo","text":"<pre><code>summarize_vib_and_thermo(\n    vib,\n    igt,\n    temperature=298.15,\n    pressure=1.0,\n    charge_and_multiplicity=None,\n    additional_fields=None,\n    store=None,\n)\n</code></pre> <p>Get tabulated results from an ASE Vibrations run and ASE IdealGasThermo object and store them in a database-friendly format.</p> <p>Parameters:</p> <ul> <li> <code>vib</code>             (<code>Vibrations</code>)         \u2013          <p>ASE Vibrations object.</p> </li> <li> <code>igt</code>             (<code>IdealGasThermo</code>)         \u2013          <p>ASE IdealGasThermo object.</p> </li> <li> <code>temperature</code>             (<code>float</code>, default:                 <code>298.15</code> )         \u2013          <p>Temperature in Kelvins.</p> </li> <li> <code>pressure</code>             (<code>float</code>, default:                 <code>1.0</code> )         \u2013          <p>Pressure in bar.</p> </li> <li> <code>charge_and_multiplicity</code>             (<code>tuple[int, int] | None</code>, default:                 <code>None</code> )         \u2013          <p>Charge and spin multiplicity of the Atoms object, only used for Molecule metadata.</p> </li> <li> <code>additional_fields</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional fields to add to the task document.</p> </li> <li> <code>store</code>             (<code>Store | bool | None</code>, default:                 <code>None</code> )         \u2013          <p>Maggma Store object to store the results in. If None, <code>SETTINGS.PRIMARY_STORE</code> will be used.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>VibThermoSchema</code>         \u2013          <p>A dictionary that merges the <code>VibSchema</code> and <code>ThermoSchema</code>.</p> </li> </ul> Source code in <code>quacc/schemas/ase.py</code> <pre><code>def summarize_vib_and_thermo(\n    vib: Vibrations,\n    igt: IdealGasThermo,\n    temperature: float = 298.15,\n    pressure: float = 1.0,\n    charge_and_multiplicity: tuple[int, int] | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    store: Store | bool | None = None,\n) -&gt; VibThermoSchema:\n    \"\"\"\n    Get tabulated results from an ASE Vibrations run and ASE IdealGasThermo object and\n    store them in a database-friendly format.\n\n    Parameters\n    ----------\n    vib\n        ASE Vibrations object.\n    igt\n        ASE IdealGasThermo object.\n    temperature\n        Temperature in Kelvins.\n    pressure\n        Pressure in bar.\n    charge_and_multiplicity\n        Charge and spin multiplicity of the Atoms object, only used for Molecule\n        metadata.\n    additional_fields\n        Additional fields to add to the task document.\n    store\n        Maggma Store object to store the results in. If None,\n        `SETTINGS.PRIMARY_STORE` will be used.\n\n    Returns\n    -------\n    VibThermoSchema\n        A dictionary that merges the `VibSchema` and `ThermoSchema`.\n    \"\"\"\n    additional_fields = additional_fields or {}\n    store = SETTINGS.PRIMARY_STORE if store is None else store\n\n    vib_task_doc = summarize_vib_run(\n        vib, charge_and_multiplicity=charge_and_multiplicity, store=False\n    )\n    thermo_task_doc = summarize_ideal_gas_thermo(\n        igt,\n        temperature=temperature,\n        pressure=pressure,\n        charge_and_multiplicity=charge_and_multiplicity,\n        store=False,\n    )\n\n    unsorted_task_doc = merge_several_dicts(\n        vib_task_doc, thermo_task_doc, additional_fields\n    )\n    task_doc = sort_dict(unsorted_task_doc)\n\n    if store:\n        results_to_db(store, task_doc)\n\n    return task_doc\n</code></pre>"},{"location":"reference/quacc/schemas/ase.html#quacc.schemas.ase.summarize_vib_run","title":"summarize_vib_run","text":"<pre><code>summarize_vib_run(\n    vib,\n    charge_and_multiplicity=None,\n    additional_fields=None,\n    store=None,\n)\n</code></pre> <p>Get tabulated results from an ASE Vibrations object and store them in a database- friendly format.</p> <p>Parameters:</p> <ul> <li> <code>vib</code>             (<code>Vibrations</code>)         \u2013          <p>ASE Vibrations object.</p> </li> <li> <code>charge_and_multiplicity</code>             (<code>tuple[int, int] | None</code>, default:                 <code>None</code> )         \u2013          <p>Charge and spin multiplicity of the Atoms object, only used for Molecule metadata.</p> </li> <li> <code>additional_fields</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional fields to add to the task document.</p> </li> <li> <code>store</code>             (<code>Store | bool | None</code>, default:                 <code>None</code> )         \u2013          <p>Maggma Store object to store the results in. If None, <code>SETTINGS.PRIMARY_STORE</code> will be used.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>VibSchema</code>         \u2013          <p>Dictionary representation of the task document</p> </li> </ul> Source code in <code>quacc/schemas/ase.py</code> <pre><code>def summarize_vib_run(\n    vib: Vibrations,\n    charge_and_multiplicity: tuple[int, int] | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    store: Store | bool | None = None,\n) -&gt; VibSchema:\n    \"\"\"\n    Get tabulated results from an ASE Vibrations object and store them in a database-\n    friendly format.\n\n    Parameters\n    ----------\n    vib\n        ASE Vibrations object.\n    charge_and_multiplicity\n        Charge and spin multiplicity of the Atoms object, only used for Molecule\n        metadata.\n    additional_fields\n        Additional fields to add to the task document.\n    store\n        Maggma Store object to store the results in. If None,\n        `SETTINGS.PRIMARY_STORE` will be used.\n\n    Returns\n    -------\n    VibSchema\n        Dictionary representation of the task document\n    \"\"\"\n    additional_fields = additional_fields or {}\n    store = SETTINGS.PRIMARY_STORE if store is None else store\n\n    vib_freqs_raw = vib.get_frequencies().tolist()\n    vib_energies_raw = vib.get_energies().tolist()\n\n    # Convert imaginary modes to negative values for DB storage\n    for i, f in enumerate(vib_freqs_raw):\n        if np.imag(f) &gt; 0:\n            vib_freqs_raw[i] = -np.abs(f)\n            vib_energies_raw[i] = -np.abs(vib_energies_raw[i])\n        else:\n            vib_freqs_raw[i] = np.abs(f)\n            vib_energies_raw[i] = np.abs(vib_energies_raw[i])\n\n    atoms = vib._atoms if isinstance(vib, VibrationsData) else vib.atoms\n\n    uri = get_uri(Path.cwd())\n    inputs = {\n        \"parameters\": None\n        if isinstance(vib, VibrationsData)\n        else atoms.calc.parameters,\n        \"parameters_vib\": None\n        if isinstance(vib, VibrationsData)\n        else {\n            \"delta\": vib.delta,\n            \"direction\": vib.direction,\n            \"method\": vib.method,\n            \"ndof\": vib.ndof,\n            \"nfree\": vib.nfree,\n        },\n        \"nid\": uri.split(\":\")[0],\n        \"dir_name\": \":\".join(uri.split(\":\")[1:]),\n    }\n\n    atoms_metadata = atoms_to_metadata(\n        atoms, charge_and_multiplicity=charge_and_multiplicity\n    )\n\n    # Get the true vibrational modes\n    natoms = len(atoms)\n    if natoms == 1:\n        vib_freqs = []\n        vib_energies = []\n    elif atoms.pbc.any():\n        vib_freqs = vib_freqs_raw\n        vib_energies = vib_energies_raw\n    else:\n        # Sort by absolute value\n        vib_freqs_raw_sorted = vib_freqs_raw.copy()\n        vib_energies_raw_sorted = vib_energies_raw.copy()\n        vib_freqs_raw_sorted.sort(key=np.abs)\n        vib_energies_raw_sorted.sort(key=np.abs)\n\n        # Cut the 3N-5 or 3N-6 modes based on their absolute value\n        n_modes = (\n            3 * natoms - 5 if atoms_metadata[\"symmetry\"][\"linear\"] else 3 * natoms - 6\n        )\n        vib_freqs = vib_freqs_raw_sorted[-n_modes:]\n        vib_energies = vib_energies_raw_sorted[-n_modes:]\n\n    imag_vib_freqs = [f for f in vib_freqs if f &lt; 0]\n\n    results = {\n        \"results\": {\n            \"imag_vib_freqs\": imag_vib_freqs,\n            \"n_imag\": len(imag_vib_freqs),\n            \"vib_energies\": vib_energies,\n            \"vib_freqs\": vib_freqs,\n            \"vib_energies_raw\": vib_energies_raw,\n            \"vib_freqs_raw\": vib_freqs_raw,\n        }\n    }\n\n    unsorted_task_doc = merge_several_dicts(\n        atoms_metadata, inputs, results, additional_fields\n    )\n    task_doc = sort_dict(unsorted_task_doc)\n\n    if store:\n        results_to_db(store, task_doc)\n\n    return task_doc\n</code></pre>"},{"location":"reference/quacc/schemas/atoms.html","title":"atoms","text":"<p>Schemas for storing metadata about Atoms objects.</p>"},{"location":"reference/quacc/schemas/atoms.html#quacc.schemas.atoms.atoms_to_metadata","title":"atoms_to_metadata","text":"<pre><code>atoms_to_metadata(\n    atoms,\n    charge_and_multiplicity=None,\n    get_metadata=True,\n    store_pmg=True,\n    additional_fields=None,\n)\n</code></pre> <p>Convert an ASE Atoms object to a dict suitable for storage in MongoDB.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>ASE Atoms object to store in {\"atoms\": atoms}</p> </li> <li> <code>charge_and_multiplicity</code>             (<code>tuple[int, int] | None</code>, default:                 <code>None</code> )         \u2013          <p>Charge and spin multiplicity of the Atoms object, only used for Molecule metadata.</p> </li> <li> <code>get_metadata</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to store atoms metadata in the returned dict.</p> </li> <li> <code>store_pmg</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to store the Pymatgen Structure/Molecule object in {\"structure\": Structure} or {\"molecule\": Molecule}, respectively.</p> </li> <li> <code>additional_fields</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional fields to add to the document.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AtomsSchema</code>         \u2013          <p>Dict of metadata about the Atoms object.</p> </li> </ul> Source code in <code>quacc/schemas/atoms.py</code> <pre><code>def atoms_to_metadata(\n    atoms: Atoms,\n    charge_and_multiplicity: tuple[int, int] | None = None,\n    get_metadata: bool = True,\n    store_pmg: bool = True,\n    additional_fields: dict[str, Any] | None = None,\n) -&gt; AtomsSchema:\n    \"\"\"\n    Convert an ASE Atoms object to a dict suitable for storage in MongoDB.\n\n    Parameters\n    ----------\n    atoms\n        ASE Atoms object to store in {\"atoms\": atoms}\n    charge_and_multiplicity\n        Charge and spin multiplicity of the Atoms object, only used for Molecule\n        metadata.\n    get_metadata\n        Whether to store atoms metadata in the returned dict.\n    store_pmg\n        Whether to store the Pymatgen Structure/Molecule object in {\"structure\":\n        Structure} or {\"molecule\": Molecule}, respectively.\n    additional_fields\n        Additional fields to add to the document.\n\n    Returns\n    -------\n    AtomsSchema\n        Dict of metadata about the Atoms object.\n    \"\"\"\n\n    additional_fields = additional_fields or {}\n    atoms = copy_atoms(atoms)\n    results = {}\n\n    # Get any charge or multiplicity keys\n    if charge_and_multiplicity:\n        atoms.charge = charge_and_multiplicity[0]\n        atoms.spin_multiplicity = charge_and_multiplicity[1]\n\n    # Strip the dummy atoms, if present\n    del atoms[[atom.index for atom in atoms if atom.symbol == \"X\"]]\n\n    # Get Atoms metadata, if requested. emmet already has built-in tools for\n    # generating pymatgen Structure/Molecule metadata, so we'll just use that.\n    if get_metadata:\n        if atoms.pbc.any():\n            struct = AseAtomsAdaptor().get_structure(atoms)\n            metadata = StructureMetadata().from_structure(struct).model_dump()\n            if store_pmg:\n                results[\"structure\"] = struct\n        else:\n            mol = AseAtomsAdaptor().get_molecule(atoms, charge_spin_check=False)\n            metadata = MoleculeMetadata().from_molecule(mol).model_dump()\n            if store_pmg:\n                results[\"molecule\"] = mol\n    else:\n        metadata = {}\n\n    # Copy the info flags as a separate entry in the DB for easy querying\n    results[\"atoms_info\"] = _quacc_sanitize(atoms.info)\n\n    # Store Atoms object\n    results[\"atoms\"] = atoms\n\n    # Combine the metadata and results dictionaries\n    atoms_doc_unsorted = metadata | results | additional_fields\n\n    return sort_dict(remove_dict_nones(atoms_doc_unsorted))\n</code></pre>"},{"location":"reference/quacc/schemas/cclib.html","title":"cclib","text":"<p>Schemas for molecular DFT codes parsed by cclib.</p>"},{"location":"reference/quacc/schemas/cclib.html#quacc.schemas.cclib.cclib_summarize_run","title":"cclib_summarize_run","text":"<pre><code>cclib_summarize_run(\n    atoms,\n    logfile_extensions,\n    dir_path=None,\n    pop_analyses=None,\n    check_convergence=None,\n    prep_next_run=True,\n    additional_fields=None,\n    store=None,\n)\n</code></pre> <p>Get tabulated results from a molecular DFT run and store them in a database-friendly format. This is meant to be a general parser built on top of cclib.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>ASE Atoms object following a calculation.</p> </li> <li> <code>logfile_extensions</code>             (<code>str | list[str]</code>)         \u2013          <p>Possible extensions of the log file (e.g. \".log\", \".out\", \".txt\", \".chk\"). Note that only a partial match is needed. For instance, <code>.log</code> will match <code>.log.gz</code> and <code>.log.1.gz</code>. If multiple files with this extension are found, the one with the most recent change time will be used. For an exact match only, put in the full file name.</p> </li> <li> <code>dir_path</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>The path to the folder containing the calculation outputs. A value of None specifies the current working directory.</p> </li> <li> <code>pop_analyses</code>             (<code>list[Literal['cpsa', 'mpa', 'lpa', 'bickelhaupt', 'density', 'mbo', 'bader', 'ddec6', 'hirshfeld']] | None</code>, default:                 <code>None</code> )         \u2013          <p>The name(s) of any cclib post-processing analysis to run. Note that for bader, ddec6, and hirshfeld, a cube file (.cube, .cub) must reside in dir_path. Supports: \"cpsa\", \"mpa\", \"lpa\", \"bickelhaupt\", \"density\", \"mbo\", \"bader\", \"ddec6\", \"hirshfeld\".</p> </li> <li> <code>check_convergence</code>             (<code>bool | None</code>, default:                 <code>None</code> )         \u2013          <p>Whether to throw an error if geometry optimization convergence is not  reached. Defaults to True in settings.</p> </li> <li> <code>prep_next_run</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether the Atoms object stored in {\"atoms\": atoms} should be prepared for the next run. This clears out any attached calculator and moves the final magmoms to the initial magmoms.</p> </li> <li> <code>additional_fields</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional fields to add to the task document.</p> </li> <li> <code>store</code>             (<code>Store | None</code>, default:                 <code>None</code> )         \u2013          <p>Maggma Store object to store the results in. If None, <code>SETTINGS.PRIMARY_STORE</code> will be used.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>cclibSchema</code>         \u2013          <p>Dictionary representation of the task document</p> </li> </ul> Source code in <code>quacc/schemas/cclib.py</code> <pre><code>def cclib_summarize_run(\n    atoms: Atoms,\n    logfile_extensions: str | list[str],\n    dir_path: str | None = None,\n    pop_analyses: list[\n        Literal[\n            \"cpsa\",\n            \"mpa\",\n            \"lpa\",\n            \"bickelhaupt\",\n            \"density\",\n            \"mbo\",\n            \"bader\",\n            \"ddec6\",\n            \"hirshfeld\",\n        ]\n    ]\n    | None = None,\n    check_convergence: bool | None = None,\n    prep_next_run: bool = True,\n    additional_fields: dict[str, Any] | None = None,\n    store: Store | None = None,\n) -&gt; cclibSchema:\n    \"\"\"\n    Get tabulated results from a molecular DFT run and store them in a database-friendly\n    format. This is meant to be a general parser built on top of cclib.\n\n    Parameters\n    ----------\n    atoms\n        ASE Atoms object following a calculation.\n    logfile_extensions\n        Possible extensions of the log file (e.g. \".log\", \".out\", \".txt\",\n        \".chk\"). Note that only a partial match is needed. For instance, `.log`\n        will match `.log.gz` and `.log.1.gz`. If multiple files with this\n        extension are found, the one with the most recent change time will be\n        used. For an exact match only, put in the full file name.\n    dir_path\n        The path to the folder containing the calculation outputs. A value of\n        None specifies the current working directory.\n    pop_analyses\n        The name(s) of any cclib post-processing analysis to run. Note that for\n        bader, ddec6, and hirshfeld, a cube file (.cube, .cub) must reside in\n        dir_path. Supports: \"cpsa\", \"mpa\", \"lpa\", \"bickelhaupt\", \"density\",\n        \"mbo\", \"bader\", \"ddec6\", \"hirshfeld\".\n    check_convergence\n         Whether to throw an error if geometry optimization convergence is not\n         reached. Defaults to True in settings.\n    prep_next_run\n        Whether the Atoms object stored in {\"atoms\": atoms} should be prepared\n        for the next run. This clears out any attached calculator and moves the\n        final magmoms to the initial magmoms.\n    additional_fields\n        Additional fields to add to the task document.\n    store\n        Maggma Store object to store the results in. If None,\n        `SETTINGS.PRIMARY_STORE` will be used.\n\n    Returns\n    -------\n    cclibSchema\n        Dictionary representation of the task document\n    \"\"\"\n\n    dir_path = dir_path or Path.cwd()\n    check_convergence = (\n        SETTINGS.CHECK_CONVERGENCE if check_convergence is None else check_convergence\n    )\n    additional_fields = additional_fields or {}\n    store = SETTINGS.PRIMARY_STORE if store is None else store\n\n    # Get the cclib base task document\n    cclib_task_doc = _make_cclib_schema(\n        dir_path, logfile_extensions, analysis=pop_analyses\n    )\n    attributes = cclib_task_doc[\"attributes\"]\n    metadata = attributes[\"metadata\"]\n\n    if check_convergence and attributes.get(\"optdone\") is False:\n        msg = f\"Optimization not complete. Refer to {dir_path}\"\n        raise RuntimeError(msg)\n\n    # Now we construct the input Atoms object. Note that this is not necessarily\n    # the same as the initial Atoms from the relaxation because the DFT\n    # package may have re-oriented the system. We only try to store the\n    # input if it is XYZ-formatted though since the Atoms object does not\n    # support internal coordinates or Gaussian Z-matrix.\n    if metadata.get(\"coord_type\") == \"xyz\" and metadata.get(\"coords\") is not None:\n        coords_obj = metadata[\"coords\"]\n        symbols = [row[0] for row in coords_obj]\n        positions = [row[1:] for row in coords_obj]\n        input_atoms = Atoms(symbols=symbols, positions=positions)\n    else:\n        input_atoms = cclib_task_doc[\"trajectory\"][0][\"atoms\"]\n\n    # Get the base task document for the ASE run\n    run_task_doc = summarize_run(\n        atoms,\n        input_atoms=input_atoms,\n        charge_and_multiplicity=(attributes[\"charge\"], attributes[\"mult\"]),\n        prep_next_run=prep_next_run,\n        store=False,\n    )\n\n    # Create a dictionary of the inputs/outputs\n    unsorted_task_doc = run_task_doc | cclib_task_doc | additional_fields\n    task_doc = sort_dict(remove_dict_nones(unsorted_task_doc))\n\n    # Store the results\n    if store:\n        results_to_db(store, task_doc)\n\n    return task_doc\n</code></pre>"},{"location":"reference/quacc/schemas/phonons.html","title":"phonons","text":"<p>Summarizer for phonopy</p>"},{"location":"reference/quacc/schemas/phonons.html#quacc.schemas.phonons.summarize_phonopy","title":"summarize_phonopy","text":"<pre><code>summarize_phonopy(\n    phonon,\n    input_atoms=None,\n    parameters=None,\n    additional_fields=None,\n    store=None,\n)\n</code></pre> <p>Summarize a Phonopy object.</p> <p>Parameters:</p> <ul> <li> <code>phonon</code>             (<code>Phonopy</code>)         \u2013          <p>Phonopy object</p> </li> <li> <code>input_atoms</code>             (<code>Atoms | None</code>, default:                 <code>None</code> )         \u2013          <p>Input atoms object</p> </li> <li> <code>parameters</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Calculator parameters used to generate the phonon object.</p> </li> <li> <code>additional_fields</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional fields to add to the document.</p> </li> <li> <code>store</code>             (<code>Store | bool | None</code>, default:                 <code>None</code> )         \u2013          <p>Whether to store the document in the database.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>PhononSchema</code>         \u2013          <p>The PhononSchema.</p> </li> </ul> Source code in <code>quacc/schemas/phonons.py</code> <pre><code>def summarize_phonopy(\n    phonon: Phonopy,\n    input_atoms: Atoms | None = None,\n    parameters: dict[str, Any] | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    store: Store | bool | None = None,\n) -&gt; PhononSchema:\n    \"\"\"\n    Summarize a Phonopy object.\n\n    Parameters\n    ----------\n    phonon\n        Phonopy object\n    input_atoms\n        Input atoms object\n    parameters\n        Calculator parameters used to generate the phonon object.\n    additional_fields\n        Additional fields to add to the document.\n    store\n        Whether to store the document in the database.\n\n    Returns\n    -------\n    PhononSchema\n        The PhononSchema.\n    \"\"\"\n    additional_fields = additional_fields or {}\n    store = SETTINGS.PRIMARY_STORE if store is None else store\n\n    uri = get_uri(Path.cwd())\n\n    inputs = {\n        \"parameters\": parameters,\n        \"phonopy_metadata\": {\"version\": phonon.version},\n        \"nid\": uri.split(\":\")[0],\n        \"dir_name\": \":\".join(uri.split(\":\")[1:]),\n    }\n\n    results = {\n        \"results\": {\n            \"thermal_properties\": phonon.get_thermal_properties_dict(),\n            \"mesh_properties\": phonon.get_mesh_dict(),\n            \"force_constants\": phonon.force_constants,\n        }\n    }\n    phonon.save(settings={\"force_constants\": True})\n\n    atoms_metadata = atoms_to_metadata(input_atoms) if input_atoms else {}\n    unsorted_task_doc = merge_several_dicts(\n        atoms_metadata, inputs, results, additional_fields\n    )\n    task_doc = sort_dict(unsorted_task_doc)\n\n    if store:\n        results_to_db(store, task_doc)\n\n    return task_doc\n</code></pre>"},{"location":"reference/quacc/schemas/prep.html","title":"prep","text":"<p>Utility functions for dealing with Atoms.</p>"},{"location":"reference/quacc/schemas/prep.html#quacc.schemas.prep.prep_next_run","title":"prep_next_run","text":"<pre><code>prep_next_run(atoms, assign_id=True, move_magmoms=True)\n</code></pre> <p>Prepares the Atoms object for a new run.</p> <p>Depending on the arguments, this function will:     - Move the converged magnetic moments to the initial magnetic moments.     - Assign a unique ID to the Atoms object in atoms.info[\"_id\"]. Any       existing IDs will be moved to atoms.info[\"_old_ids\"].</p> <p>In all cases, the calculator will be reset so new jobs can be run.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>Atoms object</p> </li> <li> <code>assign_id</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to assign a unique ID to the Atoms object in atoms.info[\"_id\"]. Any existing IDs will be moved to atoms.info[\"_old_ids\"].</p> </li> <li> <code>move_magmoms</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>If True, move atoms.calc.results[\"magmoms\"] to atoms.get_initial_magnetic_moments()</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Atoms</code>         \u2013          <p>Updated Atoms object.</p> </li> </ul> Source code in <code>quacc/schemas/prep.py</code> <pre><code>def prep_next_run(\n    atoms: Atoms, assign_id: bool = True, move_magmoms: bool = True\n) -&gt; Atoms:\n    \"\"\"\n    Prepares the Atoms object for a new run.\n\n    Depending on the arguments, this function will:\n        - Move the converged magnetic moments to the initial magnetic moments.\n        - Assign a unique ID to the Atoms object in atoms.info[\"_id\"]. Any\n          existing IDs will be moved to atoms.info[\"_old_ids\"].\n\n    In all cases, the calculator will be reset so new jobs can be run.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    assign_id\n        Whether to assign a unique ID to the Atoms object in atoms.info[\"_id\"].\n        Any existing IDs will be moved to atoms.info[\"_old_ids\"].\n    move_magmoms\n        If True, move atoms.calc.results[\"magmoms\"] to\n        atoms.get_initial_magnetic_moments()\n\n    Returns\n    -------\n    Atoms\n        Updated Atoms object.\n    \"\"\"\n    atoms = copy_atoms(atoms)\n\n    if (\n        move_magmoms\n        and hasattr(atoms, \"calc\")\n        and getattr(atoms.calc, \"results\", None) is not None\n    ):\n        # If there are initial magmoms set, then we should see what the final\n        # magmoms are. If they are present, move them to initial. If they are\n        # not present, it means the calculator doesn't support the \"magmoms\"\n        # property so we have to retain the initial magmoms given no further\n        # info.\n        if atoms.has(\"initial_magmoms\"):\n            atoms.set_initial_magnetic_moments(\n                atoms.calc.results.get(\"magmoms\", atoms.get_initial_magnetic_moments())\n            )\n        # If there are no initial magmoms set, just check the results and set\n        # everything to 0.0 if there is nothing there.\n        else:\n            atoms.set_initial_magnetic_moments(\n                atoms.calc.results.get(\"magmoms\", [0.0] * len(atoms))\n            )\n\n    # Clear off the calculator so we can run a new job. If we don't do this,\n    # then something like atoms *= (2,2,2) still has a calculator attached,\n    # which is a bit confusing.\n    atoms.calc = None\n\n    # Give the Atoms object a unique ID. This will be helpful for querying\n    # later. Also store any old IDs somewhere else for future reference. Note:\n    # Keep this at the end of the function so that the ID is assigned based on\n    # the returned Atoms object.\n    if assign_id:\n        if atoms.info.get(\"_id\", None) is not None:\n            if atoms.info.get(\"_old_ids\") is None:\n                atoms.info[\"_old_ids\"] = []\n            atoms.info[\"_old_ids\"].append(atoms.info[\"_id\"])\n        atoms.info[\"_id\"] = get_atoms_id(atoms)\n\n    return atoms\n</code></pre>"},{"location":"reference/quacc/schemas/prep.html#quacc.schemas.prep.set_magmoms","title":"set_magmoms","text":"<pre><code>set_magmoms(\n    atoms,\n    elemental_mags_dict=None,\n    elemental_mags_default=1.0,\n    copy_magmoms=True,\n    mag_cutoff=0.05,\n)\n</code></pre> <p>Sets the initial magnetic moments in the Atoms object.</p> <p>This function deserves particular attention. The following logic is applied: - If there is a converged set of magnetic moments, those are moved to the initial magmoms if copy_magmoms is True. - If there is no converged set of magnetic moments but the user has set initial magmoms, those are simply used as is. - If there are no converged magnetic moments or initial magnetic moments, then the default magnetic moments from the preset elemental_mags_dict (if specified) are set as the initial magnetic moments. - For any of the above scenarios, if mag_cutoff is not None, the newly set initial magnetic moments are checked. If all have a magnitude below mag_cutoff, then they are all set to 0 (no spin polarization).</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>Atoms object</p> </li> <li> <code>elemental_mags_dict</code>             (<code>dict[str, float] | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of elemental symbols and their corresponding magnetic moments to set. If None, no default values will be used.</p> </li> <li> <code>elemental_mags_default</code>             (<code>float</code>, default:                 <code>1.0</code> )         \u2013          <p>Default magnetic moment on an element if no magnetic moment is specified in the elemental_mags_dict. Only used if elemental_mags_dict is not None. This kwarg is mainly a convenience so that you don't need to list every single element in the elemental_mags_dict.</p> </li> <li> <code>copy_magmoms</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to copy the magnetic moments from the converged set of magnetic moments to the initial magnetic moments.</p> </li> <li> <code>mag_cutoff</code>             (<code>float | None</code>, default:                 <code>0.05</code> )         \u2013          <p>Magnitude below which the magnetic moments are considered to be zero. If None, no cutoff will be applied</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Atoms</code>         \u2013          <p>Atoms object</p> </li> </ul> Source code in <code>quacc/schemas/prep.py</code> <pre><code>def set_magmoms(\n    atoms: Atoms,\n    elemental_mags_dict: dict[str, float] | None = None,\n    elemental_mags_default: float = 1.0,\n    copy_magmoms: bool = True,\n    mag_cutoff: float | None = 0.05,\n) -&gt; Atoms:  # sourcery skip\n    \"\"\"\n    Sets the initial magnetic moments in the Atoms object.\n\n    This function deserves particular attention. The following logic is applied:\n    - If there is a converged set of magnetic moments, those are moved to the\n    initial magmoms if copy_magmoms is True. - If there is no converged set of\n    magnetic moments but the user has set initial magmoms, those are simply used\n    as is. - If there are no converged magnetic moments or initial magnetic\n    moments, then the default magnetic moments from the preset\n    elemental_mags_dict (if specified) are set as the initial magnetic moments.\n    - For any of the above scenarios, if mag_cutoff is not None, the newly set\n    initial magnetic moments are checked. If all have a magnitude below\n    mag_cutoff, then they are all set to 0 (no spin polarization).\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    elemental_mags_dict\n        Dictionary of elemental symbols and their corresponding magnetic moments\n        to set. If None, no default values will be used.\n    elemental_mags_default\n        Default magnetic moment on an element if no magnetic moment is specified\n        in the elemental_mags_dict. Only used if elemental_mags_dict is not\n        None. This kwarg is mainly a convenience so that you don't need to list\n        every single element in the elemental_mags_dict.\n    copy_magmoms\n        Whether to copy the magnetic moments from the converged set of magnetic\n        moments to the initial magnetic moments.\n    mag_cutoff\n        Magnitude below which the magnetic moments are considered to be zero. If\n        None, no cutoff will be applied\n\n    Returns\n    -------\n    Atoms\n        Atoms object\n    \"\"\"\n\n    # Handle the magnetic moments Check if a prior job was run and pull the\n    # prior magmoms\n    if hasattr(atoms, \"calc\") and getattr(atoms.calc, \"results\", None) is not None:\n        mags = atoms.calc.results.get(\"magmoms\", [0.0] * len(atoms))\n        # Note: It is important that we set mags to 0.0 here rather than None if\n        # the calculator has no magmoms because: 1) ispin=1 might be set, and 2)\n        # we do not want the preset magmoms to be used.\n    else:\n        mags = None\n\n    # Check if the user has set any initial magmoms\n    has_initial_mags = atoms.has(\"initial_magmoms\")\n\n    # If there are no initial magmoms set and this is not a follow-up job, we\n    # may need to add some from the preset yaml.\n    if mags is None:\n        if not has_initial_mags:\n            # If the preset dictionary has default magmoms, set those by\n            # element. If the element isn't in the magmoms dict then set it to\n            # mag_default.\n            if elemental_mags_dict:\n                initial_mags = np.array(\n                    [\n                        elemental_mags_dict.get(atom.symbol, elemental_mags_default)\n                        for atom in atoms\n                    ]\n                )\n                atoms.set_initial_magnetic_moments(initial_mags)\n        else:\n            pass\n    elif copy_magmoms:\n        atoms.set_initial_magnetic_moments(mags)\n\n    # If all the set mags are below mag_cutoff, set them to 0\n    if mag_cutoff:\n        has_new_initial_mags = atoms.has(\"initial_magmoms\")\n        new_initial_mags = atoms.get_initial_magnetic_moments()\n        if has_new_initial_mags and np.all(np.abs(new_initial_mags) &lt; mag_cutoff):\n            atoms.set_initial_magnetic_moments([0.0] * len(atoms))\n\n    return atoms\n</code></pre>"},{"location":"reference/quacc/schemas/vasp.html","title":"vasp","text":"<p>Schemas for VASP.</p>"},{"location":"reference/quacc/schemas/vasp.html#quacc.schemas.vasp.vasp_summarize_run","title":"vasp_summarize_run","text":"<pre><code>vasp_summarize_run(\n    atoms,\n    dir_path=None,\n    prep_next_run=True,\n    run_bader=None,\n    run_chargemol=None,\n    check_convergence=True,\n    additional_fields=None,\n    store=None,\n)\n</code></pre> <p>Get tabulated results from a VASP run and store them in a database-friendly format.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>ASE Atoms object following a calculation.</p> </li> <li> <code>dir_path</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>Path to VASP outputs. A value of None specifies the current working directory</p> </li> <li> <code>prep_next_run</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether the Atoms object stored in {\"atoms\": atoms} should be prepared for the next run. This clears out any attached calculator and moves the final magmoms to the initial magmoms.</p> </li> <li> <code>run_bader</code>             (<code>bool | None</code>, default:                 <code>None</code> )         \u2013          <p>Whether a Bader analysis should be performed. Will not run if bader executable is not in PATH even if bader is set to True. Defaults to VASP_BADER in settings.</p> </li> <li> <code>run_chargemol</code>             (<code>bool | None</code>, default:                 <code>None</code> )         \u2013          <p>Whether a Chargemol analysis should be performed. Will not run if chargemol executable is not in PATH even if chargmeol is set to True. Defaults to VASP_CHARGEMOL in settings.</p> </li> <li> <code>check_convergence</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to throw an error if convergence is not reached.</p> </li> <li> <code>additional_fields</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional fields to add to the task document.</p> </li> <li> <code>store</code>             (<code>Store | None</code>, default:                 <code>None</code> )         \u2013          <p>Maggma Store object to store the results in. If None, <code>SETTINGS.PRIMARY_STORE</code> will be used.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>VaspSchema</code>         \u2013          <p>Dictionary representation of the task document</p> </li> </ul> Source code in <code>quacc/schemas/vasp.py</code> <pre><code>def vasp_summarize_run(\n    atoms: Atoms,\n    dir_path: str | None = None,\n    prep_next_run: bool = True,\n    run_bader: bool | None = None,\n    run_chargemol: bool | None = None,\n    check_convergence: bool = True,\n    additional_fields: dict[str, Any] | None = None,\n    store: Store | None = None,\n) -&gt; VaspSchema:\n    \"\"\"\n    Get tabulated results from a VASP run and store them in a database-friendly format.\n\n    Parameters\n    ----------\n    atoms\n        ASE Atoms object following a calculation.\n    dir_path\n        Path to VASP outputs. A value of None specifies the current working\n        directory\n    prep_next_run\n        Whether the Atoms object stored in {\"atoms\": atoms} should be prepared\n        for the next run. This clears out any attached calculator and moves the\n        final magmoms to the initial magmoms.\n    run_bader\n        Whether a Bader analysis should be performed. Will not run if bader\n        executable is not in PATH even if bader is set to True. Defaults to\n        VASP_BADER in settings.\n    run_chargemol\n        Whether a Chargemol analysis should be performed. Will not run if chargemol\n        executable is not in PATH even if chargmeol is set to True. Defaults to\n        VASP_CHARGEMOL in settings.\n    check_convergence\n        Whether to throw an error if convergence is not reached.\n    additional_fields\n        Additional fields to add to the task document.\n    store\n        Maggma Store object to store the results in. If None,\n        `SETTINGS.PRIMARY_STORE` will be used.\n\n    Returns\n    -------\n    VaspSchema\n        Dictionary representation of the task document\n    \"\"\"\n\n    additional_fields = additional_fields or {}\n    run_bader = SETTINGS.VASP_BADER if run_bader is None else run_bader\n    run_chargemol = SETTINGS.VASP_CHARGEMOL if run_chargemol is None else run_chargemol\n    dir_path = dir_path or Path.cwd()\n    store = SETTINGS.PRIMARY_STORE if store is None else store\n\n    # Fetch all tabulated results from VASP outputs files. Fortunately, emmet\n    # already has a handy function for this\n    vasp_task_doc = TaskDoc.from_directory(dir_path).model_dump()\n    struct = vasp_task_doc[\"output\"][\"structure\"]\n\n    # Check for calculation convergence\n    if check_convergence and vasp_task_doc[\"state\"] != \"successful\":\n        raise RuntimeError(\n            f\"VASP calculation did not converge. Will not store task data. Refer to {dir_path}\"\n        )\n\n    base_task_doc = summarize_run(atoms, prep_next_run=prep_next_run, store=False)\n\n    # Get Bader analysis\n    if run_bader:\n        try:\n            bader_results = _bader_runner(dir_path, structure=struct)\n        except Exception as err:\n            bader_results = None\n            logging.warning(f\"Bader analysis could not be performed: {err}\")\n\n        if bader_results:\n            vasp_task_doc[\"bader\"] = bader_results[0]\n            struct = bader_results[1]\n\n    # Get the Chargemol analysis\n    if run_chargemol:\n        try:\n            chargemol_results = _chargemol_runner(dir_path, structure=struct)\n        except Exception as err:\n            chargemol_results = None\n            logging.warning(f\"Chargemol analysis could not be performed: {err}\")\n\n        if chargemol_results:\n            vasp_task_doc[\"chargemol\"] = chargemol_results[0]\n            struct = chargemol_results[1]\n\n    # Override the Structure to have the attached properties\n    vasp_task_doc[\"output\"][\"structure\"] = struct\n\n    # Make task document\n    unsorted_task_doc = base_task_doc | vasp_task_doc | additional_fields\n    task_doc = sort_dict(remove_dict_nones(unsorted_task_doc))\n\n    # Store the results\n    if store:\n        results_to_db(store, task_doc)\n\n    return task_doc\n</code></pre>"},{"location":"reference/quacc/utils/dicts.html","title":"dicts","text":"<p>Utility functions for dealing with dictionaries.</p>"},{"location":"reference/quacc/utils/dicts.html#quacc.utils.dicts.merge_dicts","title":"merge_dicts","text":"<pre><code>merge_dicts(dict1, dict2, remove_nones=True)\n</code></pre> <p>Recursively merges two dictionaries. If one of the inputs is <code>None</code>, then it is treated as <code>{}</code>.</p> <p>This function should be used instead of the | operator when merging nested dictionaries, e.g. <code>{\"a\": {\"b\": 1}} | {\"a\": {\"c\": 2}}</code> will return <code>{\"a\": {\"c\": 2}}</code> whereas <code>merge_dicts({\"a\": {\"b\": 1}}, {\"a\": {\"c\": 2}})</code> will return <code>{\"a\": {\"b\": 1, \"c\": 2}}</code>.</p> <p>Parameters:</p> <ul> <li> <code>dict1</code>             (<code>dict[str, Any] | None</code>)         \u2013          <p>First dictionary</p> </li> <li> <code>dict2</code>             (<code>dict[str, Any] | None</code>)         \u2013          <p>Second dictionary</p> </li> <li> <code>remove_nones</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>If True, remove empty lists and dictionaries</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>Merged dictionary</p> </li> </ul> Source code in <code>quacc/utils/dicts.py</code> <pre><code>def merge_dicts(\n    dict1: dict[str, Any] | None,\n    dict2: dict[str, Any] | None,\n    remove_nones: bool = True,\n) -&gt; dict[str, Any]:\n    \"\"\"\n    Recursively merges two dictionaries. If one of the inputs is `None`, then it is\n    treated as `{}`.\n\n    This function should be used instead of the | operator when merging nested dictionaries,\n    e.g. `{\"a\": {\"b\": 1}} | {\"a\": {\"c\": 2}}` will return `{\"a\": {\"c\": 2}}` whereas\n    `merge_dicts({\"a\": {\"b\": 1}}, {\"a\": {\"c\": 2}})` will return `{\"a\": {\"b\": 1, \"c\": 2}}`.\n\n    Parameters\n    ----------\n    dict1\n        First dictionary\n    dict2\n        Second dictionary\n    remove_nones\n        If True, remove empty lists and dictionaries\n\n    Returns\n    -------\n    dict\n        Merged dictionary\n    \"\"\"\n    dict1 = dict1 or {}\n    dict2 = dict2 or {}\n    merged = dict1.copy()\n\n    for key, value in dict2.items():\n        if key in merged:\n            if isinstance(merged[key], dict) and isinstance(value, dict):\n                merged[key] = merge_dicts(merged[key], value)\n            else:\n                merged[key] = value\n        else:\n            merged[key] = value\n\n    if remove_nones:\n        merged = remove_dict_nones(merged)\n\n    return merged\n</code></pre>"},{"location":"reference/quacc/utils/dicts.html#quacc.utils.dicts.merge_several_dicts","title":"merge_several_dicts","text":"<pre><code>merge_several_dicts(*args, remove_nones=True)\n</code></pre> <p>Recursively merge several dictionaries, taking the latter in the list as higher preference.</p> <p>Parameters:</p> <ul> <li> <code>*args</code>         \u2013          <p>Dictionaries to merge</p> </li> <li> <code>remove_nones</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>If True, remove empty lists and dictionaries</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>Merged dictionary</p> </li> </ul> Source code in <code>quacc/utils/dicts.py</code> <pre><code>def merge_several_dicts(*args, remove_nones: bool = True) -&gt; dict[str, Any]:\n    \"\"\"\n    Recursively merge several dictionaries, taking the latter in the list as higher preference.\n\n    Parameters\n    ----------\n    *args\n        Dictionaries to merge\n    remove_nones\n        If True, remove empty lists and dictionaries\n\n    Returns\n    -------\n    dict\n        Merged dictionary\n    \"\"\"\n    old_dict = args[0]\n    for i in range(len(args) - 1):\n        merged = merge_dicts(old_dict, args[i + 1], remove_nones=remove_nones)\n        old_dict = merged.copy()\n    return merged\n</code></pre>"},{"location":"reference/quacc/utils/dicts.html#quacc.utils.dicts.remove_dict_nones","title":"remove_dict_nones","text":"<pre><code>remove_dict_nones(start_dict)\n</code></pre> <p>For a given dictionary, recursively remove all items that are None.</p> <p>Parameters:</p> <ul> <li> <code>start_dict</code>             (<code>dict[str, Any]</code>)         \u2013          <p>Dictionary to clean</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>Cleaned dictionary</p> </li> </ul> Source code in <code>quacc/utils/dicts.py</code> <pre><code>def remove_dict_nones(start_dict: dict[str, Any]) -&gt; dict[str, Any]:\n    \"\"\"\n    For a given dictionary, recursively remove all items that are None.\n\n    Parameters\n    ----------\n    start_dict\n        Dictionary to clean\n\n    Returns\n    -------\n    dict\n        Cleaned dictionary\n    \"\"\"\n\n    if isinstance(start_dict, dict):\n        return {k: remove_dict_nones(v) for k, v in start_dict.items() if v is not None}\n    return (\n        [remove_dict_nones(v) for v in start_dict]\n        if isinstance(start_dict, list)\n        else start_dict\n    )\n</code></pre>"},{"location":"reference/quacc/utils/dicts.html#quacc.utils.dicts.sort_dict","title":"sort_dict","text":"<pre><code>sort_dict(start_dict)\n</code></pre> <p>For a given dictionary, recursively sort all entries alphabetically by key.</p> <p>Parameters:</p> <ul> <li> <code>start_dict</code>             (<code>dict[str, Any]</code>)         \u2013          <p>Dictionary to sort</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>Sorted dictionary</p> </li> </ul> Source code in <code>quacc/utils/dicts.py</code> <pre><code>def sort_dict(start_dict: dict[str, Any]) -&gt; dict[str, Any]:\n    \"\"\"\n    For a given dictionary, recursively sort all entries alphabetically by key.\n\n    Parameters\n    ----------\n    start_dict\n        Dictionary to sort\n\n    Returns\n    -------\n    dict\n        Sorted dictionary\n    \"\"\"\n\n    return {\n        k: sort_dict(v) if isinstance(v, dict) else v\n        for k, v in sorted(start_dict.items())\n    }\n</code></pre>"},{"location":"reference/quacc/utils/files.html","title":"files","text":"<p>Utility functions for file and path handling.</p>"},{"location":"reference/quacc/utils/files.html#quacc.utils.files.check_logfile","title":"check_logfile","text":"<pre><code>check_logfile(logfile, check_str)\n</code></pre> <p>Check if a logfile has a given string (case-insensitive).</p> <p>Parameters:</p> <ul> <li> <code>logfile</code>             (<code>str</code>)         \u2013          <p>Path to the logfile.</p> </li> <li> <code>check_str</code>             (<code>str</code>)         \u2013          <p>String to check for.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True if the string is found in the logfile, False otherwise.</p> </li> </ul> Source code in <code>quacc/utils/files.py</code> <pre><code>def check_logfile(logfile: str, check_str: str) -&gt; bool:\n    \"\"\"\n    Check if a logfile has a given string (case-insensitive).\n\n    Parameters\n    ----------\n    logfile\n        Path to the logfile.\n    check_str\n        String to check for.\n\n    Returns\n    -------\n    bool\n        True if the string is found in the logfile, False otherwise.\n    \"\"\"\n    zlog = zpath(logfile)\n    with zopen(zlog, \"r\") as f:\n        for line in f:\n            clean_line = line if isinstance(line, str) else line.decode(\"utf-8\")\n            if check_str.lower() in clean_line.lower():\n                return True\n    return False\n</code></pre>"},{"location":"reference/quacc/utils/files.html#quacc.utils.files.copy_decompress","title":"copy_decompress","text":"<pre><code>copy_decompress(source_files, destination)\n</code></pre> <p>Copy and decompress files from source to destination.</p> <p>Parameters:</p> <ul> <li> <code>source_files</code>             (<code>list[str | Path]</code>)         \u2013          <p>List of files to copy and decompress.</p> </li> <li> <code>destination</code>             (<code>str | Path</code>)         \u2013          <p>Destination directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          </li> </ul> Source code in <code>quacc/utils/files.py</code> <pre><code>def copy_decompress(source_files: list[str | Path], destination: str | Path) -&gt; None:\n    \"\"\"\n    Copy and decompress files from source to destination.\n\n    Parameters\n    ----------\n    source_files\n        List of files to copy and decompress.\n    destination\n        Destination directory.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    for f in source_files:\n        z_path = Path(zpath(f))\n        if z_path.exists():\n            copy(z_path, Path(destination, z_path.name))\n            decompress_file(Path(destination, z_path.name))\n        else:\n            warnings.warn(f\"Cannot find file: {z_path}\", UserWarning)\n</code></pre>"},{"location":"reference/quacc/utils/files.html#quacc.utils.files.find_recent_logfile","title":"find_recent_logfile","text":"<pre><code>find_recent_logfile(dir_name, logfile_extensions)\n</code></pre> <p>Find the most recent logfile in a given directory.</p> <p>Parameters:</p> <ul> <li> <code>dir_name</code>             (<code>Path | str</code>)         \u2013          <p>The path to the directory to search</p> </li> <li> <code>logfile_extensions</code>             (<code>str | list[str]</code>)         \u2013          <p>The extension (or list of possible extensions) of the logfile to search for. For an exact match only, put in the full file name.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>logfile</code>         \u2013          <p>The path to the most recent logfile with the desired extension</p> </li> </ul> Source code in <code>quacc/utils/files.py</code> <pre><code>def find_recent_logfile(dir_name: Path | str, logfile_extensions: str | list[str]):\n    \"\"\"\n    Find the most recent logfile in a given directory.\n\n    Parameters\n    ----------\n    dir_name\n        The path to the directory to search\n    logfile_extensions\n        The extension (or list of possible extensions) of the logfile to search\n        for. For an exact match only, put in the full file name.\n\n    Returns\n    -------\n    logfile\n        The path to the most recent logfile with the desired extension\n    \"\"\"\n    mod_time = 0.0\n    logfile = None\n    if isinstance(logfile_extensions, str):\n        logfile_extensions = [logfile_extensions]\n    for f in os.listdir(dir_name):\n        f_path = Path(dir_name, f)\n        for ext in logfile_extensions:\n            if ext in f and f_path.stat().st_mtime &gt; mod_time:\n                mod_time = f_path.stat().st_mtime\n                logfile = f_path.resolve()\n    return logfile\n</code></pre>"},{"location":"reference/quacc/utils/files.html#quacc.utils.files.get_uri","title":"get_uri","text":"<pre><code>get_uri(dir_name)\n</code></pre> <p>Return the URI path for a directory.</p> <p>This allows files hosted on different file servers to have distinct locations.</p> <p>Adapted from Atomate2.</p> <p>Parameters:</p> <ul> <li> <code>dir_name</code>             (<code>str | Path</code>)         \u2013          <p>A directory name.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>Full URI path, e.g., \"fileserver.host.com:/full/path/of/dir_name\".</p> </li> </ul> Source code in <code>quacc/utils/files.py</code> <pre><code>def get_uri(dir_name: str | Path) -&gt; str:\n    \"\"\"\n    Return the URI path for a directory.\n\n    This allows files hosted on different file servers to have distinct\n    locations.\n\n    Adapted from Atomate2.\n\n    Parameters\n    ----------\n    dir_name\n        A directory name.\n\n    Returns\n    -------\n    str\n        Full URI path, e.g., \"fileserver.host.com:/full/path/of/dir_name\".\n    \"\"\"\n    fullpath = Path(dir_name).absolute()\n    hostname = socket.gethostname()\n    with contextlib.suppress(socket.gaierror, socket.herror):\n        hostname = socket.gethostbyaddr(hostname)[0]\n    return f\"{hostname}:{fullpath}\"\n</code></pre>"},{"location":"reference/quacc/utils/files.html#quacc.utils.files.load_yaml_calc","title":"load_yaml_calc","text":"<pre><code>load_yaml_calc(yaml_path)\n</code></pre> <p>Loads a YAML file containing calculator settings. This YAML loader looks for a special flag \"parent\" in the YAML file. If this flag is present, the YAML file specified in the \"parent\" flag is loaded and its contents are inherited by the child YAML file.</p> <p>Parameters:</p> <ul> <li> <code>yaml_path</code>             (<code>str | Path</code>)         \u2013          <p>Path to the YAML file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>The calculator configuration (i.e. settings).</p> </li> </ul> Source code in <code>quacc/utils/files.py</code> <pre><code>def load_yaml_calc(yaml_path: str | Path) -&gt; dict[str, Any]:\n    \"\"\"\n    Loads a YAML file containing calculator settings. This YAML loader looks for a\n    special flag \"parent\" in the YAML file. If this flag is present, the YAML file\n    specified in the \"parent\" flag is loaded and its contents are inherited by the child\n    YAML file.\n\n    Parameters\n    ----------\n    yaml_path\n        Path to the YAML file.\n\n    Returns\n    -------\n    dict\n        The calculator configuration (i.e. settings).\n    \"\"\"\n\n    yaml_path = Path(yaml_path).with_suffix(\".yaml\")\n\n    if not yaml_path.exists():\n        msg = f\"Cannot find {yaml_path}\"\n        raise FileNotFoundError(msg)\n\n    # Load YAML file\n    with yaml_path.open() as stream:\n        config = yaml.safe_load(stream)\n\n    # Inherit arguments from any parent YAML files but do not overwrite those in\n    # the child file.\n    for config_arg in config.copy():\n        if \"parent\" in config_arg.lower():\n            yaml_parent_path = Path(yaml_path).parent / Path(config[config_arg])\n            parent_config = load_yaml_calc(yaml_parent_path)\n\n            for k, v in parent_config.items():\n                if k not in config:\n                    config[k] = v\n                else:\n                    v_new = parent_config.get(k, {})\n                    for kk, vv in v_new.items():\n                        if kk not in config[k]:\n                            config[k][kk] = vv\n\n            del config[config_arg]\n\n    return config\n</code></pre>"},{"location":"reference/quacc/utils/files.html#quacc.utils.files.make_unique_dir","title":"make_unique_dir","text":"<pre><code>make_unique_dir(base_path=None)\n</code></pre> <p>Make a directory with a unique name. Uses the same format as Jobflow.</p> <p>Parameters:</p> <ul> <li> <code>base_path</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>Path to the base directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Path</code>         \u2013          <p>Path to the job directory.</p> </li> </ul> Source code in <code>quacc/utils/files.py</code> <pre><code>def make_unique_dir(base_path: str | None = None) -&gt; Path:\n    \"\"\"\n    Make a directory with a unique name. Uses the same format as Jobflow.\n\n    Parameters\n    ----------\n    base_path\n        Path to the base directory.\n\n    Returns\n    -------\n    Path\n        Path to the job directory.\n    \"\"\"\n    time_now = datetime.now(timezone.utc).strftime(\"%Y-%m-%d-%H-%M-%S-%f\")\n    job_dir = Path(f\"quacc-{time_now}-{randint(10000, 99999)}\")\n    if base_path:\n        job_dir = Path(base_path, job_dir)\n    job_dir.mkdir(parents=True)\n\n    return job_dir\n</code></pre>"},{"location":"reference/quacc/wflow_tools/db.html","title":"db","text":"<p>Utility functions for interfacing with databases.</p>"},{"location":"reference/quacc/wflow_tools/db.html#quacc.wflow_tools.db.covalent_to_db","title":"covalent_to_db","text":"<pre><code>covalent_to_db(store, dispatch_ids=None, results_dir=None)\n</code></pre> <p>Store the results of a Covalent database in a user-specified Maggma Store.</p> <p>Parameters:</p> <ul> <li> <code>store</code>             (<code>Store</code>)         \u2013          <p>The Maggma Store object to store the results in</p> </li> <li> <code>dispatch_ids</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Dispatch ID to store. If None, all dispatch IDs in the results_dir will be stored</p> </li> <li> <code>results_dir</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>The Covalent results_dir to pull if dispatch_ID is None. If None, the results_dir from ct.get_config() will be used</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          </li> </ul> Source code in <code>quacc/wflow_tools/db.py</code> <pre><code>def covalent_to_db(\n    store: Store, dispatch_ids: list[str] | None = None, results_dir: str | None = None\n) -&gt; None:\n    \"\"\"\n    Store the results of a Covalent database in a user-specified Maggma Store.\n\n    Parameters\n    ----------\n    store\n        The Maggma Store object to store the results in\n    dispatch_ids\n        Dispatch ID to store. If None, all dispatch IDs in the results_dir will\n        be stored\n    results_dir\n        The Covalent results_dir to pull if dispatch_ID is None. If None, the\n        results_dir from ct.get_config() will be used\n\n    Returns\n    -------\n    None\n    \"\"\"\n    import covalent as ct\n    from covalent._shared_files.exceptions import MissingLatticeRecordError\n\n    if dispatch_ids and results_dir:\n        msg = \"Cannot specify both dispatch_id and results_dir\"\n        raise ValueError(msg)\n    dispatch_ids = dispatch_ids or []\n\n    # Get the dispatch IDs\n    if not dispatch_ids:\n        if results_dir:\n            dispatch_ids = os.listdir(results_dir)\n        else:\n            config_results_dir = ct.get_config()[\"dispatcher\"][\"results_dir\"]\n            dispatch_ids = os.listdir(config_results_dir)\n\n    # Populate the docs\n    docs = []\n    for d_id in dispatch_ids:\n        try:\n            result_obj = ct.get_result(d_id)\n        except MissingLatticeRecordError:\n            warnings.warn(f\"Could not find dispatch_id: {d_id}\", UserWarning)\n            continue\n        if result_obj and result_obj.status == \"COMPLETED\":\n            docs.append({\"dispatch_id\": d_id, \"result\": result_obj.result})\n\n    # Store the results\n    if docs:\n        with store:\n            store.update(docs, key=\"dispatch_id\")\n</code></pre>"},{"location":"reference/quacc/wflow_tools/db.html#quacc.wflow_tools.db.results_to_db","title":"results_to_db","text":"<pre><code>results_to_db(store, results)\n</code></pre> <p>Store the results of a quacc recipe in a user-specified Maggma Store. A UUID will be generated for each entry.</p> <p>Parameters:</p> <ul> <li> <code>store</code>             (<code>Store</code>)         \u2013          <p>The Maggma Store object to store the results in</p> </li> <li> <code>results</code>             (<code>dict[str, Any] | list[dict]</code>)         \u2013          <p>The output summary dictionary or list of dictionaries from a quacc recipe</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          </li> </ul> Source code in <code>quacc/wflow_tools/db.py</code> <pre><code>def results_to_db(store: Store, results: dict[str, Any] | list[dict]) -&gt; None:\n    \"\"\"\n    Store the results of a quacc recipe in a user-specified Maggma Store. A UUID will be\n    generated for each entry.\n\n    Parameters\n    ----------\n    store\n        The Maggma Store object to store the results in\n    results\n        The output summary dictionary or list of dictionaries from a quacc\n        recipe\n\n    Returns\n    -------\n    None\n    \"\"\"\n\n    if not isinstance(results, list):\n        results = [results]\n\n    for result in results:\n        result[\"uuid\"] = str(uuid.uuid4())\n\n    with store:\n        store.update(results, key=\"uuid\")\n</code></pre>"},{"location":"reference/quacc/wflow_tools/decorators.html","title":"decorators","text":"<p>Workflow decorators.</p>"},{"location":"reference/quacc/wflow_tools/decorators.html#quacc.wflow_tools.decorators.flow","title":"flow","text":"<pre><code>flow(_func=None, **kwargs)\n</code></pre> <p>Decorator for workflows, which consist of at least one compute job. This is a <code>@flow</code> decorator.</p> Quacc Covalent Parsl Prefect Redun Jobflow <code>flow</code> <code>ct.lattice</code> No effect <code>flow</code> <code>task</code> No effect <p>All <code>@flow</code>-decorated functions are transformed into their corresponding decorator.</p> <pre><code>from quacc import flow, job\n\n@job\ndef add(a, b):\n    return a + b\n\n@flow\ndef workflow(a, b, c):\n    return add(add(a, b), c)\n\nworkflow(1, 2, 3)\n</code></pre> <p>... is the same as doing</p> CovalentParslPrefectRedunJobflow <pre><code>import covalent as ct\n\n@ct.electron\ndef add(a, b):\n    return a + b\n\n@ct.lattice\ndef workflow(a, b, c):\n    return add(add(a, b), c)\n\nworkflow(1, 2, 3)\n</code></pre> <pre><code>from parsl import python_app\n\n@python_app\ndef add(a, b):\n    return a + b\n\ndef workflow(a, b, c):\n    return add(add(a, b), c)\n\nworkflow(1, 2, 3)\n</code></pre> <pre><code>from prefect import flow, task\n\n@task\ndef add(a, b):\n    return a + b\n\n@flow\ndef workflow(a, b, c):\n    return add.submit(add.submit(a, b), c)\n\nworkflow(1, 2, 3)\n</code></pre> <pre><code>from redun import task\n\n@task\ndef add(a, b):\n    return a + b\n\n@task\ndef workflow(a, b, c):\n    return add(add(a, b), c)\n\nworkflow(1, 2, 3)\n</code></pre> <p>Warning</p> <p>This decorator is not meant to be used with Jobflow at this time.</p> <p>Parameters:</p> <ul> <li> <code>_func</code>             (<code>Callable | None</code>, default:                 <code>None</code> )         \u2013          <p>The function to decorate. This is not meant to be supplied by the user.</p> </li> <li> <code>**kwargs</code>         \u2013          <p>Keyword arguments to pass to the decorator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Flow</code>         \u2013          <p>The <code>@flow</code>-decorated function.</p> </li> </ul> Source code in <code>quacc/wflow_tools/decorators.py</code> <pre><code>def flow(\n    _func: Callable | None = None, **kwargs\n) -&gt; Flow:  # sourcery skip: lift-return-into-if, switch\n    \"\"\"\n    Decorator for workflows, which consist of at least one compute job. This is a\n    `#!Python @flow` decorator.\n\n    | Quacc  | Covalent     | Parsl     | Prefect | Redun  | Jobflow   |\n    | ------ | ------------ | --------- | ------- | ------ | --------- |\n    | `flow` | `ct.lattice` | No effect | `flow`  | `task` | No effect |\n\n    All `#!Python @flow`-decorated functions are transformed into their corresponding\n    decorator.\n\n    ```python\n    from quacc import flow, job\n\n    @job\n    def add(a, b):\n        return a + b\n\n    @flow\n    def workflow(a, b, c):\n        return add(add(a, b), c)\n\n    workflow(1, 2, 3)\n    ```\n\n    ... is the same as doing\n\n    === \"Covalent\"\n\n        ```python\n        import covalent as ct\n\n        @ct.electron\n        def add(a, b):\n            return a + b\n\n        @ct.lattice\n        def workflow(a, b, c):\n            return add(add(a, b), c)\n\n        workflow(1, 2, 3)\n        ```\n\n    === \"Parsl\"\n\n        ```python\n        from parsl import python_app\n\n        @python_app\n        def add(a, b):\n            return a + b\n\n        def workflow(a, b, c):\n            return add(add(a, b), c)\n\n        workflow(1, 2, 3)\n        ```\n\n    === \"Prefect\"\n\n        ```python\n        from prefect import flow, task\n\n        @task\n        def add(a, b):\n            return a + b\n\n        @flow\n        def workflow(a, b, c):\n            return add.submit(add.submit(a, b), c)\n\n        workflow(1, 2, 3)\n        ```\n\n    === \"Redun\"\n\n        ```python\n        from redun import task\n\n        @task\n        def add(a, b):\n            return a + b\n\n        @task\n        def workflow(a, b, c):\n            return add(add(a, b), c)\n\n        workflow(1, 2, 3)\n        ```\n\n    === \"Jobflow\"\n\n        !!! Warning\n\n            This decorator is not meant to be used with Jobflow at this time.\n\n    Parameters\n    ----------\n    _func\n        The function to decorate. This is not meant to be supplied by the user.\n    **kwargs\n        Keyword arguments to pass to the decorator.\n\n    Returns\n    -------\n    Flow\n        The `#!Python @flow`-decorated function.\n    \"\"\"\n    from quacc import SETTINGS\n\n    if _func is None:\n        return functools.partial(flow, **kwargs)\n\n    wflow_engine = SETTINGS.WORKFLOW_ENGINE\n    if wflow_engine == \"covalent\":\n        import covalent as ct\n\n        decorated = ct.lattice(_func, **kwargs)\n    elif wflow_engine == \"prefect\":\n        from prefect import flow as prefect_flow\n\n        decorated = prefect_flow(_func, **kwargs)\n    elif wflow_engine == \"redun\":\n        from redun import task as redun_task\n\n        decorated = redun_task(_func, **kwargs)\n    else:\n        decorated = _func\n\n    return decorated\n</code></pre>"},{"location":"reference/quacc/wflow_tools/decorators.html#quacc.wflow_tools.decorators.job","title":"job","text":"<pre><code>job(_func=None, **kwargs)\n</code></pre> <p>Decorator for individual compute jobs. This is a <code>@job</code> decorator. Think of each <code>@job</code>-decorated function as an individual SLURM job, if that helps.</p> Quacc Covalent Parsl Prefect Redun Jobflow <code>job</code> <code>ct.electron</code> <code>python_app</code> <code>task</code> <code>task</code> <code>job</code> <p>All <code>@job</code>-decorated functions are transformed into their corresponding decorator.</p> <p>The wrapped function can also be stripped of its decorator by calling the <code>.__wrapped__</code> attribute.</p> <pre><code>from quacc import job\n\n@job\ndef add(a, b):\n    return a + b\n\nadd(1, 2)\n</code></pre> <p>... is the same as doing</p> CovalentParslPrefectRedunJobflow <pre><code>import covalent as ct\n\n@ct.electron\ndef add(a, b):\n    return a + b\n\nadd(1, 2)\n</code></pre> <pre><code>from parsl import python_app\n\n@python_app\ndef add(a, b):\n    return a + b\n\nadd(1, 2)\n</code></pre> <pre><code>from prefect import task\n\n@task\ndef add(a, b):\n    return a + b\n\nadd.submit(1, 2)\n</code></pre> <pre><code>from redun import task\n\n@task\ndef add(a, b):\n    return a + b\n\nadd(1, 2)\n</code></pre> <pre><code>import jobflow as jf\n\n@jf.job\ndef add(a, b):\n    return a + b\n\nadd(1, 2)\n</code></pre> <p>Parameters:</p> <ul> <li> <code>_func</code>             (<code>Callable | None</code>, default:                 <code>None</code> )         \u2013          <p>The function to decorate. This is not meant to be supplied by the user.</p> </li> <li> <code>**kwargs</code>         \u2013          <p>Keyword arguments to pass to the workflow engine decorator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Job</code>         \u2013          <p>The @job-decorated function.</p> </li> </ul> Source code in <code>quacc/wflow_tools/decorators.py</code> <pre><code>def job(_func: Callable | None = None, **kwargs) -&gt; Job:\n    \"\"\"\n    Decorator for individual compute jobs. This is a `#!Python @job` decorator. Think of\n    each `#!Python @job`-decorated function as an individual SLURM job, if that helps.\n\n    | Quacc | Covalent      | Parsl        | Prefect | Redun  | Jobflow |\n    | ----- | ------------- | ------------ | ------- | ------ | ------- |\n    | `job` | `ct.electron` | `python_app` | `task`  | `task` | `job`   |\n\n    All `#!Python @job`-decorated functions are transformed into their corresponding\n    decorator.\n\n    The wrapped function can also be stripped of its decorator by calling the\n    `#!Python .__wrapped__` attribute.\n\n    ```python\n    from quacc import job\n\n    @job\n    def add(a, b):\n        return a + b\n\n    add(1, 2)\n    ```\n\n    ... is the same as doing\n\n    === \"Covalent\"\n\n        ```python\n        import covalent as ct\n\n        @ct.electron\n        def add(a, b):\n            return a + b\n\n        add(1, 2)\n        ```\n\n    === \"Parsl\"\n\n        ```python\n        from parsl import python_app\n\n        @python_app\n        def add(a, b):\n            return a + b\n\n        add(1, 2)\n        ```\n\n    === \"Prefect\"\n\n        ```python\n        from prefect import task\n\n        @task\n        def add(a, b):\n            return a + b\n\n        add.submit(1, 2)\n        ```\n\n    === \"Redun\"\n\n        ```python\n        from redun import task\n\n        @task\n        def add(a, b):\n            return a + b\n\n        add(1, 2)\n        ```\n\n    === \"Jobflow\"\n\n        ```python\n        import jobflow as jf\n\n        @jf.job\n        def add(a, b):\n            return a + b\n\n        add(1, 2)\n        ```\n\n    Parameters\n    ----------\n    _func\n        The function to decorate. This is not meant to be supplied by the user.\n    **kwargs\n        Keyword arguments to pass to the workflow engine decorator.\n\n    Returns\n    -------\n    Job\n        The @job-decorated function.\n    \"\"\"\n\n    @functools.wraps(_func)\n    def _inner(\n        *f_args, decorator_kwargs: dict[str, Any] | None = None, **f_kwargs\n    ) -&gt; Any:\n        \"\"\"\n        This function is used for handling workflow engines that require some action\n        beyond just decoration. It also patches the parent function `_func` to takke an\n        additional keyword argument, `deocrator_kwargs`, that is a dictionary of keyword\n        arguments to pass during the decorator construction.\n\n        Parameters\n        ----------\n        *f_args\n            Positional arguments to the function, if any.\n        decorator_kwargs\n            Keyword arguments to pass to the workflow engine decorator.\n        **f_kwargs\n            Keyword arguments to the function, if any.\n\n        Returns\n        -------\n        Any\n            The output of the @job-decorated function.\n        \"\"\"\n        decorator_kwargs = decorator_kwargs if decorator_kwargs is not None else kwargs\n\n        if wflow_engine == \"prefect\":\n            from prefect import task as prefect_task\n\n            decorated = prefect_task(_func, **decorator_kwargs)\n            return decorated.submit(*f_args, **f_kwargs)\n\n        return decorated(*f_args, **f_kwargs)\n\n    from quacc import SETTINGS\n\n    wflow_engine = SETTINGS.WORKFLOW_ENGINE\n\n    if _func is None:\n        return functools.partial(job, **kwargs)\n\n    if wflow_engine == \"covalent\":\n        import covalent as ct\n\n        decorated = ct.electron(_func, **kwargs)\n    elif wflow_engine == \"jobflow\":\n        from jobflow import job as jf_job\n\n        decorated = jf_job(_func, **kwargs)\n    elif wflow_engine == \"parsl\":\n        from parsl import python_app\n\n        decorated = python_app(_func, **kwargs)\n    elif wflow_engine == \"redun\":\n        from redun import task as redun_task\n\n        decorated = redun_task(_func, **kwargs)\n    elif wflow_engine == \"prefect\":\n        return _inner\n    else:\n        decorated = _func\n\n    if not hasattr(decorated, \"__wrapped__\"):\n        decorated.__wrapped__ = _func\n\n    return decorated\n</code></pre>"},{"location":"reference/quacc/wflow_tools/decorators.html#quacc.wflow_tools.decorators.subflow","title":"subflow","text":"<pre><code>subflow(_func=None, **kwargs)\n</code></pre> <p>Decorator for (dynamic) sub-workflows. This is a <code>@subflow</code> decorator.</p> Quacc Covalent Parsl Prefect Redun Jobflow <code>subflow</code> <code>ct.electron(ct.lattice)</code> <code>join_app</code> <code>flow</code> <code>task</code> No effect <p>All <code>@subflow</code>-decorated functions are transformed into their corresponding decorator.</p> <pre><code>import random\nfrom quacc import flow, job, subflow\n\n@job\ndef add(a, b):\n    return a + b\n\n@job\ndef make_more(val):\n    return [val] * random.randint(2, 5)\n\n@subflow\ndef add_distributed(vals, c):\n    return [add(val, c) for val in vals]\n\n@flow\ndef workflow(a, b, c):\n    result1 = add(a, b)\n    result2 = make_more(result1)\n    return add_distributed(result2, c)\n\nworkflow(1, 2, 3)\n</code></pre> <p>... is the same as doing</p> CovalentParslPrefectRedunJobflow <pre><code>import random\nimport covalent as ct\n\n@ct.electron\ndef add(a, b):\n    return a + b\n\n@ct.electron\ndef make_more(val):\n    return [val] * random.randint(2, 5)\n\n@ct.electron\n@ct.lattice\ndef add_distributed(vals, c):\n    return [add(val, c) for val in vals]\n\n@ct.lattice\ndef workflow(a, b, c):\n    result1 = add(a, b)\n    result2 = make_more(result1)\n    return add_distributed(result2, c)\n\nworkflow(1, 2, 3)\n</code></pre> <pre><code>import random\nfrom parsl import join_app, python_app\n\n@python_app\ndef add(a, b):\n    return a + b\n\n@python_app\ndef make_more(val):\n    return [val] * random.randint(2, 5)\n\n@join_app\ndef add_distributed(vals, c):\n    return [add(val, c) for val in vals]\n\ndef workflow(a, b, c):\n    result1 = add(a, b)\n    result2 = make_more(result1)\n    return add_distributed(result2, c)\n\nworkflow(1, 2, 3)\n</code></pre> <pre><code>import random\nfrom prefect import flow, task\n\n@task\ndef add(a, b):\n    return a + b\n\n@task\ndef make_more(val):\n    return [val] * random.randint(2, 5)\n\n@flow\ndef add_distributed(vals, c):\n    return [add(val, c) for val in vals]\n\n@flow\ndef workflow(a, b, c):\n    result1 = add.submit(a, b)\n    result2 = make_more.submit(result1)\n    return add_distributed(result2, c)\n\nworkflow(1, 2, 3)\n</code></pre> <pre><code>import random\nfrom redun import task\n\n@task\ndef add(a, b):\n    return a + b\n\n@task\ndef make_more(val):\n    return [val] * random.randint(2, 5)\n\n@task\ndef add_distributed(vals, c):\n    return [add(val, c) for val in vals]\n\n@task\ndef workflow(a, b, c):\n    result1 = add(a, b)\n    result2 = make_more(result1)\n    return add_distributed(result2, c)\n\nworkflow(1, 2, 3)\n</code></pre> <p>Warning</p> <p>This decorator is not meant to be used with Jobflow at this time.</p> <p>Parameters:</p> <ul> <li> <code>_func</code>             (<code>Callable | None</code>, default:                 <code>None</code> )         \u2013          <p>The function to decorate. This is not meant to be supplied by the user.</p> </li> <li> <code>**kwargs</code>         \u2013          <p>Keyword arguments to pass to the decorator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>callable</code>         \u2013          <p>The decorated function.</p> </li> </ul> Source code in <code>quacc/wflow_tools/decorators.py</code> <pre><code>def subflow(\n    _func: Callable | None = None, **kwargs\n) -&gt; Subflow:  # sourcery skip: lift-return-into-if, switch\n    \"\"\"\n    Decorator for (dynamic) sub-workflows. This is a `#!Python @subflow` decorator.\n\n    | Quacc     | Covalent                  | Parsl      | Prefect | Redun  | Jobflow   |\n    | --------- | ------------------------- | ---------- | ------- | ------ | --------- |\n    | `subflow` | `ct.electron(ct.lattice)` | `join_app` | `flow`  | `task` | No effect |\n\n    All `#!Python @subflow`-decorated functions are transformed into their corresponding\n    decorator.\n\n    ```python\n    import random\n    from quacc import flow, job, subflow\n\n    @job\n    def add(a, b):\n        return a + b\n\n    @job\n    def make_more(val):\n        return [val] * random.randint(2, 5)\n\n    @subflow\n    def add_distributed(vals, c):\n        return [add(val, c) for val in vals]\n\n    @flow\n    def workflow(a, b, c):\n        result1 = add(a, b)\n        result2 = make_more(result1)\n        return add_distributed(result2, c)\n\n    workflow(1, 2, 3)\n    ```\n\n    ... is the same as doing\n\n    === \"Covalent\"\n\n        ```python\n        import random\n        import covalent as ct\n\n        @ct.electron\n        def add(a, b):\n            return a + b\n\n        @ct.electron\n        def make_more(val):\n            return [val] * random.randint(2, 5)\n\n        @ct.electron\n        @ct.lattice\n        def add_distributed(vals, c):\n            return [add(val, c) for val in vals]\n\n        @ct.lattice\n        def workflow(a, b, c):\n            result1 = add(a, b)\n            result2 = make_more(result1)\n            return add_distributed(result2, c)\n\n        workflow(1, 2, 3)\n        ```\n\n    === \"Parsl\"\n\n        ```python\n        import random\n        from parsl import join_app, python_app\n\n        @python_app\n        def add(a, b):\n            return a + b\n\n        @python_app\n        def make_more(val):\n            return [val] * random.randint(2, 5)\n\n        @join_app\n        def add_distributed(vals, c):\n            return [add(val, c) for val in vals]\n\n        def workflow(a, b, c):\n            result1 = add(a, b)\n            result2 = make_more(result1)\n            return add_distributed(result2, c)\n\n        workflow(1, 2, 3)\n        ```\n\n    === \"Prefect\"\n\n        ```python\n        import random\n        from prefect import flow, task\n\n        @task\n        def add(a, b):\n            return a + b\n\n        @task\n        def make_more(val):\n            return [val] * random.randint(2, 5)\n\n        @flow\n        def add_distributed(vals, c):\n            return [add(val, c) for val in vals]\n\n        @flow\n        def workflow(a, b, c):\n            result1 = add.submit(a, b)\n            result2 = make_more.submit(result1)\n            return add_distributed(result2, c)\n\n        workflow(1, 2, 3)\n        ```\n\n    === \"Redun\"\n\n        ```python\n        import random\n        from redun import task\n\n        @task\n        def add(a, b):\n            return a + b\n\n        @task\n        def make_more(val):\n            return [val] * random.randint(2, 5)\n\n        @task\n        def add_distributed(vals, c):\n            return [add(val, c) for val in vals]\n\n        @task\n        def workflow(a, b, c):\n            result1 = add(a, b)\n            result2 = make_more(result1)\n            return add_distributed(result2, c)\n\n        workflow(1, 2, 3)\n        ```\n\n    === \"Jobflow\"\n\n        !!! Warning\n\n            This decorator is not meant to be used with Jobflow at this time.\n\n    Parameters\n    ----------\n    _func\n        The function to decorate. This is not meant to be supplied by the user.\n    **kwargs\n        Keyword arguments to pass to the decorator.\n\n    Returns\n    -------\n    callable\n        The decorated function.\n    \"\"\"\n\n    from quacc import SETTINGS\n\n    if _func is None:\n        return functools.partial(subflow, **kwargs)\n\n    wflow_engine = SETTINGS.WORKFLOW_ENGINE\n    if wflow_engine == \"covalent\":\n        import covalent as ct\n\n        decorated = ct.electron(ct.lattice(_func, **kwargs))\n    elif wflow_engine == \"parsl\":\n        from parsl import join_app\n\n        decorated = join_app(_func, **kwargs)\n    elif wflow_engine == \"prefect\":\n        from prefect import flow as prefect_flow\n\n        decorated = prefect_flow(_func, **kwargs)\n    elif wflow_engine == \"redun\":\n        from redun import task as redun_task\n\n        decorated = redun_task(_func, **kwargs)\n    else:\n        decorated = _func\n\n    return decorated\n</code></pre>"},{"location":"reference/quacc/wflow_tools/prefect.html","title":"prefect","text":"<p>Utilities for Prefect.</p>"},{"location":"reference/quacc/wflow_tools/prefect.html#quacc.wflow_tools.prefect.make_prefect_runner","title":"make_prefect_runner","text":"<pre><code>make_prefect_runner(\n    cluster_kwargs,\n    cluster_class=None,\n    adapt_kwargs=None,\n    client_kwargs=None,\n    temporary=False,\n)\n</code></pre> <p>Make a <code>DaskTaskRunner</code> for use with Prefect workflows.</p> <p>Parameters:</p> <ul> <li> <code>cluster_kwargs</code>             (<code>dict[str, Any]</code>)         \u2013          <p>Keyword arguments to pass to <code>cluster_class</code>.</p> </li> <li> <code>cluster_class</code>             (<code>Callable | None</code>, default:                 <code>None</code> )         \u2013          <p>The Dask cluster class to use. Defaults to <code>dask_jobqueue.SLURMCluster</code>.</p> </li> <li> <code>adapt_kwargs</code>             (<code>dict[str, int | None] | None</code>, default:                 <code>None</code> )         \u2013          <p>Keyword arguments to pass to <code>cluster.adapt</code> of the form <code>{\"minimum\": int, \"maximum\": int}</code>. If <code>None</code>, no adaptive scaling will be done.</p> </li> <li> <code>client_kwargs</code>             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Keyword arguments to pass to <code>dask.distributed.Client</code>.</p> </li> <li> <code>temporary</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to use a temporary cluster. If <code>True</code>, the cluster will be terminated once the <code>Flow</code> is finished. If <code>False</code>, the cluster will run until the walltime is reached and can run multiple <code>Flow</code>s.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DaskTaskRunner</code>         \u2013          <p>A DaskTaskRunner object for use with Prefect workflows.</p> </li> </ul> Source code in <code>quacc/wflow_tools/prefect.py</code> <pre><code>@requires(prefect_deps and dask_deps, \"Need quacc[prefect] dependencies\")\ndef make_prefect_runner(\n    cluster_kwargs: dict[str, Any],\n    cluster_class: Callable | None = None,\n    adapt_kwargs: dict[str, int | None] | None = None,\n    client_kwargs: dict[str, Any] | None = None,\n    temporary: bool = False,\n) -&gt; DaskTaskRunner:\n    \"\"\"\n    Make a `DaskTaskRunner` for use with Prefect workflows.\n\n    Parameters\n    ----------\n    cluster_kwargs\n        Keyword arguments to pass to `cluster_class`.\n    cluster_class\n        The Dask cluster class to use. Defaults to `dask_jobqueue.SLURMCluster`.\n    adapt_kwargs\n        Keyword arguments to pass to `cluster.adapt` of the form `{\"minimum\": int, \"maximum\": int}`.\n        If `None`, no adaptive scaling will be done.\n    client_kwargs\n        Keyword arguments to pass to `dask.distributed.Client`.\n    temporary\n        Whether to use a temporary cluster. If `True`, the cluster will be\n        terminated once the `Flow` is finished. If `False`, the cluster will\n        run until the walltime is reached and can run multiple `Flow`s.\n\n    Returns\n    -------\n    DaskTaskRunner\n        A DaskTaskRunner object for use with Prefect workflows.\n    \"\"\"\n\n    if cluster_class is None:\n        cluster_class = SLURMCluster\n\n    # Make the one-time-use DaskTaskRunner\n    if temporary:\n        return DaskTaskRunner(\n            cluster_class=cluster_class,\n            cluster_kwargs=cluster_kwargs,\n            adapt_kwargs=adapt_kwargs,\n            client_kwargs=client_kwargs,\n        )\n\n    # Make the Dask cluster\n    cluster = _make_dask_cluster(cluster_class, cluster_kwargs)\n\n    # Set up adaptive scaling\n    if adapt_kwargs and (adapt_kwargs[\"minimum\"] or adapt_kwargs[\"maximum\"]):\n        cluster.adapt(minimum=adapt_kwargs[\"minimum\"], maximum=adapt_kwargs[\"maximum\"])\n\n    # Return the DaskTaskRunner with the cluster address\n    return DaskTaskRunner(address=cluster.scheduler_address)\n</code></pre>"},{"location":"user/advanced/database.html","title":"Using a Database","text":"<p>Oftentimes, it is beneficial to store the results in a database for easy querying (like the example below). This is quite simple to do in quacc regardless of the workflow manager you are using by taking advantage of the numerous data store options in maggma. For details on how to set up a Mongo database, refer to the corresponding Maggma tutorial</p> <p></p> General PurposeCovalentJobflow <p>Automated Approach</p> <p>For a given recipe, you can have quacc automatically store the final output summaries in your desired database by defining a Maggma data store in the <code>PRIMARY_STORE</code> quacc setting.</p> <p>For instance, let's pretend you have decided to make a <code>MongoStore</code> be your database of choice. After defining or loading your Maggma store, you would call <code>.to_json()</code> to get a dictionary representation. You can then store this JSON, formatted as a string, in the <code>PRIMARY_STORE</code> global quacc setting.</p> <pre><code>from maggma.stores import MongoStore\n\nstore = MongoStore(\n    \"my_db_name\",\n    \"my_collection_name\",\n    username=\"my_username\",\n    password=\"my_password\",\n    host=\"localhost\",\n    port=27017,\n)\nprint(store.to_json())  # This is the JSON string you would store in PRIMARY_STORE\n</code></pre> ~/.quacc.yaml<pre><code>PRIMARY_STORE: '{\"@module\": \"maggma.stores.mongolike\", \"@class\": \"MongoStore\", \"@version\": \"0.51.19\", \"database\": \"my_db_name\", \"collection_name\": \"my_collection_name\", \"host\": \"localhost\", \"port\": 27017, \"username\": \"my_username\", \"password\": \"my_password\", \"ssh_tunnel\": null, \"safe_update\": false, \"auth_source\": \"my_db_name\", \"mongoclient_kwargs\": {}, \"default_sort\": null}'\n</code></pre> <p>Manual Approach</p> <p>If you would prefer to store results in your database manually (perhaps because you are limited in terms of how much data you can store), you can use the quacc.wflow_tools.db.results_to_db function, as shown in the example below.</p> <pre><code>from maggma.stores import MongoStore\nfrom quacc.wflow_tools.db import results_to_db\n\n# Let `results` be an output (or list of outputs) from quacc recipes\n\n# Define your database details\nstore = MongoStore(\n    \"my_db_name\",\n    \"my_collection_name\",\n    username=\"my_username\",\n    password=\"my_password\",\n    host=\"localhost\",\n    port=27017,\n)\n\n# Store the results\nresults_to_db(store, results)\n</code></pre> <p>Covalent automatically stores all the inputs and outputs in an SQLite database, which you can find at the <code>\"db_path\"</code> when you run <code>covalent config</code>, and the results can be queried using the <code>ct.get_result(&lt;dispatch ID&gt;)</code> syntax. However, if you want to store the results in a different database of your choosing, you can do so quite easily.</p> <p>An example is shown below for storing the results in your custom database via the quacc.wflow_tools.db.covalent_to_db function.</p> <pre><code>from maggma.stores import MongoStore\nfrom quacc.wflow_tools.db import covalent_to_db\n\n# Define your database credentials\nstore = MongoStore(\n    \"my_db_name\",\n    \"my_collection_name\",\n    username=\"my_username\",\n    password=\"my_password\",\n    host=\"localhost\",\n    port=27017,\n)\n\n# Store the results\ncovalent_to_db(store)\n</code></pre> <p>If you are using Jobflow to construct your workflows, it will automatically store the results in the database you defined during the setup process. No additional steps are needed.</p>"},{"location":"user/advanced/file_transfers.html","title":"Transferring Files","text":""},{"location":"user/advanced/file_transfers.html#local-file-transfers","title":"Local File Transfers","text":""},{"location":"user/advanced/file_transfers.html#transfers-from-a-known-file-location","title":"Transfers from a Known File Location","text":"<p>Sometimes, you may want to transfer files between jobs. Many recipes within quacc takes an optional keyword argument, <code>copy_files</code>, that is a list of absolute filepaths to files you wish to have copied to the directory where the calculation is ultimately run.</p> <p>For instance, if you have a file <code>WAVECAR</code> stored in <code>/path/to/my/file/stage</code>, then you could ensure that is present in the calculation's working directory:</p> <pre><code>from pathlib import Path\nfrom ase.build import bulk\nfrom quacc.recipes.vasp.core import relax_job\n\natoms = bulk(\"Cu\")\nrelax_job(atoms, copy_files=[Path(\"path/to/my/file/stage/WAVECAR\")])\n</code></pre>"},{"location":"user/advanced/file_transfers.html#transfers-between-jobs","title":"Transfers Between Jobs","text":"<p>Sometimes, however, you may not necessarily know a priori where the source file is. For instance, perhaps you want to copy the file <code>WAVECAR</code> from a previous job in your workflow that is stored in a unique directory only determined at runtime. In this scenario, you can still use the <code>copy_files</code> keyword argument, but you will need to fetch the prior job's directory.</p> <pre><code>from pathlib import Path\nfrom ase.build import bulk\nfrom quacc.recipes.vasp.core import relax_job, static_job\n\natoms = bulk(\"Cu\")\nresults1 = relax_job(atoms)\nstatic_job(results1[\"atoms\"], copy_files=[Path(results1[\"dir_name\"], \"WAVECAR\")])\n</code></pre>"},{"location":"user/advanced/file_transfers.html#non-local-file-transfers","title":"Non-Local File Transfers","text":"<p>If using quacc across distributed computing environments, there may not be a guarantee that the file you wish to transfer is even on the same machine as your current job. In this scenario, the best approach is to create a dedicated file staging area on your machine of choice where you can store files you wish to transfer.</p> <p>For instance, if using a job scheduler like Slurm, you could have a step in your job script that copies files (e.g. via <code>scp</code>) from a remote location to a local staging area. Then, you can use the <code>copy_files</code> keyword argument to copy the files from the staging area to the calculation's working directory.</p> <p>Alternatively, several of the supported workflow managers have built-in options to enable file staging.</p>"},{"location":"user/basics/wflow_overview.html","title":"Workflow Engines Overview","text":"<p>Everyone's computing needs are different, so we ensured that quacc is interoperable with a variety of modern workflow management tools. There are 300+ workflow management tools out there, so we can't possibly support them all. Instead, we have focused on a select few that adopt a similar decorator-based approach to defining workflows with substantial support for HPC systems.</p>"},{"location":"user/basics/wflow_overview.html#summary","title":"Summary","text":"<p>Recommendations</p> <p>If you are new to workflow engines, we recommend trying either Parsl or Covalent. If you have a need for speed and appreciate flexibility, Parsl is the choice for you. If you are looking for a visual dashboard with an emphasis on distributed compute resources, Covalent may be worth considering.</p> ParslCovalentRedunJobflow <p>Parsl is a workflow management solution out of Argonne National Laboratory, the University of Chicago, and the University of Illinois. It is well-adapted for running on virtually any HPC environment with a job scheduler.</p> <p>Pros:</p> <ul> <li>Extremely configurable and deployable for virtually any HPC environment</li> <li>Quite simple to define the workflows</li> <li>Active community, particularly across academia</li> <li>Well-suited for pilot jobs and advanced queuing schemes</li> <li>Thorough documentation</li> <li>Does not rely on maintaining a centralized server</li> </ul> <p>Cons:</p> <ul> <li>The number of different terms can be slightly overwhelming to those less familiar with HPC</li> <li>Understanding the various configuration options for your HPC setup can be an initial hurdle</li> <li>Monitoring job progress is more challenging and less detailed than other solutions</li> </ul> <p>Covalent is a workflow management solution from the company Agnostiq.</p> <p>Pros:</p> <ul> <li>Best-in-class visual dashboard for job monitoring</li> <li>Easy to use in distributed, heterogeneous compute environments</li> <li>Excellent documentation</li> <li>Automatic and simple database integration</li> <li>The compute nodes do not need to be able to connect to the internet, unlike some of its competitors</li> </ul> <p>Cons:</p> <ul> <li>Not as widely used as other workflow management solutions</li> <li>Only supports standard queuing schemes, limiting throughput</li> <li>It requires a centralized server to be running continuously in order to manage the workflows</li> <li>High-security HPC environments may be difficult to access via SSH with the centralized server approach</li> </ul> <p>Redun is a flexible workflow management program developed by Insitro.</p> <p>Pros:</p> <ul> <li>Extremely simple syntax for defining workflows</li> <li>Has strong support for task/result caching</li> <li>Useful console-based monitoring system</li> </ul> <p>Cons:</p> <ul> <li>Currently lacks support for typical HPC job schedulers and platforms other than AWS</li> <li>No user-friendly GUI for job monitoring</li> <li>Less active user community than some other options</li> </ul> <p>Jobflow is developed and maintained by the Materials Project team at Lawrence Berkeley National Laboratory and serves as a seamless interface to FireWorks for dispatching and monitoring compute jobs.</p> <p>Jobflow</p> <p>Pros:</p> <ul> <li>Native support for a variety of databases</li> <li>Directly compatible with Atomate2</li> <li>Designed with materials science in mind</li> <li>Actively supported by the Materials Project team</li> </ul> <p>Cons:</p> <ul> <li>Is not compatible with the <code>@flow</code> decorator used in some quacc recipes</li> <li>Parsing the output of a workflow is not as intuitive as other solutions</li> <li>Defining dynamic workflows with Jobflow's <code>Response</code> object can be more complex than other solutions</li> <li>Only supports FireWorks for job dispatching at the moment</li> </ul> <p>FireWorks:</p> <p>Pros:</p> <ul> <li>Well-suited for a variety of job management approaches</li> <li>Helpful dashboard for monitoring job progress</li> </ul> <p>Cons:</p> <ul> <li>FireWorks documentation can be difficult to navigate without prior experience</li> <li>FireWorks can have a steep learning curve due to its many configuration options</li> <li>The reliance on MongoDB can be challenging for new users and certain HPC environments</li> <li>New features are not planned</li> </ul>"},{"location":"user/basics/wflow_syntax.html","title":"Workflow Syntax","text":""},{"location":"user/basics/wflow_syntax.html#introduction","title":"Introduction","text":"<p>Here, we provide code snippets for several decorator-based workflow engines. For a comparison of the pros and cons of each approach, refer to the Workflow Engines Overview page. We describe the specifics of how to use each workflow engine in more detail later in the documentation.</p>"},{"location":"user/basics/wflow_syntax.html#background","title":"Background","text":"<p>To help enable interoperability between workflow engines, quacc offers a unified set of decorators: <code>@job</code>, <code>@flow</code>, and <code>@subflow</code>.</p> ParslCovalentRedunJobflow <p>Take a moment to read the Parsl documentation's \"Quick Start\" to get a sense of how Parsl works. Namely, you should understand the concept of a <code>python_app</code> and <code>join_app</code>, which describe individual compute tasks and dynamic job tasks, respectively.</p> <p> Quacc Parsl <code>@job</code> <code>@python_app</code> <code>@flow</code> No effect <code>@subflow</code> <code>@join_app</code> <p></p> <p>Take a moment to learn about the main Covalent Concepts, namely the <code>@ct.electron</code> and <code>@ct.lattice</code> decorators, which describe individual compute tasks and workflows, respectively.</p> <p> Quacc Covalent <code>@job</code> <code>@ct.electron</code> <code>@flow</code> <code>@ct.lattice</code> <code>@subflow</code> <code>@ct.electron</code><code>@ct.lattice</code> <p></p> <p>Take a moment to read the Redun documentation's Design Overview page to get a sense of how Redun works. Namely, you should understand the <code>Task</code> decorator and how to interface with the <code>Scheduler</code>.</p> <p> Quacc Redun <code>@job</code> <code>@task</code> <code>@flow</code> <code>@task</code> <code>@subflow</code> <code>@task</code> <p></p> <p>Take a moment to read the Jobflow documentation's Quick Start to get a sense of how Jobflow works. Namely, you should understand the <code>Job</code> and <code>Flow</code> definitions, which describe individual compute tasks and workflows, respectively.</p> <p> Quacc Jobflow <code>@job</code> <code>@job</code> <code>@flow</code> N/A <code>@subflow</code> N/A <p></p> <p>Warning</p> <p>Due to the difference in how Jobflow handles workflows compared to other supported workflow engines, any quacc recipes that have been pre-defined with a <code>@flow</code> or <code>@subflow</code> decorator (i.e. have <code>_flow</code> in the name) cannot be run directly with Jobflow.</p> <p>The quacc descriptors are drop-in replacements for the specified workflow engine analogue, which we will use for the remainder of the tutorials. Based on the value for the <code>WORKFLOW_ENGINE</code> global variable in your quacc settings, the appropriate decorator will be automatically selected. If the <code>WORKFLOW_ENGINE</code> setting is set to <code>\"local\"</code>, the decorators will have no effect on the underlying function.</p>"},{"location":"user/basics/wflow_syntax.html#simple-workflow","title":"Simple Workflow","text":"<p>Let's do the following:</p> <ol> <li>Add two numbers (e.g. <code>1 + 2</code>)</li> <li>Multiply the output of Step 1 by a third number (e.g. <code>3 * 3</code>)</li> </ol> <p>In practice, we would want each of the two tasks to be their own compute job.</p> <pre><code>graph LR\n  A[Input] --&gt; B(add) --&gt; C(mult) --&gt; D[Output];</code></pre> ParslCovalentRedunJobflow <p>Important</p> <p>If you haven't done so yet, make sure you update the quacc <code>WORKFLOW_ENGINE</code> configuration variable and load the default Parsl configuration:</p> <pre><code>quacc set WORKFLOW_ENGINE parsl\n</code></pre> python<pre><code>import parsl\n\nparsl.load()  #  (1)!\n</code></pre> <ol> <li>It is necessary to instantiate a Parsl configuration before running Parsl workflows. This command loads the default (local) configuration and only needs to be done once.</li> </ol> <pre><code>from quacc import job\n\n\n@job  #  (1)!\ndef add(a, b):\n    return a + b\n\n\n@job\ndef mult(a, b):\n    return a * b\n\n\ndef workflow(a, b, c):  #  (2)!\n    return mult(add(a, b), c)\n\n\nresult = workflow(1, 2, 3).result()  # 9\nprint(result)\n</code></pre> <ol> <li> <p>The <code>@job</code> decorator will be transformed into <code>@python_app</code>.</p> </li> <li> <p>The <code>@flow</code> decorator doesn't actually do anything when using Parsl, so we chose to not include it here for brevity.</p> </li> </ol> <p>Important</p> <p>If you haven't done so yet, make sure you update the quacc <code>WORKFLOW_ENGINE</code> configuration variable and start the Covalent server:</p> <pre><code>quacc set WORKFLOW_ENGINE covalent\ncovalent start\n</code></pre> <pre><code>import covalent as ct\nfrom quacc import flow, job\n\n\n@job  #  (1)!\ndef add(a, b):\n    return a + b\n\n\n@job\ndef mult(a, b):\n    return a * b\n\n\n@flow  #  (2)!\ndef workflow(a, b, c):\n    return mult(add(a, b), c)\n\n\ndispatch_id = ct.dispatch(workflow)(1, 2, 3)\nresult = ct.get_result(dispatch_id, wait=True)\nprint(result)\n</code></pre> <ol> <li> <p>The <code>@job</code> decorator will be transformed into <code>@ct.electron</code>.</p> </li> <li> <p>The <code>@flow</code> decorator will be transformed into <code>@ct.lattice</code>.</p> </li> <li> <p>This command will dispatch the workflow to the Covalent server.</p> </li> </ol> <p>Important</p> <p>If you haven't done so yet, make sure you update the quacc <code>WORKFLOW_ENGINE</code> configuration variable:</p> <pre><code>quacc set WORKFLOW_ENGINE redun\n</code></pre> <pre><code>from redun import Scheduler\nfrom quacc import flow, job\n\nscheduler = Scheduler()  #  (1)!\n\n\n@job  #  (2)!\ndef add(a, b):\n    return a + b\n\n\n@job\ndef mult(a, b):\n    return a * b\n\n\n@flow  #  (3)!\ndef workflow(a, b, c):\n    return mult(add(a, b), c)\n\n\nresult = scheduler.run(workflow(1, 2, 3))\nprint(result)\n</code></pre> <ol> <li> <p>It is necessary to instantiate the scheduler before submitting calculations.</p> </li> <li> <p>The <code>@job</code> decorator will be transformed into a Redun <code>@task</code>.</p> </li> <li> <p>The <code>@flow</code> decorator will also be transformed into a Redun <code>@task</code>. Everything in Redun is a <code>@task</code>, so it doesn't matter what quacc decorator you apply. We chose <code>@flow</code> simply for clarity.</p> </li> </ol> <p>Important</p> <p>If you haven't done so yet, make sure you update the quacc <code>WORKFLOW_ENGINE</code> configuration variable:</p> <pre><code>quacc set WORKFLOW_ENGINE jobflow\n</code></pre> <pre><code>import jobflow as jf\nfrom quacc import job\n\n\n@job  #  (1)!\ndef add(a, b):\n    return a + b\n\n\n@job\ndef mult(a, b):\n    return a * b\n\n\njob1 = add(1, 2)\njob2 = mult(job1.output, 3)\nflow = jf.Flow([job1, job2])\n\nresponses = jf.run_locally(flow)\nresult = responses[job2.uuid][1].output\nprint(result)\n</code></pre> <ol> <li>The <code>@job</code> decorator will be transformed into <code>@jf.job</code>.</li> </ol>"},{"location":"user/basics/wflow_syntax.html#stripping-the-decorator-from-a-job","title":"Stripping the Decorator from a Job","text":"<p>If you ever want to strip the decorator from a pre-decorated <code>@job</code> for any reason, you can call the <code>.__wrapped__</code> attribute. This returns the original function.</p> <pre><code>from quacc import job\n\n\n@job\ndef add(a, b):\n    return a + b\n\n\nadd.__wrapped__(1, 2)\n</code></pre>"},{"location":"user/basics/wflow_syntax.html#learn-more","title":"Learn More","text":"ParslCovalentRedunJobflow <p>If you want to learn more about Parsl, you can read the Parsl Documentation. Please refer to the Parsl Slack Channel for any Parsl-specific questions.</p> <p>If you want to learn more about Covalent, you can read the Covalent Documentation. Please refer to the Covalent Discussion Board for any Covalent-specific questions.</p> <p>If you want to learn more about Redun, you can read the Redun documentation.</p> <p>If you want to learn more about Jobflow, you can read the Jobflow Documentation. Please refer to the Jobflow Discussions Board for Jobflow-specific questions.</p>"},{"location":"user/recipes/recipes_intro.html","title":"Intro to Recipes","text":"<p>In quacc, each code comes with pre-packaged jobs and workflows, which we call recipes for short. This tutorial walks you through how to use these provided recipes to run simple calculations that can be tested out on your local machine.</p>"},{"location":"user/recipes/recipes_intro.html#pre-requisites","title":"Pre-Requisites","text":"<p>If you are not yet familiar with the ASE <code>Atoms</code> object, you should read the ASE tutorial. Additionally, it is worthwhile to be familiar with the basics of an ASE Calculator. The \"Open Science with ASE: Core Tutorials\" is also an excellent resource for learning about the basics of ASE.</p> <p>Note</p> <p>Since we are not using a workflow engine for these examples, run the following in the command line:</p> <pre><code>quacc set WORKFLOW_ENGINE local\n</code></pre>"},{"location":"user/recipes/recipes_intro.html#examples","title":"Examples","text":""},{"location":"user/recipes/recipes_intro.html#a-simple-calculation-with-emt","title":"A Simple Calculation with EMT","text":"<pre><code>graph LR\n  A[Input] --&gt; B(EMT Relax) --&gt; C[Output]</code></pre> <p>Let's start with a simple example. Here, we will use a cheap calculator based on effective medium theory (EMT) to run a structure relaxation on a bulk structure of copper. We are interested in doing a structure relaxation, so we will use the quacc.recipes.emt.core.relax_job recipe, as demonstrated below.</p> <pre><code>from ase.build import bulk\nfrom quacc.recipes.emt.core import relax_job\n\n# Make an Atoms object of a bulk Cu structure\natoms = bulk(\"Cu\")\n\n# Run a structure relaxation on the Atoms object\nresult = relax_job(atoms)\nprint(result)\n</code></pre> Printed Output <pre><code>{'atoms': Atoms(symbols='Cu', pbc=True, cell=[[0.0, 1.805, 1.805], [1.805, 0.0, 1.805], [1.805, 1.805, 0.0]], initial_magmoms=...),\n 'atoms_info': {'_id': 'f8d53f110f524872f30a5cc20e8befb1'},\n 'builder_meta': {'build_date': datetime.datetime(2023, 10, 19, 0, 46, 1, 742310),\n                  'emmet_version': '0.69.6',\n                  'pymatgen_version': '2023.10.4'},\n 'chemsys': 'Cu',\n 'composition': Composition('Cu1'),\n 'composition_reduced': Composition('Cu1'),\n 'converged': True,\n 'density': 8.971719800606017,\n 'density_atomic': 11.761470249999999,\n 'dir_name': '/home/rosen',\n 'elements': [Element Cu],\n 'fmax': 0.01,\n 'formula_anonymous': 'A',\n 'formula_pretty': 'Cu',\n 'input_atoms': {'atoms': Atoms(symbols='Cu', pbc=True, cell=[[0.0, 1.805, 1.805], [1.805, 0.0, 1.805], [1.805, 1.805, 0.0]], calculator=SinglePointCalculator(...)),\n                 'atoms_info': {},\n                 'builder_meta': {'build_date': datetime.datetime(2023, 10, 19, 0, 46, 1, 725218),\n                                  'emmet_version': '0.69.6',\n                                  'pymatgen_version': '2023.10.4'},\n                 'chemsys': 'Cu',\n                 'composition': Composition('Cu1'),\n                 'composition_reduced': Composition('Cu1'),\n                 'density': 8.971719800606017,\n                 'density_atomic': 11.761470249999999,\n                 'elements': [Element Cu],\n                 'formula_anonymous': 'A',\n                 'formula_pretty': 'Cu',\n                 'nelements': 1,\n                 'nsites': 1,\n                 'structure': Structure Summary\nLattice\n    abc : 2.5526554800834367 2.5526554800834367 2.5526554800834367\n angles : 60.00000000000001 60.00000000000001 60.00000000000001\n volume : 11.761470249999999\n      A : 0.0 1.805 1.805\n      B : 1.805 0.0 1.805\n      C : 1.805 1.805 0.0\n    pbc : True True True\nPeriodicSite: Cu (0.0, 0.0, 0.0) [0.0, 0.0, 0.0],\n                 'symmetry': {'crystal_system': &lt;CrystalSystem.cubic: 'Cubic'&gt;,\n                              'number': 225,\n                              'point_group': 'm-3m',\n                              'symbol': 'Fm-3m',\n                              'symprec': 0.1,\n                              'version': '2.1.0'},\n                 'volume': 11.761470249999999},\n 'name': 'EMT Relax',\n 'nelements': 1,\n 'nid': 'rosen.',\n 'nsites': 1,\n 'nsteps': 0,\n 'parameters': {'asap_cutoff': False},\n 'parameters_opt': {'max_steps': 1000,\n                    'maxstep': 0.2,\n                    'optimizer': 'FIRE',\n                    'type': 'optimization'},\n 'results': {'energies': array([-0.00568151]),\n             'energy': -0.005681511358588409,\n             'forces': array([[0., 0., 0.]]),\n             'free_energy': -0.005681511358588409},\n 'structure': Structure Summary\nLattice\n    abc : 2.5526554800834367 2.5526554800834367 2.5526554800834367\n angles : 60.00000000000001 60.00000000000001 60.00000000000001\n volume : 11.761470249999999\n      A : 0.0 1.805 1.805\n      B : 1.805 0.0 1.805\n      C : 1.805 1.805 0.0\n    pbc : True True True\nPeriodicSite: Cu (0.0, 0.0, 0.0) [0.0, 0.0, 0.0],\n 'symmetry': {'crystal_system': &lt;CrystalSystem.cubic: 'Cubic'&gt;,\n              'number': 225,\n              'point_group': 'm-3m',\n              'symbol': 'Fm-3m',\n              'symprec': 0.1,\n              'version': '2.1.0'},\n 'trajectory': [{'atoms': Atoms(symbols='Cu', pbc=True, cell=[[0.0, 1.805, 1.805], [1.805, 0.0, 1.805], [1.805, 1.805, 0.0]], calculator=SinglePointCalculator(...)),\n                 'atoms_info': {},\n                 'builder_meta': {'build_date': datetime.datetime(2023, 10, 19, 0, 46, 1, 744287),\n                                  'emmet_version': '0.69.6',\n                                  'pymatgen_version': '2023.10.4'},\n                 'chemsys': 'Cu',\n                 'composition': Composition('Cu1'),\n                 'composition_reduced': Composition('Cu1'),\n                 'density': 8.971719800606017,\n                 'density_atomic': 11.761470249999999,\n                 'elements': [Element Cu],\n                 'formula_anonymous': 'A',\n                 'formula_pretty': 'Cu',\n                 'nelements': 1,\n                 'nsites': 1,\n                 'structure': Structure Summary\nLattice\n    abc : 2.5526554800834367 2.5526554800834367 2.5526554800834367\n angles : 60.00000000000001 60.00000000000001 60.00000000000001\n volume : 11.761470249999999\n      A : 0.0 1.805 1.805\n      B : 1.805 0.0 1.805\n      C : 1.805 1.805 0.0\n    pbc : True True True\nPeriodicSite: Cu (0.0, 0.0, 0.0) [0.0, 0.0, 0.0],\n                 'symmetry': {'crystal_system': &lt;CrystalSystem.cubic: 'Cubic'&gt;,\n                              'number': 225,\n                              'point_group': 'm-3m',\n                              'symbol': 'Fm-3m',\n                              'symprec': 0.1,\n                              'version': '2.1.0'},\n                 'volume': 11.761470249999999}],\n 'trajectory_results': [{'energies': array([-0.00568151]),\n                         'energy': -0.005681511358588409,\n                         'forces': array([[0., 0., 0.]]),\n                         'free_energy': -0.005681511358588409}],\n 'volume': 11.761470249999999}\n</code></pre>"},{"location":"user/recipes/recipes_intro.html#a-simple-mixed-code-workflow","title":"A Simple Mixed-Code Workflow","text":"<pre><code>graph LR\n  A[Input] --&gt; B(EMT Relax) --&gt; C(GFN2-xTB Static) --&gt; D[Output]</code></pre> <p>Now let's return to our bulk Cu example from above and start adding on some complexity. Here, we will use EMT to run a relaxation on the bulk Cu structure and then use the output of this calculation as the input to a static calculation with the semi-empirical quantum mechanics method GFN2-xTB as implemented in quacc.recipes.tblite.core.static_job. This example highlights how there are no restrictions in terms of how many codes you can use in a single workflow.</p> <p>Note</p> <p>Some codes require additional setup, including <code>tblite</code> (which can only be <code>pip</code> installed on Linux). Refer to the Calculator Setup section for details.</p> <pre><code>from ase.build import bulk\nfrom quacc.recipes.emt.core import relax_job\nfrom quacc.recipes.tblite.core import static_job\n\n# Make an Atoms object of a bulk Cu structure\natoms = bulk(\"Cu\")\n\n# Run a structure relaxation with EMT\nresult1 = relax_job(atoms)\n\n# Run a static calculation with GFN2-xTB\nresult2 = static_job(result1[\"atoms\"], method=\"GFN2-xTB\")\nprint(result2)\n</code></pre> Printed Output <pre><code>{'atoms': Atoms(symbols='Cu', pbc=True, cell=[[0.0, 1.805, 1.805], [1.805, 0.0, 1.805], [1.805, 1.805, 0.0]], initial_magmoms=...),\n'atoms_info': {'_id': 'f8d53f110f524872f30a5cc20e8befb1',\n                '_old_ids': ['f8d53f110f524872f30a5cc20e8befb1']},\n'builder_meta': {'build_date': datetime.datetime(2023, 10, 18, 21, 22, 33, 352823),\n                'emmet_version': '0.69.6',\n                'pymatgen_version': '2023.10.4'},\n'chemsys': 'Cu',\n'composition': Composition('Cu1'),\n'composition_reduced': Composition('Cu1'),\n'density': 8.971719800606017,\n'density_atomic': 11.761470249999999,\n'dir_name': '/home/rosen',\n'elements': [Element Cu],\n'formula_anonymous': 'A',\n'formula_pretty': 'Cu',\n'input_atoms': {'atoms': Atoms(symbols='Cu', pbc=True, cell=[[0.0, 1.805, 1.805], [1.805, 0.0, 1.805], [1.805, 1.805, 0.0]], initial_magmoms=..., calculator=TBLite(...)),\n                'atoms_info': {'_id': 'f8d53f110f524872f30a5cc20e8befb1'},\n                'builder_meta': {'build_date': datetime.datetime(2023, 10, 18, 21, 22, 33, 348713),\n                                'emmet_version': '0.69.6',\n                                'pymatgen_version': '2023.10.4'},\n                'chemsys': 'Cu',\n                'composition': Composition('Cu1'),\n                'composition_reduced': Composition('Cu1'),\n                'density': 8.971719800606017,\n                'density_atomic': 11.761470249999999,\n                'elements': [Element Cu],\n                'formula_anonymous': 'A',\n                'formula_pretty': 'Cu',\n                'nelements': 1,\n                'nsites': 1,\n                'structure': Structure Summary\nLattice\n    abc : 2.5526554800834367 2.5526554800834367 2.5526554800834367\nangles : 60.00000000000001 60.00000000000001 60.00000000000001\nvolume : 11.761470249999999\n    A : 0.0 1.805 1.805\n    B : 1.805 0.0 1.805\n    C : 1.805 1.805 0.0\n    pbc : True True True\nPeriodicSite: Cu (0.0, 0.0, 0.0) [0.0, 0.0, 0.0],\n                'symmetry': {'crystal_system': &lt;CrystalSystem.cubic: 'Cubic'&gt;,\n                            'number': 225,\n                            'point_group': 'm-3m',\n                            'symbol': 'Fm-3m',\n                            'symprec': 0.1,\n                            'version': '2.1.0'},\n                'volume': 11.761470249999999},\n'name': 'TBLite Static',\n'nelements': 1,\n'nid': 'rosen.',\n'nsites': 1,\n'parameters': {'accuracy': 1.0,\n                'cache_api': True,\n                'electronic_temperature': 300.0,\n                'max_iterations': 250,\n                'method': 'GFN2-xTB',\n                'verbosity': 1},\n'results': {'charges': array([-4.63975525e-11]),\n            'dipole': array([-8.01874552e-08,  1.98737614e-07, -5.14192823e-08]),\n            'energy': -318.8584605831409,\n            'forces': array([[5.44452313e-20, 5.39007790e-19, 2.45003541e-19]]),\n            'free_energy': -318.8584605831409,\n            'stress': array([14.65181119, 14.65181119, 14.65181119,  1.40704868,  1.01943286,\n        0.63181703])},\n'structure': Structure Summary\nLattice\n    abc : 2.5526554800834367 2.5526554800834367 2.5526554800834367\nangles : 60.00000000000001 60.00000000000001 60.00000000000001\nvolume : 11.761470249999999\n    A : 0.0 1.805 1.805\n    B : 1.805 0.0 1.805\n    C : 1.805 1.805 0.0\n    pbc : True True True\nPeriodicSite: Cu (0.0, 0.0, 0.0) [0.0, 0.0, 0.0],\n'symmetry': {'crystal_system': &lt;CrystalSystem.cubic: 'Cubic'&gt;,\n            'number': 225,\n            'point_group': 'm-3m',\n            'symbol': 'Fm-3m',\n            'symprec': 0.1,\n            'version': '2.1.0'},\n'volume': 11.761470249999999}\n</code></pre>"},{"location":"user/recipes/recipes_intro.html#concluding-comments","title":"Concluding Comments","text":"<p>At this point, you now have the basic idea of how quacc recipes work!</p> <p>If you don't care about using a workflow engine, feel free to write simple quacc-based Python scripts and submit them as-is using your favorite computing machine and scheduler. However, if you are looking to efficiently scale up and monitor large numbers of workflows, continue reading!</p>"},{"location":"user/recipes/recipes_list.html","title":"List of Recipes","text":"<p>The list of available quacc recipes is shown below. The \"Req'd Extras\" column specifies any additional recipe-specific dependencies that must be installed beyond those mentioned in \"Calculator Setup\".</p>"},{"location":"user/recipes/recipes_list.html#dftb","title":"DFTB+","text":"<p>Info</p> <p>DFTB+ is especially useful for periodic GFN-xTB calculations and the DFTB+ method based on Slater-Koster parameters.</p> <p> Name Decorator Documentation Req'd Extras DFTB+ Static <code>@job</code> quacc.recipes.dftb.core.static_job DFTB+ Relax <code>@job</code> quacc.recipes.dftb.core.relax_job <p></p>"},{"location":"user/recipes/recipes_list.html#emt","title":"EMT","text":"<p>Info</p> <p>Effective medium theory (EMT) is a semi-empirical method for modeling solids that is predominantly used for prototyping workflows. Because it is solely for demonstration purposes, it only supports the following metals: Al, Ni, Cu, Pd, Ag, Pt, and Au.</p> <p> Name Decorator Documentation Req'd Extras EMT Static <code>@job</code> quacc.recipes.emt.core.static_job EMT Relax <code>@job</code> quacc.recipes.emt.core.relax_job EMT Bulk to Defects <code>@flow</code> quacc.recipes.emt.defects.bulk_to_defects_flow <code>quacc[defects]</code> EMT Bulk to Slabs <code>@flow</code> quacc.recipes.emt.slabs.bulk_to_slabs_flow EMT Phonons <code>@flow</code> quacc.recipes.emt.phonons.phonon_flow <code>quacc[phonons]</code> <p></p>"},{"location":"user/recipes/recipes_list.html#gaussian","title":"Gaussian","text":"<p>Info</p> <p>Gaussian is an extremely popular molecular DFT code that is quite robust and easy to use.</p> <p> Name Decorator Documentation Req'd Extras Gaussian Static <code>@job</code> quacc.recipes.gaussian.core.static_job Gaussian Relax <code>@job</code> quacc.recipes.gaussian.core.relax_job <p></p>"},{"location":"user/recipes/recipes_list.html#gulp","title":"GULP","text":"<p>Info</p> <p>GULP is especially useful for periodic GFN-FF calculations and force field methods. GULP can be downloaded and installed here.</p> <p> Name Decorator Documentation Req'd Extras GULP Static <code>@job</code> quacc.recipes.gulp.core.static_job GULP Relax <code>@job</code> quacc.recipes.gulp.core.relax_job <p></p>"},{"location":"user/recipes/recipes_list.html#lennard-jones-potential","title":"Lennard-Jones Potential","text":"<p>Info</p> <p>Lennard Jones (LJ) is an empirical potential that is predominantly used for prototyping workflows for molecules.</p> <p> Name Decorator Documentation Req'd Extras LJ Static <code>@job</code> quacc.recipes.lj.core.static_job LJ Relax <code>@job</code> quacc.recipes.lj.core.relax_job LJ Frequency <code>@job</code> quacc.recipes.lj.core.freq_job <p></p>"},{"location":"user/recipes/recipes_list.html#newtonnet","title":"NewtonNet","text":"<p>Info</p> <p>NewtonNet is a message passing network for deep learning of interatomic potentials and forces, as described here.</p> <p> Name Decorator Documentation Req'd Extras NewtonNet Static <code>@job</code> quacc.recipes.newtonnet.core.static_job NewtonNet Relax <code>@job</code> quacc.recipes.newtonnet.core.relax_job NewtonNet Frequency <code>@job</code> quacc.recipes.newtonnet.core.freq_job NewtonNet TS <code>@job</code> quacc.recipes.newtonnet.ts.ts_job <code>quacc[sella]</code> NewtonNet IRC <code>@job</code> quacc.recipes.newtonnet.ts.irc_job <code>quacc[sella]</code> NewtonNet Quasi IRC <code>@job</code> quacc.recipes.newtonnet.ts.quasi_irc_job <code>quacc[sella]</code> <p></p>"},{"location":"user/recipes/recipes_list.html#orca","title":"ORCA","text":"<p>Info</p> <p>ORCA is a free code that is especially useful for molecular DFT calculations with recently developed methods. ORCA can be downloaded and installed here.</p> <p> Name Decorator Documentation Req'd Extras ORCA Static <code>@job</code> quacc.recipes.orca.core.static_job ORCA Relax <code>@job</code> quacc.recipes.orca.core.relax_job <p></p>"},{"location":"user/recipes/recipes_list.html#psi4","title":"Psi4","text":"<p>Info</p> <p>Psi4 is an open-source quantum chemistry electronic structure package.</p> <p> Name Decorator Documentation Req'd Extras Psi4 Static <code>@job</code> quacc.recipes.psi4.core.static_job <p></p>"},{"location":"user/recipes/recipes_list.html#q-chem","title":"Q-Chem","text":"<p>Info</p> <p>Q-Chem is a powerful, general-purpose molecular DFT code with a variety of features.</p> <p> Name Decorator Documentation Req'd Extras Q-Chem Static <code>@job</code> quacc.recipes.qchem.core.static_job Q-Chem Relax <code>@job</code> quacc.recipes.qchem.core.relax_job Q-Chem Internal Relax <code>@job</code> quacc.recipes.qchem.core.internal_relax_job Q-Chem Frequency <code>@job</code> quacc.recipes.qchem.core.freq_job Q-Chem TS <code>@job</code> quacc.recipes.qchem.ts.ts_job <code>quacc[sella]</code> Q-Chem IRC <code>@job</code> quacc.recipes.qchem.ts.irc_job <code>quacc[sella]</code> Q-Chem Quasi IRC <code>@job</code> quacc.recipes.qchem.ts.quasi_irc_job <code>quacc[sella]</code> <p></p>"},{"location":"user/recipes/recipes_list.html#tblite","title":"TBLite","text":"<p>Info</p> <p>tblite is a code that interfaces with the xtb package for running GFN-xTB calculations.</p> <p> Name Decorator Documentation Req'd Extras TBLite Static <code>@job</code> quacc.recipes.tblite.core.static_job TBLite Relax <code>@job</code> quacc.recipes.tblite.core.relax_job TBLite Frequency <code>@job</code> quacc.recipes.tblite.core.freq_job TBLite Phonons <code>@flow</code> quacc.recipes.tblite.phonons.phonon_flow <code>quacc[phonons]</code> <p></p>"},{"location":"user/recipes/recipes_list.html#vasp","title":"VASP","text":"<p>Info</p> <p>VASP is a very widely used code for plane-wave, periodic DFT calculations. Quacc has built-in support for automatically fixing failed VASP jobs via Custodian.</p> <p> Name Decorator Documentation Req'd Extras VASP Static <code>@job</code> quacc.recipes.vasp.core.static_job VASP Relax <code>@job</code> quacc.recipes.vasp.core.relax_job VASP Double Relax <code>@job</code> quacc.recipes.vasp.core.double_relax_job VASP Slab Static <code>@job</code> quacc.recipes.vasp.slabs.slab_static_job VASP Slab Relax <code>@job</code> quacc.recipes.vasp.slabs.slab_relax_job VASP Bulk to Slabs <code>@flow</code> quacc.recipes.vasp.slabs.bulk_to_slabs_flow VASP Slab to Adsorbates <code>@flow</code> quacc.recipes.vasp.slabs.slab_to_ads_flow VASP MP Prerelax <code>@job</code> quacc.recipes.vasp.mp.mp_relax_job VASP MP Relax <code>@job</code> quacc.recipes.vasp.mp.mp_relax_job VASP MP Relax Workflow <code>@flow</code> quacc.recipes.vasp.mp.mp_relax_flow VASP QMOF Relax <code>@job</code> quacc.recipes.vasp.qmof.qmof_relax_job <p></p>"},{"location":"user/settings/settings.html","title":"Settings Management","text":"<p>Important</p> <p>The quacc configuration parameters (e.g. YAML file, environment variables) are only active on the machine where they are specified. In other words, each remote machine has its own custom set of configuration parameters.</p>"},{"location":"user/settings/settings.html#modifying-quacc-settings","title":"Modifying Quacc Settings","text":"<p>The default global quacc settings can be found in the <code>settings.py</code> file. If you wish to modify any of the global quacc settings, there are several ways to do so.</p>"},{"location":"user/settings/settings.html#using-a-yaml-file","title":"Using a YAML File","text":"<p>If you are planning to modify a given set of parameters for all of your calculations, the easiest way is to create a YAML file with custom settings. By default, quacc looks for this YAML file at <code>~/.quacc.yaml</code>. If you wish to store the YAML file somewhere else or with a different name, you can define the environment variable <code>QUACC_CONFIG_FILE</code> and point it to the YAML path of your choosing.</p> ~/.quacc.yaml<pre><code>SCRATCH_DIR: $SCRATCH # (1)!\nCREATE_UNIQUE_WORKDIR: true # (2)!\n</code></pre> <ol> <li> <p>This would set the quacc scratch directory to the environment variable <code>$SCRATCH</code> on whatever machine the calculations are run on.</p> </li> <li> <p>This would ensure that each job in your quacc workflow is run in a unique, isolated working directory. This is often useful when running workflows in parallel, although some workflow engines like Covalent have their own mechanisms for this.</p> </li> </ol> <p>Command-Line Interface</p> <p>The quacc command-line interface (CLI) lets you update the YAML file from the terminal. You can run <code>quacc set PARAMETER value</code> to set a given parameter in the YAML file to the specified value. Similarly, you can run <code>quacc unset PARAMETER</code> to remove a parameter from the YAML file.</p>"},{"location":"user/settings/settings.html#using-environment-variables","title":"Using Environment Variables","text":"<p>If you want to define quacc settings without writing them to a YAML file, you can instead modify the desired settings by defining individual environment variables with <code>QUACC</code> as the prefix. For instance, to modify the <code>SCRATCH_DIR</code> setting to be <code>$SCRATCH</code>, simply define <code>QUACC_SCRATCH_DIR=$SCRATCH</code> as a new environment variable. This approach is ideal when you want to modify the quacc settings for a subset of jobs, as the environment variable can be included in the job's submission script.</p>"},{"location":"user/settings/settings_list.html","title":"List of Quacc Settings","text":"quacc/settings.py<pre><code>    # ---------------------------\n    # Workflow Engine\n    # ---------------------------\n\n    WORKFLOW_ENGINE: Literal[\n        \"covalent\", \"jobflow\", \"parsl\", \"prefect\", \"redun\", \"local\"\n    ] = Field(\n        installed_engine,\n        description=(\n            \"The workflow manager to use.\"\n            \"Options include: 'covalent', 'parsl', 'redun', 'jobflow', 'prefect', or 'local'\"\n        ),\n    )\n\n    # ---------------------------\n    # General Settings\n    # ---------------------------\n\n    RESULTS_DIR: Path = Field(\n        Path.cwd(),\n        description=(\n            \"Directory to store I/O-based calculation results in.\"\n            \"Note that this behavior may be modified by the chosen workflow engine.\"\n            \"For instance, Covalent specifies the base directory as the `workdir` \"\n            \"of a local executor or the `remote_workdir` of a remote executor.\"\n            \"In this case, the `RESULTS_DIR` will be a subdirectory of that directory.\"\n        ),\n    )\n    SCRATCH_DIR: Path = Field(\n        Path(\"~/.scratch\"), description=\"Scratch directory for calculations.\"\n    )\n    CREATE_UNIQUE_WORKDIR: bool = Field(\n        False,\n        description=(\n            \"Whether to have a unique working directory in RESULTS_DIR for each job.\"\n            \"Some workflow engines have an option to do this for you already.\"\n        ),\n    )\n    GZIP_FILES: bool = Field(\n        True, description=\"Whether generated files should be gzip'd.\"\n    )\n    CHECK_CONVERGENCE: bool = Field(\n        True,\n        description=\"Whether to check for convergence in the `summarize_run`-type functions, if supported.\",\n    )\n\n    # ---------------------------\n    # Data Store Settings\n    # ---------------------------\n    PRIMARY_STORE: Optional[Union[str, Store]] = Field(\n        None,\n        description=(\n            \"String-based JSON representation of the primary Maggma data store \"\n            \"where calculation results will be stored.\"\n            \"Taken from the `.to_json()` method of the corresponding Store object.\"\n        ),\n    )\n\n    # ---------------------------\n    # ORCA Settings\n    # ---------------------------\n    ORCA_CMD: Path = Field(\n        Path(which(\"orca\") or \"orca\"),\n        description=(\n            \"Path to the ORCA executable. This must be the full, absolute path \"\n            \"for parallel calculations to work.\"\n        ),\n    )\n\n    # ---------------------------\n    # Gaussian Settings\n    # ---------------------------\n    GAUSSIAN_CMD: Path = Field(\n        Path(\"g16\"), description=(\"Path to the Gaussian executable.\")\n    )\n\n    # ---------------------------\n    # GULP Settings\n    # ---------------------------\n    GULP_CMD: Path = Field(Path(\"gulp\"), description=(\"Path to the GULP executable.\"))\n    GULP_LIB: Optional[Path] = Field(\n        None, description=(\"Path to the GULP force field library.\")\n    )\n\n    # ---------------------------\n    # VASP Settings\n    # ---------------------------\n\n    # VASP Settings: Main\n    VASP_PARALLEL_CMD: str = Field(\n        \"\",\n        description=(\n            \"Parallel command to run VASP with Custodian.\"\n            \"For example: srun -N 2 --ntasks-per-node 48\"\n            \"Note that this does not include the executable name.\"\n        ),\n    )\n    VASP_CMD: str = Field(\n        \"vasp_std\", description=\"Command to run the standard version of VASP.\"\n    )\n    VASP_GAMMA_CMD: str = Field(\n        \"vasp_gam\", description=\"Command to run the gamma-point only version of VASP.\"\n    )\n    VASP_PP_PATH: Optional[Path] = Field(\n        None,\n        description=\"Path to the VASP pseudopotential library. Must contain the directories `potpaw_PBE` and `potpaw` for PBE and LDA pseudopotentials, respectively.\",\n    )\n    VASP_VDW: Optional[Path] = Field(\n        None, description=\"Path to the vdw_kernel.bindat file for VASP vdW functionals.\"\n    )\n\n    # VASP Settings: General\n    VASP_INCAR_COPILOT: Literal[\"off\", \"on\", \"aggressive\"] = Field(\n        \"on\",\n        description=(\n            \"Controls VASP co-pilot mode for automated INCAR parameter handling.\"\n            \"off: Do not use co-pilot mode. INCAR parameters will be unmodified.\"\n            \"on: Use co-pilot mode. This will only modify INCAR flags not already set by the user.\"\n            \"aggressive: Use co-pilot mode in aggressive mode. This will modify INCAR flags even if they are already set by the user.\"\n        ),\n    )\n    VASP_BADER: bool = Field(\n        bool(which(\"bader\")),\n        description=(\n            \"Whether to run a Bader analysis when summarizing VASP results.\"\n            \"Requires bader to be in PATH.\"\n        ),\n    )\n    VASP_CHARGEMOL: bool = Field(\n        bool(os.environ.get(\"DDEC6_ATOMIC_DENSITIES_DIR\")),\n        description=(\n            \"Whether to run a Chargemol (i.e. DDEC6, CM5) analysis when summarizing VASP results.\"\n            \"Requires the Chargemol executable to be in PATH and the DDEC6_ATOMIC_DENSITIES_DIR environment variable.\"\n        ),\n    )\n    VASP_PRESET_MAG_DEFAULT: float = Field(\n        1.0,\n        description=(\n            \"Default initial magmom to use for a given element if a preset \"\n            \"with magmoms is provided but an element is missing from the list\"\n        ),\n    )\n    VASP_MAG_CUTOFF: float = Field(\n        0.05,\n        description=(\n            \"If the absolute value of all magnetic moments are below this value, \"\n            \"they will be set to 0 such that a spin-unpolarized calculation will be performed\"\n        ),\n    )\n    VASP_COPY_MAGMOMS: bool = Field(\n        True,\n        description=(\n            \"If True, any pre-existing atoms.get_magnetic_moments() will be set\"\n            \"in atoms.set_initial_magnetic_moments().\"\n        ),\n    )\n    VASP_PRESET_DIR: Path = Field(\n        Path(__file__).parent / \"calculators\" / \"vasp\" / \"presets\",\n        description=\"Path to the VASP preset directory\",\n    )\n\n    # VASP Settings: Custodian\n    VASP_USE_CUSTODIAN: bool = Field(\n        True, description=\"Whether Custodian should be used to run VASP\"\n    )\n    VASP_CUSTODIAN_VTST: bool = Field(\n        False,\n        description=(\n            \"If VTST-related input swaps should be used when running Custodian.\"\n            \"Requires VASP to be compiled with VTST\"\n        ),\n    )\n    VASP_CUSTODIAN_MAX_ERRORS: int = Field(\n        5, description=\"Maximum errors for Custodian\"\n    )\n    VASP_CUSTODIAN_HANDLERS: list[str] = Field(\n        [\n            \"VaspErrorHandler\",\n            \"MeshSymmetryErrorHandler\",\n            \"UnconvergedErrorHandler\",\n            \"NonConvergingErrorHandler\",\n            \"PotimErrorHandler\",\n            \"PositiveEnergyErrorHandler\",\n            \"FrozenJobErrorHandler\",\n            \"StdErrHandler\",\n            \"LargeSigmaHandler\",\n            \"IncorrectSmearingHandler\",\n        ],\n        description=\"Handlers for Custodian\",\n    )\n    VASP_CUSTODIAN_VALIDATORS: list[str] = Field(\n        [\"VasprunXMLValidator\", \"VaspFilesValidator\"],\n        description=\"Validators for Custodian\",\n    )\n    VASP_CUSTODIAN_WALL_TIME: Optional[int] = Field(\n        None,\n        description=(\n            \"After this many seconds, Custodian will stop running \"\n            \"and ensure that VASP writes a STOPCAR\"\n        ),\n    )\n\n    # ---------------------------\n    # Q-Chem Settings\n    # ---------------------------\n\n    # Q-Chem Settings: Main\n    QCHEM_CMD: str = Field(\n        \"qchem\", description=\"Command to run the standard version of Q-Chem.\"\n    )\n\n    QCHEM_LOCAL_SCRATCH: Path = Field(\n        Path(\"/tmp\") if Path(\"/tmp\").exists() else Path.cwd() / \".qchem_scratch\",\n        description=\"Compute-node local scratch directory in which Q-Chem should perform IO.\",\n    )\n\n    # Q-Chem Settings: Custodian\n    QCHEM_USE_ERROR_HANDLERS: bool = Field(\n        True,\n        description=\"Whether Custodian's error handlers should be employed for Q-Chem.\",\n    )\n\n    QCHEM_CUSTODIAN_MAX_ERRORS: int = Field(\n        5, description=\"Maximum errors for Q-Chem Custodian.\"\n    )\n\n    # NBO Settings\n    QCHEM_NBO_EXE: Optional[Path] = Field(\n        None, description=\"Full path to the NBO executable.\"\n    )\n\n    # ---------------------------\n    # NewtonNet Settings\n    # ---------------------------\n    NEWTONNET_MODEL_PATH: Union[Path, list[Path]] = Field(\n        \"best_model_state.tar\", description=\"Path to NewtonNet .tar model\"\n    )\n    NEWTONNET_CONFIG_PATH: Union[Path, list[Path]] = Field(\n        \"config.yml\", description=\"Path to NewtonNet YAML settings file\"\n    )\n</code></pre>"},{"location":"user/wflow_engine/executors1.html","title":"Deploying Calculations","text":"<p>In the previous examples, we have been running calculations on our local machine. However, in practice, you will probably want to run your calculations on one or more HPC machines. This section will describe how to set up your workflows to run on HPC machines using your desired workflow engine to scale up your calculations.</p> ParslCovalentRedunJobflow <p>Out-of-the-box, Parsl will run on your local machine. However, in practice you will probably want to run your Parsl workflows on HPC machines.</p> <p>Pilot Jobs</p> <p>Unlike most other workflow engines, Parsl is built for the pilot job model where the allocated nodes continually pull in new tasks to run. This makes it possible to avoid submitting a large number of small jobs to the scheduler, which can be inefficient from a queuing perspective.</p> <p>Configuring Executors</p> <p>Example Configurations</p> <p>To configure Parsl for the high-performance computing environment of your choice, refer to the executor Configuration page in the Parsl documentation for many examples.</p> <p>Let's imagine a scenario where we want to run a series of compute-intensive DFT calculations. Each DFT calculation requires 2 CPU nodes (each node having 48 cores). We want to run DFT calculations on 4 unique structures, all in parallel. We also want this to be done in a single Slurm allocation, meaning that this allocation must request 8 total nodes.</p> <p>An example <code>HighThroughputExecutor</code> that will orchestrate jobs from the login node of NERSC's Perlmutter machine to carry out the above example is as follows:</p> <pre><code>import parsl\nfrom parsl.config import Config\nfrom parsl.executors import HighThroughputExecutor\nfrom parsl.launchers import SimpleLauncher\nfrom parsl.providers import SlurmProvider\n\nmax_slurm_jobs = 1  # Maximum number of Slurm jobs (blocks) to allocate\nn_calcs_per_job = 4  # Number of calculations to run in parallel (per block)\nn_nodes_per_calc = 2  # Number of nodes to reserve for each calculation\n\nconfig = Config(\n    max_idletime=60,  # (1)!\n    strategy=\"htex_auto_scale\",  # (2)!\n    executors=[\n        HighThroughputExecutor(\n            label=\"quacc_parsl\",  # (3)!\n            max_workers=n_calcs_per_job,  # (4)!\n            cores_per_worker=1e-6,  # (5)!\n            provider=SlurmProvider(\n                account=\"MyAccountName\",\n                scheduler_options=\"#SBATCH -q debug -C cpu\",  # (6)!\n                worker_init=f\"source ~/.bashrc &amp;&amp; conda activate quacc\",  # (7)!\n                walltime=\"00:10:00\",  # (8)!\n                nodes_per_block=n_nodes_per_calc * n_calcs_per_job,  # (9)!\n                init_blocks=0,  # (10)!\n                min_blocks=0,  # (11)!\n                max_blocks=max_slurm_jobs,  # (12)!\n                launcher=SimpleLauncher(),  # (13)!\n                cmd_timeout=120,  # (14)!\n            ),\n        )\n    ],\n)\n\nparsl.load(config)\n</code></pre> <ol> <li> <p>The maximum amount of time (in seconds) to allow the executor to be idle before blocks (i.e. Slurm jobs) can potentially be shut down. Default is 120.</p> </li> <li> <p>Unique to the <code>HighThroughputExecutor</code>, this <code>strategy</code> will automatically scale the number of active blocks (i.e. Slurm jobs) up or down based on the number of tasks remaining. We set <code>max_blocks=1</code> here, so it can't scale up beyond 1 Slurm job, but it can scale down from 1 to 0 since <code>min_blocks=0</code>.</p> </li> <li> <p>This is just an arbitrary label for file I/O.</p> </li> <li> <p>Sets the maximum number of workers per block, which should generally be the number of tasks per block.</p> </li> <li> <p>This prevents the <code>HighThroughputExecutor</code> from reducing the number of workers if you request more workers than cores. It is recommended for codes that run via MPI.</p> </li> <li> <p>Any additional <code>#SBATCH</code> options not captured elsewhere can be included here.</p> </li> <li> <p>Any commands to run before carrying out any of the Parsl tasks. This is useful for setting environment variables, activating a given Conda environment, and loading modules.</p> </li> <li> <p>The walltime for each block (i.e. Slurm job).</p> </li> <li> <p>The number of nodes that each block (i.e. Slurm job) should allocate.</p> </li> <li> <p>Sets the number of blocks (e.g. Slurm jobs) to provision during initialization of the workflow. We set this to a value of 0 so that there isn't a running Slurm job before any tasks have been submitted to Parsl.</p> </li> <li> <p>Sets the minimum number of blocks (e.g. Slurm jobs) to maintain during elastic resource management. We set this to 0 so that Slurm jobs aren't running when there are no remaining tasks.</p> </li> <li> <p>Sets the maximum number of active blocks (e.g. Slurm jobs) during elastic resource management. We set this to 1 here, but it can be increased to have multiple Slurm jobs running simultaneously. Raising <code>max_blocks</code> to a larger value will allow the \"htex_auto_scale\" strategy to upscale resources as needed.</p> </li> <li> <p>The type of Launcher to use. <code>SimpleLauncher()</code> must be used instead of the commonly used <code>SrunLauncher()</code> to allow quacc subprocesses to launch their own <code>srun</code> commands.</p> </li> <li> <p>The maximum time to wait (in seconds) for the job scheduler info to be retrieved/sent.</p> </li> </ol> <p>Practical Deployment</p> <p>For debugging purposes or when running only a small numbers of jobs, it is simple enough to run the Parsl process from an interactive Jupyter Notebook or IPython kernel on the remote machine. However, for practical deployment and to ensure jobs are continually submitted to the queue even when the SSH session is terminated, you can run the Parsl orchestration process on a login node and maintain its state via a program like <code>tmux</code> or <code>screen</code>.</p> <p>For example, running <code>tmux new -s launcher</code> will create a new <code>tmux</code> session named <code>launcher</code>. To exit the <code>tmux</code> session while still preserving any running tasks on the login node, press <code>ctrl+b</code> followed by <code>d</code>. To re-enter the tmux session, run <code>tmux attach -t launcher</code>. Additional <code>tmux</code> commands can be found on the tmux cheatsheet.</p> <p>Multiple Executors</p> <p>Parsl supports tying specific executors to a given <code>PythonApp</code>, as discussed in the Multi-Executor section of the Parsl documentation.</p> <p>By default, Covalent will run all jobs on your local machine using the Dask backend. This is a parameter that you can control. For instance, Covalent offers many executor plugins that can be installed and used to interface with a wide range of HPC, cloud, and quantum devices.</p> <p>Setting the Executor for the Flow</p> <p>If you want to use the same executor for all the jobs in a workflow, you can pass the <code>executor</code> keyword argument to the <code>@flow</code> decorator.</p> <pre><code>import covalent as ct\nfrom ase.build import bulk\nfrom quacc import flow\nfrom quacc.recipes.emt.core import relax_job, static_job\n\n\n@flow(executor=\"local\")  # (1)!\ndef workflow(atoms):\n    result1 = relax_job(atoms)\n    result2 = static_job(result1[\"atoms\"])\n\n    return result2\n\n\natoms = bulk(\"Cu\")\ndispatch_id = ct.dispatch(workflow)(atoms)\nresult = ct.get_result(dispatch_id, wait=True)\nprint(result)\n</code></pre> <ol> <li>This was merely for demonstration purposes. There is never really a need to use the \"local\" executor since the \"dask\" executor runs locally and is faster.</li> </ol> <p>Setting Executors for Individual Jobs</p> <p>The individual executor options for each job can be modified after they are imported as well.</p> <pre><code>import covalent as ct\nfrom ase.build import bulk\nfrom quacc import flow\nfrom quacc.recipes.emt.core import relax_job, static_job\n\nrelax_job.electron_object.executor = \"dask\"\nstatic_job.electron_object.executor = \"local\"\n\n\n@flow\ndef workflow(atoms):\n    output1 = relax_job(atoms)\n    output2 = static_job(output1[\"atoms\"])\n\n    return output2\n\n\natoms = bulk(\"Cu\")\ndispatch_id = ct.dispatch(workflow)(atoms)\nresult = ct.get_result(dispatch_id, wait=True)\nprint(result)\n</code></pre> <p>Configuring Executors</p> <p>Example Configurations</p> <p>Refer to the executor plugin documentation for instructions on how to install and use the relevant plugins that allow Covalent to submit jobs on your desired machines.</p> <p>Most users of quacc will probably want to use the <code>HPCExecutor</code>, which is a plugin for Covalent that supports Slurm, PBS, LSF, Flux, and more. For submitting jobs to a Slurm-based job scheduler from your local machine, an example <code>HPCExecutor</code> configuration might look like the following, which has been tested on Perlmutter at NERSC:</p> <pre><code>n_nodes = 2  # Number of nodes to reserve for each calculation\nn_cores_per_node = 48  # Number of CPU cores per node\n\nexecutor = ct.executor.HPCExecutor(\n    # SSH credentials\n    username=\"YourUserName\",\n    address=\"perlmutter-p1.nersc.gov\",\n    ssh_key_file=\"~/.ssh/nersc\",\n    cert_file=\"~/.ssh/nersc-cert.pub\",  # (1)!\n    # PSI/J parameters\n    instance=\"slurm\",\n    resource_spec_kwargs={\n        \"node_count\": n_nodes,\n        \"processes_per_node\": n_cores_per_node,\n    },  # (2)!\n    job_attributes_kwargs={\n        \"duration\": 10,  # minutes\n        \"project_name\": \"YourAccountName\",\n        \"custom_attributes\": {\"slurm.constraint\": \"cpu\", \"slurm.qos\": \"debug\"},\n    },  # (3)!\n    # Remote Python env parameters\n    remote_conda_env=\"quacc\",\n    # Covalent parameters\n    remote_workdir=\"$SCRATCH/quacc\",\n    create_unique_workdir=True,  # (4)!\n    cleanup=False,  # (5)!\n)\n</code></pre> <ol> <li> <p>This a certificate file used to validate your SSH credentials. This is often not needed but is required at NERSC facilities due to the use of <code>sshproxy</code>-based multi-factor authentication.</p> </li> <li> <p>These are the resource specifications for the compute job, which are keyword arguments passed to PSI/J's <code>ResourceSpecV1</code> class.</p> </li> <li> <p>These are the job attributes that the job scheduler needs, which are keyword arguments passed to PSI/J's <code>JobAttributes</code> class.</p> </li> <li> <p>You generally want each quacc job to be run in its own unique working directory to ensure files don't overwrite one another, so  <code>create_unique_workdir</code> should be set to <code>True</code>.</p> </li> <li> <p>For debugging purposes, it can be useful to keep all the temporary files. Once you're confident things work, you can omit the <code>cleanup</code> keyword argument.</p> </li> </ol> Note <p>If you plan to use the dedicated SlurmExecutor developed by Covalent, an analogous example is included below:</p> <pre><code>n_nodes = 2\nn_cores_per_node = 48\n\nexecutor = ct.executor.SlurmExecutor(\n    username=\"YourUserName\",\n    address=\"perlmutter-p1.nersc.gov\",\n    ssh_key_file=\"~/.ssh/nersc\",\n    cert_file=\"~/.ssh/nersc-cert.pub\",\n    remote_workdir=\"$SCRATCH/quacc\",\n    conda_env=\"quacc\",\n    options={\n        \"nodes\": f\"{n_nodes}\",\n        \"qos\": \"debug\",\n        \"constraint\": \"cpu\",\n        \"account\": \"YourAccountName\",\n        \"job-name\": \"quacc\",\n        \"time\": \"00:10:00\",\n    },\n    use_srun=False,  # (1)!\n)\n</code></pre> <ol> <li>The <code>SlurmExecutor</code> must have <code>use_srun=False</code> in order for ASE-based calculators to be launched appropriately.</li> </ol> <p>Out-of-the-box, Redun will run on your local machine. However, in practice, you will probably want to specify a dedicated executor.</p> <p>Example Configurations</p> <p>To configure Redun for the high-performance computing environment of your choice, refer to the executors page in the Redun documentation.</p> <p>Out-of-the-box, Jobflow can be used to run on your local machine. You will, however, need a \"manager\" to run your workflows on HPC machines. The currently recommended manager for Jobflow is FireWorks, which is described here.</p> <p>Setting Up Your <code>my_qadapter.yaml</code></p> <p>When you set up Jobflow and FireWorks, you created a <code>my_qadapter.yaml</code> file. It's now time to revisit that file and adjust the <code>pre_rocket</code> command with any modules or environment variables necessary for your calculations to run. Additionally, you will probably want to update the <code>nodes</code>, <code>walltime</code>, and related settings for your scheduler.</p> <p>Converting Between Jobflow and FireWorks</p> <p>The <code>jobflow.managers.fireworks</code> module has all the tools you need to convert your Jobflow workflows to a format that is suitable for FireWorks.</p> <p>Converting a Job to a Firework</p> <p>To convert a <code>Job</code> to a <code>firework</code> and add it to your launch pad:</p> <pre><code>from fireworks import LaunchPad\nfrom jobflow.managers.fireworks import job_to_firework\n\nfw = job_to_firework(job)\nlpad = LaunchPad.auto_load()\nlpad.add_wf(fw)\n</code></pre> <p>Converting a Flow to a Workflow</p> <p>To convert a <code>Flow</code> to a <code>workflow</code> and add it to your launch pad:</p> <pre><code>from fireworks import LaunchPad\nfrom jobflow.managers.fireworks import flow_to_workflow\n\nwf = flow_to_workflow(flow)\nlpad = LaunchPad.auto_load()\nlpad.add_wf(wf)\n</code></pre> <p>Setting Where Jobs are Dispatched</p> <p>The <code>my_qadapter.yaml</code> file you made in the installation instructions specifies how FireWorks will submit jobs added to your launch pad. Additional details can be found in the Jobflow Documentation for how to dynamically set where and how Jobflow <code>Job</code> and <code>Flow</code> objects can be dispatched.</p> <p>Dispatching Calculations</p> <p>With a workflow added to your launch pad, on the desired machine of choice, you can run <code>qlaunch rapidfire --nlaunches &lt;N&gt;</code> (where <code>&lt;N&gt;</code> is the number of jobs to submit) in the command line to submit your workflows to the job scheduler. Running <code>qlaunch rapidfire -m &lt;N&gt;</code> will ensure that <code>&lt;N&gt;</code> jobs are always in the queue or running. To modify the order in which jobs are run, a priority can be set via <code>lpad set_priority &lt;priority&gt; -i &lt;FWID&gt;</code> where <code>&lt;priority&gt;</code> is a number.</p> <p>By default, <code>qlaunch</code> will launch compute jobs that each poll for a single FireWork to run. This means that more Slurm jobs may be submitted than there are jobs to run. To modify the behavior of <code>qlaunch</code> to only submit a Slurm job for each \"READY\" FireWork in the launchpad, use the <code>-r</code> (\"reserved\") flag.</p> <p>Monitoring the Launchpad</p> <p>The easiest way to monitor the state of your launched FireWorks and workflows is through the GUI, which can be viewed with <code>lpad webgui</code>. To get the status of running fireworks from the command line, you can run <code>lpad get_fws -s RUNNING</code>. Other statuses can also be provided as well as individual FireWorks IDs.</p> <p>To rerun a specific FireWork, one can use the <code>rerun_fws</code> command like so: <code>lpad rerun_fws -i &lt;FWID&gt;</code> where <code>&lt;FWID&gt;</code> is the FireWork ID. Similarly, one can rerun all fizzled jobs via <code>lpad rerun_fws -s FIZZLED</code>. More complicated Mongo-style queries can also be carried out. Cancelling a workflow can be done with <code>lpad delete_wflows -i &lt;FWID&gt;</code>.</p> <p>Refer to the <code>lpad -h</code> help menu for more details.</p> <p>Continuous Job Submission</p> <p>To ensure that jobs are continually submitted to the queue, you can use <code>tmux</code> to preserve the job submission process even when the SSH session is terminated. For example, running <code>tmux new -s launcher</code> will create a new <code>tmux</code> session named <code>launcher</code>. To exit the <code>tmux</code> session while still preserving any running tasks on the login node, press <code>ctrl+b</code> followed by <code>d</code>. To re-enter the tmux session, run <code>tmux attach -t launcher</code>. Additional <code>tmux</code> commands can be found on the tmux cheatsheet.</p>"},{"location":"user/wflow_engine/executors2.html","title":"Worked Examples on HPC","text":"<p>In this section, we provide a few examples going through the entire process to deploy recipes remotely on HPC machines that use a job scheduler. The precise configuration details will depend on your given compute setup. Nonetheless, we have provided examples here for Perlmutter at NERSC that you can build from.</p> <p>First-Time Deployment</p> <p>Before deploying remote calculations for the first time, do <code>quacc set WORKFLOW_ENGINE local</code> on the remote machine and run your recipe as a standard Python script (e.g. by submitting it as a job to the scheduler). This preliminary test will help you identify potential issues early on. When you're done, you can re-set the <code>WORKFLOW_ENGINE</code> variable and continue with deployment via a workflow manager.</p>"},{"location":"user/wflow_engine/executors2.html#pre-requisites","title":"Pre-Requisites","text":"<p>If you haven't done so already:</p> ParslCovalentJobflow <p>On the remote machine:</p> <pre><code>pip install --force-reinstall --no-deps https://gitlab.com/ase/ase/-/archive/master/ase-master.zip\npip install quacc[parsl]\nquacc set WORKFLOW_ENGINE parsl &amp;&amp; quacc set CREATE_UNIQUE_WORKDIR True\n</code></pre> <p>On both the local and remote machines:</p> <pre><code>pip install --force-reinstall --no-deps https://gitlab.com/ase/ase/-/archive/master/ase-master.zip\npip install quacc[covalent]\nquacc set WORKFLOW_ENGINE covalent\n</code></pre> <p>On the local machine:</p> <pre><code>covalent start\n</code></pre> <p>For NERSC Users</p> <p>If using Perlmutter at NERSC, modify your <code>~/.bashrc</code> on the remote machine as follows since only the <code>$SCRATCH</code> directory supports file locking mechanisms:</p> ~/.bashrc<pre><code>export COVALENT_CONFIG_DIR=\"$SCRATCH/.config/covalent\"\n</code></pre> <p>On both the local and remote machines:</p> <pre><code>pip install --force-reinstall --no-deps https://gitlab.com/ase/ase/-/archive/master/ase-master.zip\npip install quacc[jobflow]\nquacc set WORKFLOW_ENGINE jobflow\n</code></pre>"},{"location":"user/wflow_engine/executors2.html#example-1","title":"Example 1","text":"<p>When deploying calculations for the first time, it's important to start simple, which is why you should try to run a sample EMT workflow first.</p> ParslCovalentJobflow <p>Starting Small</p> <p>From an interactive resource like a Jupyter Notebook or IPython kernel on the remote machine:</p> <pre><code>import parsl\nfrom parsl.config import Config\nfrom parsl.executors import HighThroughputExecutor\nfrom parsl.launchers import SimpleLauncher\nfrom parsl.providers import SlurmProvider\n\naccount = \"MyAccountName\"\n\nconfig = Config(\n    max_idletime=60,\n    strategy=\"htex_auto_scale\",\n    executors=[\n        HighThroughputExecutor(\n            label=\"quacc_parsl\",\n            provider=SlurmProvider(\n                account=account,\n                scheduler_options=\"#SBATCH -q debug -C cpu\",\n                worker_init=\"source ~/.bashrc &amp;&amp; conda activate quacc\",\n                walltime=\"00:10:00\",\n                nodes_per_block=1,\n                init_blocks=0,\n                min_blocks=0,\n                max_blocks=1,\n                launcher=SimpleLauncher(),\n                cmd_timeout=120,\n            ),\n        )\n    ],\n)\n\nparsl.load(config)\n</code></pre> <pre><code>from ase.build import bulk\nfrom quacc.recipes.emt.core import relax_job, static_job\n\n\ndef workflow(atoms):\n    relax_output = relax_job(atoms)\n    return static_job(relax_output[\"atoms\"])\n\n\natoms = bulk(\"Cu\")\nfuture = workflow(atoms)\nresult = future.result()\nprint(result)\n</code></pre> <p>Scaling Up</p> <p>Now it's time to scale things up and show off Parsl's true power. Let's run a TBLite relaxation and frequency calculation for 162 molecules in the so-called \"g2\" collection of small, neutral molecules.</p> <p>On the remote machine, make sure to run <code>pip install quacc[tblite]</code>. Then run the following example, adjusting the configuration as necessary for your machine.</p> <p>First we initialize a Parsl configuration. For this example, we will request 2 Slurm jobs (blocks), each of which will run tasks over 2 nodes that will be dynamically scaled.</p> <pre><code>import parsl\nfrom parsl.config import Config\nfrom parsl.executors import HighThroughputExecutor\nfrom parsl.launchers import SimpleLauncher\nfrom parsl.providers import SlurmProvider\n\naccount = \"MyAccountName\"\n\nconfig = Config(\n    max_idletime=60,\n    strategy=\"htex_auto_scale\",\n    executors=[\n        HighThroughputExecutor(\n            label=\"quacc_parsl\",\n            provider=SlurmProvider(\n                account=account,\n                scheduler_options=\"#SBATCH -q debug -C cpu\",\n                worker_init=\"source ~/.bashrc &amp;&amp; conda activate quacc\",\n                walltime=\"00:10:00\",\n                nodes_per_block=2,\n                init_blocks=0,\n                min_blocks=0,\n                max_blocks=2,\n                launcher=SimpleLauncher(),\n                cmd_timeout=120,\n            ),\n        )\n    ],\n)\nparsl.load(config)\n</code></pre> <p>Now we define the workflow:</p> <pre><code>from quacc.recipes.tblite.core import relax_job, freq_job\n\n\ndef workflow(atoms):\n    relax_output = relax_job(atoms)\n    return freq_job(relax_output[\"atoms\"], energy=relax_output[\"energy\"])\n</code></pre> <p>We now loop over all molecules in the \"g2\" collection and apply our workflow.</p> <pre><code>from ase.collections import g2\n\nfutures = []\nfor name in g2.names:\n    atoms = g2[name]\n    future = workflow(atoms)  #  (1)!\n    futures.append(future)\n</code></pre> <ol> <li>This is where the calculations are asynchronously launched.</li> </ol> <p>We monitor the progress of our calculations and print a few summary values.</p> <pre><code>from tqdm import tqdm\nfrom concurrent.futures import as_completed\n\nfor future in tqdm(as_completed(futures), total=len(futures)):\n    task_doc = future.result()\n    print(\n        task_doc[\"formula_pretty\"],\n        task_doc[\"results\"][\"gibbs_energy\"],\n        task_doc[\"dir_name\"],\n    )\n</code></pre> <p>Run the following code on the local machine:</p> <pre><code>import covalent as ct\nfrom ase.build import bulk\nfrom quacc import flow\nfrom quacc.recipes.emt.core import relax_job, static_job\n\nusername = \"MyUserName\"\naccount = \"MyAccountName\"\n\nexecutor = ct.executor.HPCExecutor(\n    username=username,\n    address=\"perlmutter-p1.nersc.gov\",\n    ssh_key_file=\"~/.ssh/nersc\",\n    cert_file=\"~/.ssh/nersc-cert.pub\",\n    instance=\"slurm\",\n    resource_spec_kwargs={\n        \"node_count\": 1,\n        \"processes_per_node\": 1,\n    },\n    job_attributes_kwargs={\n        \"duration\": 10,\n        \"project_name\": account,\n        \"custom_attributes\": {\"slurm.constraint\": \"cpu\", \"slurm.qos\": \"debug\"},\n    },\n    remote_conda_env=\"quacc\",\n    remote_workdir=\"$SCRATCH/quacc\",\n    create_unique_workdir=True,\n    cleanup=False,\n)\n\n\n@flow(executor=executor)\ndef workflow(atoms):\n    relax_output = relax_job(atoms)\n    return static_job(relax_output[\"atoms\"])\n\n\natoms = bulk(\"Cu\")\ndispatch_id = ct.dispatch(workflow)(atoms)\nresult = ct.get_result(dispatch_id, wait=True)\nprint(result)\n</code></pre> <p>Debugging</p> <p>The most common cause of issues is related to the job scheduler details (i.e. the <code>resource_spec_kwargs</code> and the <code>job_attributes_kwargs</code>). If your job fails on the remote machine, check the files left behind in the working directory as well as the <code>~/.psij</code> directory for a history and various log files associated with your attempted job submissions.</p> <p>From the login node of the remote machine, run the following:</p> <pre><code>import jobflow as jf\nfrom ase.build import bulk\nfrom fireworks import LaunchPad\nfrom jobflow.managers.fireworks import flow_to_workflow\nfrom quacc.recipes.emt.core import relax_job, static_job\n\natoms = bulk(\"Cu\")\njob1 = relax_job(atoms)\njob2 = static_job(job1.output[\"atoms\"])\nflow = jf.Flow([job1, job2])\n\nwf = flow_to_workflow(flow)\nlpad = LaunchPad.auto_load()\nlpad.add_wf(wf)\n</code></pre> <p>Then run the following on the remote machine:</p> <pre><code>qlaunch rapidfire -m 1\n</code></pre>"},{"location":"user/wflow_engine/executors2.html#example-2","title":"Example 2","text":"<p>In this example, we will run a sample VASP recipe that will highlight the use of a more complicated configuration.</p> <p>First, prepare your <code>QUACC_VASP_PP_PATH</code> environment variable in the <code>~/.bashrc</code> of your remote machine as described in the Calculator Setup guide. When you're done, follow the steps below.</p> ParslCovalentJobflow <p>From an interactive resource like a Jupyter Notebook or IPython kernel on the remote machine:</p> <pre><code>import parsl\nfrom parsl.config import Config\nfrom parsl.executors import HighThroughputExecutor\nfrom parsl.launchers import SimpleLauncher\nfrom parsl.providers import SlurmProvider\n\naccount = \"MyAccountName\"\nmax_slurm_jobs = 1\nn_calcs_per_job = 2\nn_nodes_per_calc = 1\nn_cores_per_node = 128\n\nconfig = Config(\n    strategy=\"htex_auto_scale\",\n    executors=[\n        HighThroughputExecutor(\n            label=\"quacc_parsl\",\n            max_workers=n_calcs_per_job,\n            cores_per_worker=1e-6,\n            provider=SlurmProvider(\n                account=account,\n                scheduler_options=\"#SBATCH -q debug -C cpu\",\n                worker_init=f\"source ~/.bashrc &amp;&amp; conda activate quacc &amp;&amp; module load vasp/6.4.1-cpu &amp;&amp; export QUACC_VASP_PARALLEL_CMD='srun -N {n_nodes_per_calc} --ntasks-per-node={n_cores_per_node} --cpu_bind=cores'\",\n                walltime=\"00:10:00\",\n                nodes_per_block=n_nodes_per_calc * n_calcs_per_job,\n                init_blocks=0,\n                min_blocks=0,\n                max_blocks=max_slurm_jobs,\n                launcher=SimpleLauncher(),\n                cmd_timeout=120,\n            ),\n        )\n    ],\n)\n\nparsl.load(config)\n</code></pre> <pre><code>from ase.build import bulk\nfrom quacc.recipes.vasp.core import relax_job, static_job\n\n\ndef workflow(atoms):\n    relax_output = relax_job(atoms, kpts=[3, 3, 3])\n    return static_job(relax_output[\"atoms\"], kpts=[3, 3, 3])\n\n\nfuture1 = workflow(bulk(\"C\"))\nfuture2 = workflow(bulk(\"Cu\"))\nprint(future1.result(), future2.result())\n</code></pre> <p>Run the following code on the local machine:</p> <pre><code>import covalent as ct\nfrom ase.build import bulk\nfrom quacc import flow\nfrom quacc.recipes.vasp.core import relax_job, static_job\n\nusername = \"MyUserName\"\naccount = \"MyAccountName\"\nn_nodes = 1\nn_cores_per_node = 128\n\nexecutor = ct.executor.HPCExecutor(\n    username=username,\n    address=\"perlmutter-p1.nersc.gov\",\n    ssh_key_file=\"~/.ssh/nersc\",\n    cert_file=\"~/.ssh/nersc-cert.pub\",\n    instance=\"slurm\",\n    resource_spec_kwargs={\n        \"node_count\": n_nodes,\n        \"processes_per_node\": n_cores_per_node,\n    },\n    job_attributes_kwargs={\n        \"duration\": 30,\n        \"project_name\": account,\n        \"custom_attributes\": {\"slurm.constraint\": \"cpu\", \"slurm.qos\": \"debug\"},\n    },\n    pre_launch_cmds=[\"module load vasp/6.4.1-cpu\"],\n    environment={\"QUACC_VASP_PARALLEL_CMD\": f\"srun -N {n_nodes} --ntasks-per-node={n_cores_per_node} --cpu_bind=cores\"},\n    remote_conda_env=\"quacc\",\n    remote_workdir=\"$SCRATCH/quacc\",\n    create_unique_workdir=True,\n    cleanup=False,\n)\n\n\n@flow(executor=executor)\ndef workflow(atoms):\n    relax_output = relax_job(atoms)\n    return static_job(relax_output[\"atoms\"])\n\n\natoms = bulk(\"C\")\ndispatch_id = ct.dispatch(workflow)(atoms)\nresult = ct.get_result(dispatch_id, wait=True)\nprint(result)\n</code></pre> <p>You will need to update your <code>my_qadapter.yaml</code> file that you made when setting up FireWorks. Specifically, ensure that the following parameters are set:</p> my_qadapter.yaml<pre><code>_fw_name: CommonAdapter\n_fw_q_type: SLURM\nrocket_launch: rlaunch -w /path/to/fw_config/my_fworker.yaml singleshot\nnodes: 1\nwalltime: 00:30:00\naccount: MyAccountName\njob_name: quacc_firework\nqos: debug\npre_rocket: |\nmodule load vasp/6.4.1-cpu\nexport QUACC_VASP_PARALLEL_CMD=\"srun -N 1 --ntasks-per-node=128 --cpu_bind=cores\"\n</code></pre> <p>From the login node of the remote machine, then run the following:</p> <pre><code>import jobflow as jf\nfrom ase.build import bulk\nfrom fireworks import LaunchPad\nfrom jobflow.managers.fireworks import flow_to_workflow\nfrom quacc.recipes.vasp.core import relax_job, static_job\n\natoms = bulk(\"C\")\njob1 = relax_job(atoms, kpts=[3, 3, 3])\njob2 = static_job(job1.output[\"atoms\"], kpts=[3, 3, 3])\nflow = jf.Flow([job1, job2])\n\nwf = flow_to_workflow(flow)\nlpad = LaunchPad.auto_load()\nlpad.add_wf(wf)\n</code></pre> <p>Then run the following on the remote machine:</p> <pre><code>qlaunch rapidfire -m 1\n</code></pre>"},{"location":"user/wflow_engine/wflow_engines1.html","title":"Pre-Defined Recipes","text":"<p>Here, we will show how to use quacc with one of a variety of workflow engines to construct, dispatch, and monitor your calculations. In quacc, there are two types of recipes:</p> <ol> <li>Individual compute jobs with the suffix <code>_job</code> that have been pre-defined with a <code>@job</code> decorator.</li> <li>Multi-step workflows with the suffix <code>_flow</code> that have been pre-defined with a <code>@flow</code> decorator.</li> </ol>"},{"location":"user/wflow_engine/wflow_engines1.html#running-a-pre-defined-job","title":"Running a Pre-Defined Job","text":"<p>We will now try running a job where we relax a bulk Cu structure using EMT, which is pre-defined in quacc as quacc.recipes.emt.core.relax_job.</p> <pre><code>graph LR\n  A[Input] --&gt; B(Relax) --&gt; C[Output];</code></pre> ParslCovalentRedunJobflow <p>Important</p> <p>If you haven't done so yet, make sure you update the quacc <code>WORKFLOW_ENGINE</code> configuration variable and load the default Parsl configuration:</p> terminal<pre><code>quacc set WORKFLOW_ENGINE parsl\n</code></pre> python<pre><code>import parsl\n\nparsl.load()\n</code></pre> <pre><code>from ase.build import bulk\nfrom quacc.recipes.emt.core import relax_job\n\n# Make an Atoms object of a bulk Cu structure\natoms = bulk(\"Cu\")\n\n# Call the PythonApp\nfuture = relax_job(atoms)  # (1)!\n\n# Print result\nprint(future.result())  # (2)!\n</code></pre> <ol> <li> <p>The <code>relax_job</code> function was pre-defined in quacc with a <code>@job</code> decorator, which is why we did not need to include it here. We also did not need to use a <code>@flow</code> decorator because Parsl does not have an analogous decorator.</p> </li> <li> <p>The use of <code>.result()</code> serves to block any further calculations from running until it is resolved. Calling <code>.result()</code> also returns the function output as opposed to the <code>AppFuture</code> object.</p> </li> </ol> <p>Important</p> <p>If you haven't done so yet, make sure you update the quacc <code>WORKFLOW_ENGINE</code> configuration variable and start the Covalent server:</p> <pre><code>quacc set WORKFLOW_ENGINE covalent\ncovalent start\n</code></pre> <pre><code>import covalent as ct\nfrom ase.build import bulk\nfrom quacc import flow\nfrom quacc.recipes.emt.core import relax_job\n\n# Make an Atoms object of a bulk Cu structure\natoms = bulk(\"Cu\")\n\n# Define the workflow\nworkflow = flow(relax_job)  # (1)!\n\n# Dispatch the workflow to the Covalent server\n# with the bulk Cu Atoms object as the input\ndispatch_id = ct.dispatch(workflow)(atoms)  # (2)!\n\n# Fetch the result from the server\nresult = ct.get_result(dispatch_id, wait=True)  # (3)!\nprint(result)\n</code></pre> <ol> <li> <p>This is shorthand for the following:</p> <pre><code>@flow\ndef workflow(atoms):\n    return relax_job(atoms)\n</code></pre> <p>Also note that the <code>relax_job</code> function was pre-defined in quacc with a <code>@job</code> decorator, which is why we did not need to include it here.</p> </li> <li> <p>This will dispatch the workflow to the Covalent server.</p> </li> <li> <p>The <code>ct.get_result</code> function is used to fetch the workflow status and results from the server. You don't need to set <code>wait=True</code> in practice. Once you dispatch the workflow, it will begin running (if the resources are available).</p> </li> </ol> <p>Important</p> <p>If you haven't done so yet, make sure you update the quacc <code>WORKFLOW_ENGINE</code> configuration variable:</p> <pre><code>quacc set WORKFLOW_ENGINE redun\n</code></pre> <pre><code>from ase.build import bulk\nfrom redun import Scheduler\nfrom quacc.recipes.emt.core import relax_job\n\n# Instantiate the scheduler\nscheduler = Scheduler()\n\n# Make an Atoms object of a bulk Cu structure\natoms = bulk(\"Cu\")\n\n# Dispatch the workflow\nresult = scheduler.run(relax_job(atoms))  # (1)!\nprint(result)\n</code></pre> <ol> <li>The <code>relax_job</code> function was pre-defined in quacc with a <code>@job</code> decorator, which is why we did not need to include it here.</li> </ol> <p>Important</p> <p>If you haven't done so yet, make sure you update the quacc <code>WORKFLOW_ENGINE</code> configuration variable:</p> <pre><code>quacc set WORKFLOW_ENGINE jobflow\n</code></pre> <pre><code>import jobflow as jf\nfrom ase.build import bulk\nfrom quacc.recipes.emt.core import relax_job\n\n# Make an Atoms object of a bulk Cu structure\natoms = bulk(\"Cu\")\n\n# Define the Job\njob = relax_job(atoms)  # (1)!\n\n# Run the job locally\nresponses = jf.run_locally(job, create_folders=True)  # (2)!\n\n# Get the result\nresult = responses[job.uuid][1].output\nprint(result)\n</code></pre> <ol> <li> <p>The <code>relax_job</code> function was pre-defined in quacc with a <code>@job</code> decorator, which is why we did not need to include it here.</p> </li> <li> <p>We chose to run the job locally, but other workflow managers supported by Jobflow can be imported and used.</p> </li> </ol>"},{"location":"user/wflow_engine/wflow_engines1.html#running-a-pre-defined-workflow","title":"Running a Pre-Defined Workflow","text":"<p>We will now try running a pre-defined workflow where we carve all possible slabs from a given structure, run a new relaxation calculation on each slab, and then a static calculation for each relaxed slab. This is implemented in quacc.recipes.emt.slabs.bulk_to_slabs_flow.</p> <pre><code>graph LR\n  A[Input] --&gt; B(Make Slabs)\n  B --&gt; C(Slab Relax) --&gt; G(Slab Static) --&gt; K[Output]\n  B --&gt; D(Slab Relax) --&gt; H(Slab Static) --&gt; K[Output]\n  B --&gt; E(Slab Relax) --&gt; I(Slab Static) --&gt; K[Output]\n  B --&gt; F(Slab Relax) --&gt; J(Slab Static) --&gt; K[Output];</code></pre> ParslCovalentRedunJobflow <pre><code>from ase.build import bulk\nfrom quacc.recipes.emt.slabs import bulk_to_slabs_flow\n\n# Define the Atoms object\natoms = bulk(\"Cu\")\n\n# Define the workflow\nfuture = bulk_to_slabs_flow(atoms)\n\n# Print the results\nprint(future.result())\n</code></pre> <pre><code>import covalent as ct\nfrom ase.build import bulk\nfrom quacc.recipes.emt.slabs import bulk_to_slabs_flow\n\n# Define the Atoms object\natoms = bulk(\"Cu\")\n\n# Dispatch the workflow\ndispatch_id = ct.dispatch(bulk_to_slabs_flow)(atoms)  # (1)!\n\n# Print the results\nresult = ct.get_result(dispatch_id, wait=True)\nprint(result)\n</code></pre> <ol> <li>We didn't need to wrap <code>bulk_to_slabs_flow</code> with a decorator because it is already pre-decorated with a <code>@flow</code> decorator.</li> </ol> <pre><code>from ase.build import bulk\nfrom redun import Scheduler\nfrom quacc.recipes.emt.slabs import bulk_to_slabs_flow\n\n# Instantiate the scheduler\nscheduler = Scheduler()\n\n# Define the Atoms object\natoms = bulk(\"Cu\")\n\n# Define the workflow\nresult = scheduler.run(bulk_to_slabs_flow(atoms))  # (1)!\n\n# Print the results\nprint(result)\n</code></pre> <ol> <li>We didn't need to wrap <code>bulk_to_slabs_flow</code> with a decorator because it is already pre-decorated with a <code>@flow</code> decorator.</li> </ol> <p>Warning</p> <p>Due to the difference in how Jobflow handles workflows (particularly dynamic ones) compared to other supported workflow engines, any quacc recipes that have been pre-defined with a <code>@flow</code> decorator (i.e. have <code>_flow</code> in the name) cannot be run directly with Jobflow. Rather, a Jobflow-specific <code>Flow</code> needs to be constructed by the user.</p>"},{"location":"user/wflow_engine/wflow_engines2.html","title":"Combining Recipes","text":"<p>Here, we will show how to use combine quacc jobs and workflows into your own custom workflows that can be run with your chosen workflow engine.</p>"},{"location":"user/wflow_engine/wflow_engines2.html#running-a-user-constructed-serial-workflow","title":"Running a User-Constructed Serial Workflow","text":"<p>We will now try running a simple workflow where we relax a bulk Cu structure using EMT and take the output of that calculation as the input to a follow-up static calculation with EMT.</p> <pre><code>graph LR\n  A[Input] --&gt; B(Relax) --&gt; C(Static) --&gt; D[Output];</code></pre> ParslCovalentRedunJobflow <p>Important</p> <p>If you haven't done so yet, make sure you update the quacc <code>WORKFLOW_ENGINE</code> configuration variable and load the default Parsl configuration:</p> terminal<pre><code>quacc set WORKFLOW_ENGINE parsl\n</code></pre> python<pre><code>import parsl\n\nparsl.load()\n</code></pre> <pre><code>from ase.build import bulk\nfrom quacc.recipes.emt.core import relax_job, static_job\n\n\n# Define the workflow\ndef workflow(atoms):\n    # Define Job 1\n    future1 = relax_job(atoms)  # (1)!\n\n    # Define Job 2, which takes the output of Job 1 as input\n    future2 = static_job(future1[\"atoms\"])\n\n    return future2\n\n\n# Make an Atoms object of a bulk Cu structure\natoms = bulk(\"Cu\")\n\n# Dispatch the workflow\nfuture = workflow(atoms)\n\n# Fetch the result\nresult = future.result()  # (2)!\nprint(result)\n</code></pre> <ol> <li> <p>The <code>relax_job</code> function was pre-defined in quacc with a <code>@job</code> decorator, which is why we did not need to include it here.</p> </li> <li> <p>The use of <code>.result()</code> serves to block any further calculations from running until it is resolved. Calling <code>.result()</code> also returns the function output as opposed to the <code>AppFuture</code> object.</p> </li> </ol> <p>Note</p> <p>Parsl <code>PythonApp</code> objects will implicitly know to call <code>.result()</code> on any <code>AppFuture</code> it receives, and it is good to rely on this fact to avoid unnecessary blocking.</p> <p>Important</p> <p>If you haven't done so yet, make sure you update the quacc <code>WORKFLOW_ENGINE</code> configuration variable and start the Covalent server:</p> <pre><code>quacc set WORKFLOW_ENGINE covalent\ncovalent start\n</code></pre> <pre><code>import covalent as ct\nfrom ase.build import bulk\nfrom quacc import flow\nfrom quacc.recipes.emt.core import relax_job, static_job\n\n\n# Define the workflow\n@flow  # (1)!\ndef workflow(atoms):\n    # Define Job 1\n    result1 = relax_job(atoms)  # (2)!\n\n    # Define Job 2, which takes the output of Job 1 as input\n    result2 = static_job(result1[\"atoms\"])\n\n    return result2\n\n\n# Make an Atoms object of a bulk Cu structure\natoms = bulk(\"Cu\")\n\n# Dispatch the workflow to the Covalent server\n# with the bulk Cu Atoms object as the input\ndispatch_id = ct.dispatch(workflow)(atoms)  # (3)!\n\n# Fetch the result from the server\nresult = ct.get_result(dispatch_id, wait=True)  # (4)!\nprint(result)\n</code></pre> <ol> <li> <p>The <code>@flow</code> decorator defines the workflow that will be executed. It is the same as calling <code>ct.lattice</code> in Covalent.</p> </li> <li> <p>The <code>relax_job</code> function was pre-defined in quacc with a <code>@job</code> decorator, which is why we did not need to include it here.</p> </li> <li> <p>Because the workflow was defined with a <code>@flow</code> decorator, it will be sent to the Covalent server and a dispatch ID will be returned.</p> </li> <li> <p>You don't need to set <code>wait=True</code> in practice. Once you dispatch the workflow, it will begin running (if the resources are available). The <code>ct.get_result</code> function is used to fetch the workflow status and results from the server.</p> </li> </ol> <p>Important</p> <p>If you haven't done so yet, make sure you update the quacc <code>WORKFLOW_ENGINE</code> configuration variable:</p> <pre><code>quacc set WORKFLOW_ENGINE redun\n</code></pre> <pre><code>from ase.build import bulk\nfrom redun import Scheduler\nfrom quacc import flow\nfrom quacc.recipes.emt.core import relax_job, static_job\n\n# Instantiate the scheduler\nscheduler = Scheduler()\n\n\n# Define the workflow\n@flow  # (1)!\ndef workflow(atoms):\n    # Define Job 1\n    result1 = relax_job(atoms)  # (2)!\n\n    # Define Job 2, which takes the output of Job 1 as input\n    result2 = static_job(result1[\"atoms\"])\n\n    return result2\n\n\n# Make an Atoms object of a bulk Cu structure\natoms = bulk(\"Cu\")\n\n# Dispatch the workflow\nresult = scheduler.run(workflow(atoms))\nprint(result)\n</code></pre> <ol> <li> <p>The <code>@flow</code> decorator defines the workflow that will be executed. It is the same as the <code>@task</code> decorator in Redun.</p> </li> <li> <p>The <code>relax_job</code> function was pre-defined in quacc with a <code>@job</code> decorator, which is why we did not need to include it here.</p> </li> </ol> <p>Important</p> <p>If you haven't done so yet, make sure you update the quacc <code>WORKFLOW_ENGINE</code> configuration variable:</p> <pre><code>quacc set WORKFLOW_ENGINE jobflow\n</code></pre> <pre><code>import jobflow as jf\nfrom ase.build import bulk\nfrom quacc.recipes.emt.core import relax_job, static_job\n\n# Make an Atoms object of a bulk Cu structure\natoms = bulk(\"Cu\")\n\n# Define Job 1\njob1 = relax_job(atoms)  # (1)!\n\n# Define Job 2, which takes the output of Job 1 as input\njob2 = static_job(job1.output[\"atoms\"])  # (2)!\n\n# Define the workflow\nworkflow = jf.Flow([job1, job2])  # (3)!\n\n# Run the workflow locally\nresponses = jf.run_locally(workflow, create_folders=True)  # (4)!\n\n# Get the result\nresult = responses[job2.uuid][1].output\nprint(result)\n</code></pre> <ol> <li> <p>The <code>relax_job</code> function was pre-defined in quacc with a <code>@job</code> decorator, which is why we did not need to include it here.</p> </li> <li> <p>In Jobflow, each <code>Job</code> is only a reference and so the <code>.output</code> must be explicitly passed between jobs.</p> </li> <li> <p>We must stitch the individual <code>Job</code> objects together into a <code>jf.Flow</code>, which can be easily achieved by passing them as a list to the <code>jf.Flow()</code> constructor.</p> </li> <li> <p>We chose to run the job locally, but other workflow managers supported by Jobflow can be imported and used.</p> </li> </ol>"},{"location":"user/wflow_engine/wflow_engines2.html#running-a-user-constructed-parallel-workflow","title":"Running a User-Constructed Parallel Workflow","text":"<p>Now we will define a workflow where we will carry out two EMT structure relaxations, but the two jobs are not dependent on one another. In this example, the workflow manager will know that it can run the two jobs separately, and even if Job 1 were to fail, Job 2 would still progress.</p> <pre><code>graph LR\n  A[Input] --&gt; B(Relax) --&gt; D[Output]\n  A[Input] --&gt; C(Relax) --&gt; D[Output];</code></pre> ParslCovalentRedunJobflow <pre><code>from ase.build import bulk, molecule\nfrom quacc.recipes.emt.core import relax_job\n\n\n# Define workflow\ndef workflow(atoms1, atoms2):\n    # Define two independent relaxation jobs\n    result1 = relax_job(atoms1)\n    result2 = relax_job(atoms2)\n\n    return {\"result1\": result1, \"result2\": result2}\n\n\n# Define two Atoms objects\natoms1 = bulk(\"Cu\")\natoms2 = molecule(\"N2\")\n\n# Define two independent relaxation jobs\nfutures = workflow(atoms1, atoms2)\n\n# Fetch the results\nresult1 = futures[\"result1\"].result()\nresult2 = futures[\"result2\"].result()\nprint(result1, result2)\n</code></pre> <pre><code>from ase.build import bulk, molecule\nfrom quacc import flow\nfrom quacc.recipes.emt.core import relax_job\n\n\n# Define workflow\n@flow\ndef workflow(atoms1, atoms2):\n    # Define two independent relaxation jobs\n    result1 = relax_job(atoms1)\n    result2 = relax_job(atoms2)\n\n    return {\"result1\": result1, \"result2\": result2}\n\n\n# Define two Atoms objects\natoms1 = bulk(\"Cu\")\natoms2 = molecule(\"N2\")\n\n# Dispatch the workflow to the Covalent server\ndispatch_id = ct.dispatch(workflow)(atoms1, atoms2)\n\n# Fetch the results from the server\nresult = ct.get_result(dispatch_id, wait=True)\nprint(result)\n</code></pre> <pre><code>from ase.build import bulk, molecule\nfrom redun import Scheduler\nfrom quacc import flow\nfrom quacc.recipes.emt.core import relax_job\n\n# Instantiate the scheduler\nscheduler = Scheduler()\n\n\n# Define workflow\n@flow\ndef workflow(atoms1, atoms2):\n    # Define two independent relaxation jobs\n    result1 = relax_job(atoms1)\n    result2 = relax_job(atoms2)\n\n    return {\"result1\": result1, \"result2\": result2}\n\n\n# Define two Atoms objects\natoms1 = bulk(\"Cu\")\natoms2 = molecule(\"N2\")\n\n# Dispatch the workflow\nresult = scheduler.run(workflow(atoms1, atoms2))\nprint(result)\n</code></pre> <pre><code>import jobflow as jf\nfrom ase.build import bulk, molecule\nfrom quacc.recipes.emt.core import relax_job\n\n# Define two Atoms objects\natoms1 = bulk(\"Cu\")\natoms2 = molecule(\"N2\")\n\n# Define two independent relaxation jobs\njob1 = relax_job(atoms1)\njob2 = relax_job(atoms2)\n\n# Define the workflow\nworkflow = jf.Flow([job1, job2])\n\n# Run the workflow locally\nresponses = jf.run_locally(workflow, create_folders=True)\n\n# Get the result\nresult = responses[job2.uuid][1].output\nprint(result)\n</code></pre>"},{"location":"user/wflow_engine/wflow_engines2.html#running-a-user-constructed-dynamic-workflow","title":"Running a User-Constructed Dynamic Workflow","text":"<p>For this example, let's consider a toy scenario where we wish to relax a bulk Cu structure, carve all possible slabs, and then run a new relaxation calculation on each slab (with no static calculation at the end).</p> <pre><code>graph LR\n  A[Input] --&gt; B(Relax) --&gt; C(Make Slabs)\n  C(Make Slabs) --&gt; D(Slab Relax) --&gt; H[Output]\n  C(Make Slabs) --&gt; E(Slab Relax) --&gt; H[Output]\n  C(Make Slabs) --&gt; F(Slab Relax) --&gt; H[Output]\n  C(Make Slabs) --&gt; G(Slab Relax) --&gt; H[Output];</code></pre> ParslCovalentRedunJobflow <pre><code>from ase.build import bulk\nfrom quacc.recipes.emt.core import relax_job\nfrom quacc.recipes.emt.slabs import bulk_to_slabs_flow\n\n\n# Define the workflow\ndef workflow(atoms):\n    relaxed_bulk = relax_job(atoms)\n    relaxed_slabs = bulk_to_slabs_flow(relaxed_bulk[\"atoms\"], run_static=False)  # (1)!\n\n    return relaxed_slabs\n\n\n# Define the Atoms object\natoms = bulk(\"Cu\")\n\n# Dispatch the workflow\nfuture = workflow(atoms)\n\n# Fetch the results\nresult = future.result()\nprint(result)\n</code></pre> <ol> <li>We chose to set <code>run_static=False</code> here to disable the static calculation that is normally carried out in this workflow.</li> </ol> <pre><code>import covalent as ct\nfrom ase.build import bulk\nfrom quacc import flow\nfrom quacc.recipes.emt.core import relax_job\nfrom quacc.recipes.emt.slabs import bulk_to_slabs_flow\n\n\n# Define the workflow\n@flow\ndef workflow(atoms):\n    relaxed_bulk = relax_job(atoms)\n    relaxed_slabs = bulk_to_slabs_flow(relaxed_bulk[\"atoms\"], run_static=False)  # (1)!\n\n    return relaxed_slabs\n\n\n# Define the Atoms object\natoms = bulk(\"Cu\")\n\n# Dispatch the workflow and retrieve result\ndispatch_id = ct.dispatch(workflow)(atoms)\nresult = ct.get_result(dispatch_id, wait=True)\nprint(result)\n</code></pre> <ol> <li>We didn't need to wrap <code>bulk_to_slabs_flow</code> with a decorator because it is already pre-decorated with a <code>@flow</code> decorator. We also chose to set <code>run_static=False</code> here to disable the static calculation that is normally carried out in this workflow.</li> </ol> <pre><code>from ase.build import bulk\nfrom redun import Scheduler\nfrom quacc import flow\nfrom quacc.recipes.emt.core import relax_job\nfrom quacc.recipes.emt.slabs import bulk_to_slabs_flow\n\nscheduler = Scheduler()\n\n\n# Define the workflow\n@flow\ndef workflow(atoms):\n    relaxed_bulk = relax_job(atoms)\n    relaxed_slabs = bulk_to_slabs_flow(relaxed_bulk[\"atoms\"], run_static=False)  # (1)!\n\n    return relaxed_slabs\n\n\n# Define the Atoms object\natoms = bulk(\"Cu\")\n\n# Run the workflow\nresult = scheduler.run(workflow(atoms))\nprint(result)\n</code></pre> <ol> <li>We didn't need to wrap <code>bulk_to_slabs_flow</code> with a decorator because it is already pre-decorated with a <code>@flow</code> decorator. We also chose to set <code>run_static=False</code> here to disable the static calculation that is normally carried out in this workflow.</li> </ol> <p>Limitations</p> <p>Due to the difference in how Jobflow handles workflows (particularly dynamic ones) compared to other supported workflow engines, any quacc recipes that have been pre-defined with a <code>@flow</code> decorator (i.e. have <code>_flow</code> in the name) cannot be run directly with Jobflow. Rather, a Jobflow-specific <code>Flow</code> needs to be constructed by the user.</p>"}]}